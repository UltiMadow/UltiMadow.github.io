<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <meta name="renderer" content="webkit">
  <meta http-equiv="X-UA-Compatible" content="IE=edge" >
  <link rel="dns-prefetch" href="http://example.com">
  <title>【做题笔记】 Atcoder Grand Contest | UM&#39;s blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="一些 OI 在役的遗产，写了 AGC001-062 的几乎所有题的题解（然后大部分现在也不会了（ 剩一个 AGC053F 不会做，题解也没看懂，就没写（ 文件较大，公式较多，卡顿注意（">
<meta property="og:type" content="article">
<meta property="og:title" content="【做题笔记】 Atcoder Grand Contest">
<meta property="og:url" content="http://example.com/2024/10/11/%E3%80%90%E5%81%9A%E9%A2%98%E7%AC%94%E8%AE%B0%E3%80%91%20Atcoder%20Grand%20Contest/index.html">
<meta property="og:site_name" content="UM&#39;s blog">
<meta property="og:description" content="一些 OI 在役的遗产，写了 AGC001-062 的几乎所有题的题解（然后大部分现在也不会了（ 剩一个 AGC053F 不会做，题解也没看懂，就没写（ 文件较大，公式较多，卡顿注意（">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://cdn.luogu.com.cn/upload/image_hosting/60xwyzom.png">
<meta property="og:image" content="https://img.atcoder.jp/agc051/71818d155faf01fd3d1684a7bb88c17e.png">
<meta property="og:image" content="https://img.atcoder.jp/agc051/abbe8b1ab54a58fc6005fcb8c73d4261.png">
<meta property="og:image" content="https://img.atcoder.jp/agc051/2d2147ada5ac09f277fd0688a67f3772.png">
<meta property="og:image" content="https://img.atcoder.jp/agc051/b8267b175e5261a237d23c233c86ee6d.png">
<meta property="og:image" content="https://img.atcoder.jp/agc051/f3c08bc39531e4cd1258b577ee5d9ebd.png">
<meta property="og:image" content="https://img.atcoder.jp/agc057/61b3000087dd8839269d74914b8cec53.png">
<meta property="article:published_time" content="2024-10-10T16:00:00.000Z">
<meta property="article:modified_time" content="2024-10-11T15:47:20.209Z">
<meta property="article:author" content="UMqwq">
<meta property="article:tag" content="做题笔记">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.luogu.com.cn/upload/image_hosting/60xwyzom.png">
  
    <link rel="alternative" href="/atom.xml" title="UM&#39;s blog" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  <link rel="stylesheet" type="text/css" href="/./main.0cf68a.css">
  <style type="text/css">
  
    #container.show {
      background: linear-gradient(200deg,#a0cfe4,#e8c37e);
    }
  </style>
  

  

<meta name="generator" content="Hexo 7.3.0"></head>

<body>
  <div id="container" q-class="show:isCtnShow">
    <canvas id="anm-canvas" class="anm-canvas"></canvas>
    <div class="left-col" q-class="show:isShow">
      
<div class="overlay" style="background: #4d4d4d"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			<img src="https://avatars.githubusercontent.com/u/63380871?v=4" class="js-avatar">
		</a>
		<hgroup>
		  <h1 class="header-author"><a href="/"></a></h1>
		</hgroup>
		

		<nav class="header-menu">
			<ul>
			
				<li><a href="/">主页</a></li>
	        
				<li><a href="/tags/%E9%9A%8F%E7%AC%94/">随笔</a></li>
	        
			</ul>
		</nav>
		<nav class="header-smart-menu">
    		
    			
    			<a q-on="click: openSlider(e, 'innerArchive')" href="javascript:void(0)">所有文章</a>
    			
            
    			
    			<a q-on="click: openSlider(e, 'friends')" href="javascript:void(0)">友链</a>
    			
            
    			
    			<a q-on="click: openSlider(e, 'aboutme')" href="javascript:void(0)">关于我</a>
    			
            
		</nav>
		<nav class="header-nav">
			<div class="social">
				
					<a class="github" target="_blank" href="https://github.com/UltiMadow" title="github"><i class="icon-github"></i></a>
		        
					<a class="bilibili" target="_blank" href="https://space.bilibili.com/2025913265" title="bilibili"><i class="icon-bilibili"></i></a>
		        
					<a class="mail" target="_blank" href="/umqwq@stu.pku.edu.cn" title="mail"><i class="icon-mail"></i></a>
		        
			</div>
		</nav>
	</header>		
</div>

    </div>
    <div class="mid-col" q-class="show:isShow,hide:isShow|isFalse">
      
<nav id="mobile-nav">
  	<div class="overlay js-overlay" style="background: #4d4d4d"></div>
	<div class="btnctn js-mobile-btnctn">
  		<div class="slider-trigger list" q-on="click: openSlider(e)"><i class="icon icon-sort"></i></div>
	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
				<img src="https://avatars.githubusercontent.com/u/63380871?v=4" class="js-avatar">
			</div>
			<hgroup>
			  <h1 class="header-author js-header-author"></h1>
			</hgroup>
			
			
			
				
			
				
			
			
			
			<nav class="header-nav">
				<div class="social">
					
						<a class="github" target="_blank" href="https://github.com/UltiMadow" title="github"><i class="icon-github"></i></a>
			        
						<a class="bilibili" target="_blank" href="https://space.bilibili.com/2025913265" title="bilibili"><i class="icon-bilibili"></i></a>
			        
						<a class="mail" target="_blank" href="/umqwq@stu.pku.edu.cn" title="mail"><i class="icon-mail"></i></a>
			        
				</div>
			</nav>

			<nav class="header-menu js-header-menu">
				<ul style="width: 50%">
				
				
					<li style="width: 50%"><a href="/">主页</a></li>
		        
					<li style="width: 50%"><a href="/tags/%E9%9A%8F%E7%AC%94/">随笔</a></li>
		        
				</ul>
			</nav>
		</header>				
	</div>
	<div class="mobile-mask" style="display:none" q-show="isShow"></div>
</nav>

      <div id="wrapper" class="body-wrap">
        <div class="menu-l">
          <div class="canvas-wrap">
            <canvas data-colors="#eaeaea" data-sectionHeight="100" data-contentId="js-content" id="myCanvas1" class="anm-canvas"></canvas>
          </div>
          <div id="js-content" class="content-ll">
            <article id="post-【做题笔记】 Atcoder Grand Contest" class="article article-type-post " itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      【做题笔记】 Atcoder Grand Contest
    </h1>
  

        
        <a href="/2024/10/11/%E3%80%90%E5%81%9A%E9%A2%98%E7%AC%94%E8%AE%B0%E3%80%91%20Atcoder%20Grand%20Contest/" class="archive-article-date">
  	<time datetime="2024-10-10T16:00:00.000Z" itemprop="datePublished"><i class="icon-calendar icon"></i>2024-10-11</time>
</a>
        
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>一些 OI 在役的遗产，写了 AGC001-062 的几乎所有题的题解（然后大部分现在也不会了（</p>
<p>剩一个 AGC053F 不会做，题解也没看懂，就没写（</p>
<p>文件较大，公式较多，卡顿注意（</p>
<span id="more"></span>

<h3 id="AGC001"><a href="#AGC001" class="headerlink" title="AGC001"></a>AGC001</h3><ul>
<li>A</li>
</ul>
<p>从小到大排序之后相邻两个配对即可</p>
<p>时间复杂度 $\mathcal O(n\log n)$</p>
<ul>
<li>B</li>
</ul>
<p>发现每两次反射之后剩余的图形都是个平行四边形</p>
<p>之后直接在辗转相除的时候统计答案即可</p>
<p>时间复杂度 $\mathcal O(\log n)$</p>
<ul>
<li>C</li>
</ul>
<p>枚举直径中点&#x2F;中边之后 dfs 统计一遍即可</p>
<p>时间复杂度 $\mathcal O(n^2)$ <del>（所以这题是怎么紫的</del></p>
<ul>
<li>D</li>
</ul>
<p>不难发现奇数最多只能有两个，并且只能放在最前面和最后面</p>
<p>然后构造序列 $b$ 为 $a_1-1,a_2,\dots,a_{m-1},a_m+1$ 即可满足条件</p>
<p>时间复杂度 $\mathcal O(m)$，注意特判 $m&#x3D;1$</p>
<ul>
<li>E</li>
</ul>
<p>考虑这个式子的几何意义</p>
<p>$\binom{a_i+a_j+b_i+b_j}{a_i+a_j}$ 即从 $(-a_i,-b_i)$ 到 $(a_j,b_j)$ 的最短路条数</p>
<p>于是就转化为了多源最短路计数问题，从左下角往右上角扫一遍，最后减去 $(-a_i,-b_i)$ 到 $(a_i,b_i)$ 的再除以 2 即可</p>
<p>时间复杂度 $\mathcal O(w^2)$（$w$ 为值域）</p>
<ul>
<li>F</li>
</ul>
<p>把 $p$ 转化为它的逆排列 $p’$ 之后题目就和 <a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P8099">P8099 [USACO22JAN] Minimizing Haybales P</a> 一样了</p>
<h3 id="AGC002"><a href="#AGC002" class="headerlink" title="AGC002"></a>AGC002</h3><ul>
<li>D</li>
</ul>
<p>询问离线，整体二分，每次暴力维护出连通块大小即可，需要一个支持撤销的并查集</p>
<p>也可以用 kruskal 重构树+二分在线解决</p>
<p>时间复杂度 $\mathcal O(n\log^2n)$</p>
<ul>
<li>E</li>
</ul>
<p>将糖果先从大到小排序</p>
<p>把 ${a_i}$ 画成网格图，第 $i$ 列高 $a_i$</p>
<p>于是就转化成从原点开始走，每次可以向上走 1 格或者向右走 1 格，走到边界就输了</p>
<p>显然边界上先手必胜，每条对角线除了边界以外状态相同</p>
<p>于是先沿原点所在的对角线走，走到不能走为止，如果接下来向上或者向右有一个距离为奇数，那么先手必胜，否则必败</p>
<p>时间复杂度 $\mathcal O(n)$</p>
<ul>
<li>F</li>
</ul>
<p>设 $f_{i,j}$ 为放了 $i$ 个白球，$j$ 种其他颜色的球的方案数</p>
<p>考虑当前最前面没放球的位置放什么颜色的球，直接转移即可</p>
<p>时间复杂度 $\mathcal O(nk)$</p>
<h3 id="AGC003"><a href="#AGC003" class="headerlink" title="AGC003"></a>AGC003</h3><ul>
<li>A</li>
</ul>
<p>有 <code>N</code> 一定有 <code>S</code>，有 <code>E</code> 一定有 <code>W</code></p>
<p>时间复杂度 $\mathcal O(n)$</p>
<ul>
<li>B</li>
</ul>
<p>按面值从小到大扫一遍，贪心匹配</p>
<p>时间复杂度 $\mathcal O(n)$</p>
<ul>
<li>C</li>
</ul>
<p>翻转相邻三个元素不会改变下标奇偶性</p>
<p>于是奇偶错误的元素两两匹配即可</p>
<p>时间复杂 $\mathcal O(n)$</p>
<ul>
<li>D</li>
</ul>
<p>先把每个数中的立方因子去掉，这部分复杂度 $\mathcal O(n\sqrt[3] a)$</p>
<p>考虑先用 $\sqrt[3]a$ 以下的数分解质因数，记剩下的数为 $x$</p>
<p>根据 $x$ 给 $a$ 分类：</p>
<ol>
<li>$x&#x3D;1$</li>
<li>$x$ 为完全平方数</li>
<li>$x$ 为 $\le \sqrt a$ 的质数</li>
<li>其他数</li>
</ol>
<p>显然只有第 1 类内部匹配和第 2 类匹配第 3 类可以组成完全立方数</p>
<p>于是用 map 维护一个桶然后贪心选即可</p>
<p>时间复杂度 $\mathcal O(n\sqrt[3]a)$</p>
<ul>
<li>E</li>
</ul>
<p>先把 $a$ 预处理成单调增的序列</p>
<p>设 $f_i$ 为第 $i$ 次操作后的序列在最后的序列中出现了多少次</p>
<p>考虑倒推一下，首先有 $\lfloor \frac{a_i}{a_{i-1}}\rfloor f_i\to f_{i-1}$，接下来考虑剩下的 $q&#x3D;a_i \bmod a_{i-1}$ 对答案的贡献</p>
<p>先二分找到一个位置 $p$，$a_p\le q&lt;a_{p+1}$，不难发现 $i\to q$ 的关系和 $i\to {i-1}$ 是一样的</p>
<p>于是不断取模递归解决即可，边界 $p&#x3D;0$ 时可以差分解决</p>
<p>最后对差分数组前缀和一下即可</p>
<p>时间复杂度 $\mathcal O(n\log^2 n)$（大概可以参考辗转相除的复杂度？）</p>
<ul>
<li>F</li>
</ul>
<p>连通块个数&#x3D;黑点个数-左右相邻两个都是黑点的个数</p>
<p>考虑 $k$ 到 $k+1$ 图的变化</p>
<p>如果存在一行左右两端都是黑色，那么这个图左右可以连通</p>
<p>如果存在一列上下两段都是黑色，那么这个图上下可以连通</p>
<p>如果上下左右同时连通，那么答案为 1</p>
<p>如果上下左右同时不连通，那么答案为 $cnt^{k-1}$，$cnt$ 为黑点个数</p>
<p>不妨设图左右连通（上下联通同理）</p>
<p>设黑点个数为 $cnt$，左右相邻两个都是黑点的个数为 $pi$，左右两端都是黑色的行数为 $e$</p>
<p>那么 $(cnt,pi,e)$ 的变化关系很容易用一个矩阵描述出来：</p>
<p>$$<br>\begin{bmatrix}<br>cnt &amp;pi\cr<br>0&amp;e<br>\end{bmatrix}^{k-1}<br>$$</p>
<p>于是矩阵快速幂计算即可</p>
<p>时间复杂度 $\mathcal O(nm+\log k)$</p>
<h3 id="AGC004"><a href="#AGC004" class="headerlink" title="AGC004"></a>AGC004</h3><ul>
<li>A</li>
</ul>
<p>$a,b,c$ 中存在偶数答案为 0，都是奇数答案为 $\min{ab,bc,ca}$</p>
<ul>
<li>B</li>
</ul>
<p>枚举使用膜法的次数 $p$，则获得颜色 $i$ 的代价为 $\min\limits_{i-p\le j\le i}a_i$</p>
<p>暴力扫一遍即可，时间复杂度 $\mathcal O(n^2)$</p>
<ul>
<li>C</li>
</ul>
<p>构造这样的底图：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#####.        .....#</span><br><span class="line">#.....        .#####</span><br><span class="line">#####.        .....#</span><br><span class="line">#.....        .#####</span><br><span class="line">#####.        .....#</span><br><span class="line">#.....        .#####</span><br></pre></td></tr></table></figure>

<p>需要重合的地方把两张图都设置成 <code>#</code> 就行了</p>
<p>时间复杂度 $\mathcal O(nm)$</p>
<ul>
<li>D</li>
</ul>
<p>先把 1 变成自环，然后就是经典贪心了（</p>
<p>时间复杂度 $\mathcal O(n)$</p>
<ul>
<li>E</li>
</ul>
<p>换个参照物，假设机器人不动，出口在动</p>
<p>设 $f_{l,r,d,u}$ 表示出口目前最远想左走了 $l$，向右走了 $r$，向下走了 $d$，向上走了 $u$，最多能救下的机器人数</p>
<p>于是每次枚举向哪个方向扩展一格，救下的机器人数一定是一行或一列上的一个区间，于是用前缀和维护一下即可</p>
<p>时间复杂度 $\mathcal O(n^4)$</p>
<ul>
<li>F</li>
</ul>
<p>将整张图黑白染色一下，把操作转化成两个点如果颜色不同则可以交换</p>
<p>再进一步转化成黑色点有球，白色点有洞，每次可以移动一个球，目标是让所有球都进洞，并且步数最少</p>
<ol>
<li>$m&#x3D;n-1$</li>
</ol>
<p>此时图是一棵树，一定是二分图，存在黑白染色</p>
<p>设 $a_u$ 为 $u$ 子树内球的个数，$b_u$ 为洞的个数</p>
<p>考虑 $u$ 到它父亲的这条边最少经过的次数，为 $|a_u-b_u|$</p>
<p>那么 $\sum|a_u-b_u|$ 即为答案（当然总球数不等于总洞数时无解）</p>
<ol start="2">
<li>$m&#x3D;n$ 且环为偶环</li>
</ol>
<p>此时图仍然是二分图，存在黑白染色</p>
<p>考虑非树边 $p\to q$ 上被球经过的次数 $x$，我们规定 $p\to q$ 算经过 $1$ 次，$q\to p$ 算经过 $-1$ 次</p>
<p>设 $p$ 到根的路径上点集为 $P$，$q$ 到根路径上点集为 $Q$（$P,Q$ 都不包括根）</p>
<p>那么答案为 $\sum\limits_{u\not\in P\cup Q}|a_u-b_u|+\sum\limits_{u\in P}|(a_u-x)-b_u|+\sum\limits_{u\in Q}|a_u-(b_u-x)|+|x|$</p>
<p>这个东西排序取中位数就好了</p>
<ol start="3">
<li>$m&#x3D;n$ 且环为奇环</li>
</ol>
<p>这时图不是二分图了，设黑白染色冲突的两个点为 $p$ 和 $q$</p>
<p>不难发现 $p\to q$ 的边使用一次可以使球的个数增加或减少 2</p>
<p>于是这条边需要操作几次就可以算出来了，之后把这条边断掉然后按树的方法做即可</p>
<p>时间复杂度 $\mathcal O(n\log n)$</p>
<h3 id="AGC005"><a href="#AGC005" class="headerlink" title="AGC005"></a>AGC005</h3><ul>
<li>A</li>
</ul>
<p>栈，括号匹配，时间复杂度 $\mathcal O(n)$</p>
<ul>
<li>B</li>
</ul>
<p>单调栈维护 $i$ 前后第一个 $&lt;a_i$ 的，然后扫一遍统计答案即可</p>
<p>时间复杂度 $\mathcal O(n)$</p>
<ul>
<li>C</li>
</ul>
<p>记这棵树的直径长度为 $L$</p>
<ol>
<li>$L$ 为奇数</li>
</ol>
<p>直径上有偶数个点，最小的距离为 $\lceil \frac L2\rceil$，距离为 $\lceil\frac L2\rceil$ 的恰好有两个，$&gt;\lceil\frac L2\rceil$ 的至少有两个</p>
<ol start="2">
<li>$L$ 为偶数</li>
</ol>
<p>直径上有奇数个点，最小的距离为 $\frac L2$，距离为 $\frac L2$ 的恰好有一个，$&gt;\frac L2$ 的至少有两个</p>
<p>时间复杂度 $\mathcal O(n)$</p>
<ul>
<li>D</li>
</ul>
<p>设 $f_i$ 表示恰好 $i$ 个位置不合法的情况数，$g_i$ 表示钦定 $i$ 个位置不合法的情况数</p>
<p>那么 $g_i&#x3D;\sum\limits_{j\ge i}\binom ji f_j$，二项式反演一下得到 $f_i&#x3D;\sum\limits_{j\ge i}(-1)^{j-i}\binom j ig_j$</p>
<p>答案即为 $f_0&#x3D;\sum\limits_{i\le n}(-1)^{i}g_i$</p>
<p>把匹配的形式画成二分图，那么不合法的可能匹配形成了 $2k$ 条形如 $(i,0)\to(i+k,1)\to(i+2k,0)\to \cdots$ 的链，记链长为 $len$</p>
<p>如果我们要在 $len$ 长度的链中选择 $x$ 个匹配，根据插板法，方案数为 $\binom{len-x}{x}$</p>
<p>于是把所有链的 OGF 卷起来就好了，最后乘上随便选的方案数 $(n-i)!$ 即可</p>
<p>时间复杂度 $\mathcal O(nk\frac nk)&#x3D;\mathcal O(n^2)$</p>
<ul>
<li>E</li>
</ul>
<p>如果 A 树上存在相邻的两个点在 B 树上的距离 $\ge 3$，并且先手能走到这个节点，那么游戏可以无限进行下去</p>
<p>有一个性质：先手一定不会走到一个满足在 A 中深度大于等于在 B 中深度的点 $u$</p>
<p>这是因为 A 树上相邻两个点在 B 树上距离 $\le 2$，所以先手并不能跨越后手</p>
<p>于是 dfs 合法的节点，停在 B 树深度最大的节点上即可</p>
<p>时间复杂度 $\mathcal O(n)$</p>
<ul>
<li>F</li>
</ul>
<p>考虑每个点对答案的贡献</p>
<p>则 $f_i&#x3D;\sum_u (\binom ni-\sum\binom {sz_v}i)$ 其中 $v$ 为 $u$ 为根时 $u$ 的儿子</p>
<p>记 $g_i $ 为大小为 $i$ 的子树个数，则 $f_i&#x3D;n\binom ni-\sum_j g_j\binom ji$</p>
<p>后面那一项是一个差卷积的形式，直接 NTT 即可</p>
<p>（热知识：$924844033&#x3D;441\times 2^{21}+1$ 的原根是 5）</p>
<p>时间复杂度 $\mathcal O(n\log n)$</p>
<h3 id="AGC006"><a href="#AGC006" class="headerlink" title="AGC006"></a>AGC006</h3><ul>
<li>A</li>
</ul>
<p>暴力。时间复杂度 $\mathcal O(n^2)$</p>
<ul>
<li>B</li>
</ul>
<p>$x&#x3D;1$ 或者 $x&#x3D;2n-1$ 时无解</p>
<p>其他的只要令 $x-1,x,x+1$ 在 $n-1,n,n+1$ 三个位置即可</p>
<p>时间复杂度 $\mathcal O(n)$</p>
<ul>
<li>C</li>
</ul>
<p>考虑操作一个兔子它坐标期望变成多少</p>
<p>$x’<em>i&#x3D;\frac {2x</em>{i-1}-x_i+2x_{i+1}-x_i}2&#x3D;x_{i-1}+x_{i+1}-x_i$，不难发现这可以转化为交换相邻的两个差分</p>
<p>于是看每个差分值被交换到哪里就行了</p>
<p>时间复杂度 $\mathcal O(n)$</p>
<ul>
<li>D</li>
</ul>
<p>先二分答案，把 $\le mid$ 的设置成 0，其余设置成 1，求这个 01 序列的答案</p>
<p>不难发现除了 <code>01010...1010</code> 和 <code>10101..0101</code> 两种情况外，其他都是靠 $n$ 最近的连续两个 0 或 连续两个 1 成为答案，于是就可以 $\mathcal O(n)$ 判断答案是 0 还是 1</p>
<p>时间复杂度 $\mathcal O(n\log n)$</p>
<ul>
<li>E</li>
</ul>
<p>翻转相邻的三列不影响奇偶性，所以可以先把奇偶性判掉</p>
<p>对奇偶列分开考虑，每交换一次可以减少一个逆序对，所以交换次数的奇偶性和逆序对的奇偶性相同</p>
<p>交换奇数列相邻的两个会导致偶数列翻转奇数次，奇数列翻转偶数次，偶数列同理</p>
<p>所以翻转次数的奇偶性也确定了，判断一下和交换次数的一致性即可</p>
<p>时间复杂度 $\mathcal O(n\log n)$</p>
<ul>
<li>F</li>
</ul>
<p>题意转化一下，$(i,j)$ 是黑色就连一条 $i\to j$ 的边</p>
<p>考虑对图进行三染色，对于每个连通块分开来计算</p>
<ol>
<li>三染色失败，不难发现这个连通块最终会被连成完全图</li>
<li>三染色成功，但只有一种颜色或两种颜色，这时没有其他边能连</li>
<li>三染色成功，用了三种颜色，设三种颜色的集合分别为 $S_0,S_1,S_2$，那么 $S_0\to S_1,S_1\to S_2,S_2\to S_0$ 全部有边</li>
</ol>
<p>时间复杂度 $\mathcal O(n)$</p>
<h3 id="AGC007"><a href="#AGC007" class="headerlink" title="AGC007"></a>AGC007</h3><ul>
<li>A</li>
</ul>
<p>每行一定是连续区间，每列一定是连续区间，相邻两行区间交为 1，相邻两列区间交为 1</p>
<ul>
<li>B</li>
</ul>
<p>设 $S&#x3D;20001$</p>
<p>构造 $a_i&#x3D;iS$，$b_i&#x3D;(n-i)S+id_i$，其中 $id_{p_i}&#x3D;i$</p>
<p>时间复杂度 $\mathcal O(n)$</p>
<ul>
<li>C</li>
</ul>
<p>考虑第 $i$ 段距离在一次球进洞之后期望长度变化</p>
<p>可能使 $d_i$ 变化的情况：</p>
<ol>
<li>球滚过第 $i+1$ 段距离，$i,i+1,i+2$ 三段合成一段</li>
<li>前 $i$ 段距离中有一段被球滚过，$i+2$ 段变成新的第 $i$ 段</li>
</ol>
<p>于是有 $E(d_i)&#x3D;d_i+\frac{i(d_{i+2}-d_i)+d_{i+1}+d_{i+2}}{2n}&#x3D;d_i+\frac{2xi+d_{i+1}+d_{i+2}}{2n}$</p>
<p>不难发现 $E(d_i)$ 也是一个等差数列，首项 $E(d_1)&#x3D;d_1+\frac{2d+5x}{2n}$，公差 $x’&#x3D;x+\frac{4x}{2n}&#x3D;x+\frac{2x}{n}$，项数 $n’&#x3D;n-2$</p>
<p>于是每次移动算一下期望就行了</p>
<p>时间复杂度 $\mathcal O(n)$</p>
<ul>
<li>D</li>
</ul>
<p>感觉 D 比 C 简单（</p>
<p>设 $f_i$ 表示收到了前 $i$ 只熊的金币的最少时间</p>
<p>则枚举 $j$，$j$ 之后的最优路线为 $j+1\to i\to j+1\to i$</p>
<p>分类讨论一下到达 $i$ 之后回到 $j+1$ 时金币是否已经产出，一部分用单调队列维护，另一部分直接维护前缀最大值即可</p>
<p>时间复杂度 $\mathcal O(n)$</p>
<ul>
<li>E</li>
</ul>
<p>首先二分答案 $mid$</p>
<p>设 $f_u(l,r)$ 表示 $u$ 子树中进入子树的距离为 $l$，离开子树的距离为 $r$ 是否可行</p>
<p>如果 $u$ 中两个状态 $(l_1,r_1)$ 和 $(l_2,r_2)$ 有 $l_1\le l_2$ 且  $r_1\le r_2$ 那么显然 $(l_2,r_2)$ 永远不可能最优，可以直接去掉</p>
<p>那么将一个节点的 $(l,r)$ 按 $l$ 从小到大排序后，$r$ 一定单调递减</p>
<p>接下来考虑合并 $u$ 的两个子树 $lc$ 和 $rc$</p>
<p>不妨设我们先进入的是 $lc$ 子树，设当前状态为 $(l_{lc,i},r_{lc,i})$，显然合并后的状态的 $l$ 已经确定了，这时候需要选择一个 $r_{lc,i}+l_{rc,j}$ 合法的且 $r_{rc,j}$ 最小的 $j$ 出来，由于 $r$ 的单调性，所以一定选择满足条件中 $l$ 最大的那一个</p>
<p>于是用一个指针维护一下就行了</p>
<p>由于是满二叉树，所以每一层节点的状态数和都是 $\mathcal O(n)$ 的，所以总复杂度 $\mathcal O(n\log ^2n)$</p>
<ul>
<li>F</li>
</ul>
<p>考虑把复制字符的过程用一个折线图表示出来</p>
<p>倒序考虑每一条折线，最优的折线一定会被上一条折线卡住，新的折点坐标为原折点坐标加上 $(-1,1)$</p>
<p>于是可以用队列维护这些折点，每次如果起点和上一个起点没有卡住，则新建一个折点；如果最后的区间把原先的折点覆盖了，那么删去这些折点</p>
<p>最后答案即为过程中队列的最大的长度</p>
<p>时间复杂度 $\mathcal O(n)$</p>
<h3 id="AGC008"><a href="#AGC008" class="headerlink" title="AGC008"></a>AGC008</h3><ul>
<li>A</li>
</ul>
<p>vp 的时候差点脑抽写大分类讨论交上去（</p>
<p>一共只有 $x\to y$，$x\to -y\to y$，$x\to -x\to y$，$x\to -x\to -y\to y$ 四种可能性，取最小值即可</p>
<ul>
<li>B</li>
</ul>
<p>一定会有连续 $k$ 个格子同色，枚举这 $k$ 个格子，其他格子贪心选正的就行了</p>
<p>时间复杂度 $\mathcal O(n)$</p>
<ul>
<li>C</li>
</ul>
<p>不难发现 T，S，Z 三种方块没用（奇偶性不对）</p>
<p>O 方块可以直接使用</p>
<p>两个 I，J，L 可以拼成长方形，一个 I，一个 J，一个 L 一起可以拼成长方形（当然奇数个 I 也可以，但是可以等价地把其中偶数个 I 拿出去单独拼）</p>
<p>于是贪心去匹配就行了</p>
<p>时间复杂度 $\mathcal O(1)$</p>
<ul>
<li>D</li>
</ul>
<p>先把 $a$ 从小到大排序，正着扫一遍，把前 $i$ 个 $i$ 都填进去</p>
<p>再把 $a$ 从大到小排序，倒着扫一遍，把后 $n-i$ 个 $i$ 填进去</p>
<p>时间复杂度 $\mathcal O(n\log n)$</p>
<ul>
<li>E</li>
</ul>
<p>vp 的时候差一点做出来了（</p>
<p>先把 $i\leftarrow a_i$ 的基环森林建出来，把环和基环树分开考虑</p>
<ol>
<li>基环树</li>
</ol>
<p>不难发现只有环和若干链组成的基环树符合条件，而我们的目标是把链压到环上</p>
<p>设当前链和下一条链距离为 $s$，当前链长度为 $l$</p>
<p>$l&gt;s$ 显然不行，$l&#x3D;s$ 只有一种方法，$l&lt;s$ 有两种方法</p>
<p>每条链独立，所以对每一个基环树算 2 的幂次即可</p>
<ol start="2">
<li>环</li>
</ol>
<p>偶环只有一种方法，奇环（长度大于 1）有两种方法</p>
<p>同时两个相同长度的环可以有环长种方式合并，于是对于每种环长枚举匹配几个，用组合数算一下匹配数即可</p>
<p>时间复杂度 $\mathcal O(n\log n)$（瓶颈在快速幂）</p>
<ul>
<li>F</li>
</ul>
<p>先做子任务：所有点都是关键点</p>
<p>记 $f(u,d)$ 为 $u$ 节点距离 $\le d$ 的所有点的集合</p>
<p>考虑如何不重不漏地统计这些集合</p>
<p>我们每次只在一个集合 $d$ 最小的位置来统计这个集合，全集在此处不统计</p>
<p>于是要求不存在 $f(v,d-1)&#x3D;f(u,d)$，不难发现这个等价于 $dis_{u&#x2F;v}&gt;d-2$，其中 $dis_{u&#x2F;v}$ 表示除了 $v$ 子树里的点之外距离 $u$ 最远的距离，限制最强的即为 $d\le sec_u+1$，其中 $sec_u$ 表示距离 $u$ 次远的距离</p>
<p>有点不是关键点时，我们仍然这样统计，只是对 $d$ 多了一个下界</p>
<p>如果 $u$ 为关键点，那么下界显然为 0,</p>
<p>如果 $u$ 不为关键点，并且希望能够代表一个集合 $f(v,d)$，$v$ 为关键点，那么一定要满足 $f(v,d)$ 覆盖了所有 $v$ 所在的 $u$ 的子树中的点，否则一定在 $u\to v$ 之间可以找到一个点 $w$ 它的 $d$ 值更小</p>
<p>于是用换根 dp 就可以算出每个点的上界和下界</p>
<p>时间复杂度 $\mathcal O(n)$</p>
<h3 id="AGC009"><a href="#AGC009" class="headerlink" title="AGC009"></a>AGC009</h3><ul>
<li>A</li>
</ul>
<p>倒序扫一遍，贪心增加，时间复杂度 $\mathcal O(n)$</p>
<ul>
<li>B</li>
</ul>
<p>先建出 $a_u\to u$ 的树</p>
<p>设 $f_u$ 表示 $u$ 子树内比赛树的最小深度</p>
<p>显然在转移的时候应该将 $f_v$ 从小到大排序转移进 $f_u$</p>
<p>时间复杂度 $\mathcal O(n\log n)$</p>
<ul>
<li>C</li>
</ul>
<p>设 $f_i$ 表示 $i$ 在 X 集合中，$i+1$ 在 Y 集合中（或者不存在）的方案数；$g_i$ 表示 $i$ 在 Y 集合中，$i+1$ 在 X 集合中的方案数</p>
<p>显然转移有一个上下界，预处理出来就可以用前缀和维护转移</p>
<p>时间复杂度 $\mathcal O(n\log n)$（偷懒用了二分预处理（</p>
<ul>
<li>D</li>
</ul>
<p>题意即为给每个点 $u$ 一个 $f_u$，使 $f$ 相同的两个点之间存在一个点的 $f$ 值比它们大</p>
<p>点分树一定是一种合法的解，于是 $f$ 值最大是不会超过 $\log n$</p>
<p>设 $g_u$ 为 $u$ 子树中还没匹配的数集，由于 $f$ 很小所以可以压成一个整数</p>
<p>在 $g_v$ 中出现至少两次的数一定要在 $u$ 这个位置被匹配掉，于是 $u$ 的取值有了一个下界</p>
<p>如果 $f_u$ 在任意一个 $g_v$ 中出现，一定不符合要求</p>
<p>于是贪心地确定 $f$ 即可</p>
<p>时间复杂度 $\mathcal O(n\log n)$（应该也可以用 <code>__builtin</code> 函数做到 $\mathcal O(n)$</p>
<ul>
<li>E</li>
</ul>
<p>先转化一下题意：一棵树，非叶子节点都有 $k$ 个儿子，叶子有 0&#x2F;1 权值，0 有 $n$ 个，1 有 $m$ 个，每个点的权值是儿子节点的代数平均值，求根节点有多少种可能的权值</p>
<p>设第 $i$ 个 0 深度为 $x_i$，第 $i$ 个 1 深度为 $y_i$，则根节点权值为 $z&#x3D;\sum k^{-y_i}$</p>
<p>考虑这个 $z$ 要满足什么条件</p>
<p>如果所有叶子节点权值全部为 1，则有 $\sum k^{-x_i}+\sum k^{-y_i}&#x3D;1$，$\sum k^{-x_i}&#x3D;1-z$</p>
<p>把 $z$ 写成 $k$ 进制小数的形式：$0.z_1z_2z_3\dots$</p>
<p>那么有数字和 $\sum z_i\le m$，每次进位会导致数字和减少 $k-1$，则 $\sum z_i\equiv m\pmod {k-1}$</p>
<p>对于 $1-z$，设 $z$ 的小数位数为 $l$，则 $1-z$ 的数字和为 $p&#x3D;(l-1)(k-1)+l-\sum z_i$</p>
<p>同样地，有 $p\le n$，$p\equiv n\pmod {k-1}$</p>
<p>于是可以有一个 dp：设 $f_{i,j,0&#x2F;1}$ 表示 $z$ 小数有 $i$ 位，$z$ 的数字和为 $j$，有&#x2F;没有后缀 0 的方案数</p>
<p>用前缀和优化一下转移即可，时间复杂度 $\mathcal O(n^2)$</p>
<h3 id="AGC010"><a href="#AGC010" class="headerlink" title="AGC010"></a>AGC010</h3><ul>
<li>A</li>
</ul>
<p>有奇数个奇数答案为 <code>NO</code>，否则为 <code>YES</code></p>
<ul>
<li>B</li>
</ul>
<p>总操作次数 $s&#x3D;\frac{2\sum a}{n(n+1)}$</p>
<p>$a_{i+1}$ 可以是 $a_i+s-k_in$，要求 $\sum k_i\le s$，扫一遍判断一下即可</p>
<p>时间复杂度 $\mathcal O(n)$</p>
<ul>
<li>C</li>
</ul>
<p>题目要求相当于给每条边一个 $f$ 值，使得叶子节点 $u$ 相连的边的 $f$ 值为 $a_u$，非叶子节点 $u$ 相连的边的 $f$ 值之和为 $2a_u$</p>
<p>设 $f_u$ 为 $u\to fa$ 这条边的 $f$ 值，那么显然有 $f_u&#x3D;2a_u-\sum f_v$</p>
<p>接下来考虑每个 $f$ 值要满足什么条件</p>
<p>对于每个 $f_u$，显然要求 $0\le f_u\le a_u$</p>
<p>由于我们每次要选择两个子树进行匹配，子树不能自己和自己匹配，所以有 $\max{f_u,f_v}\le \frac{2a_u}{2}&#x3D;a_u$</p>
<p>注意特判一下所有点都是叶子（$n&#x3D;2$）的情况就行了</p>
<p>时间复杂度 $\mathcal O(n)$</p>
<ul>
<li>D</li>
</ul>
<p>不难发现出现一个 1 的时候胜负就确定了：有奇数个偶数则先手必胜，否则后手必胜</p>
<p>于是我们考虑每次操作时偶数个数的奇偶性变化</p>
<ol>
<li><p>终止状态：出现 1，有奇数个偶数先手必胜，否则后手必胜</p>
</li>
<li><p>有奇数个偶数：此时先手必胜（先手任意操作一个偶数，此时一定有偶数个偶数且要么出现 1 跳到状态 1，要么有大于 1 个奇数跳到状态 3）</p>
</li>
<li><p>有偶数个偶数且有大于 1 个奇数：此时后手必胜（先手任意操作，此时一定有奇数个偶数，跳到状态 1 或者状态 2）</p>
</li>
<li><p>有偶数个偶数且有一个奇数：此时先手可以操作唯一的一个奇数，此时所有数至少 $\div 2$，局面交给后手判断</p>
</li>
</ol>
<p>时间复杂度 $\mathcal O(n\log ^2a)$</p>
<ul>
<li>E</li>
</ul>
<p>考虑序列给定一个序列后手如何操作才能使序列字典序最大</p>
<p>对于 $i&lt;j$，$\gcd(a_i,a_j)&gt;1$，那么最终序列中 $a_i$ 一定在 $a_j$ 之前，于是我们可以连边 $i\to j$</p>
<p>对这个图进行拓扑排序就是一个可行的最终序列</p>
<p>要求字典序最大，把拓扑排序中的队列换成优先队列即可</p>
<p>接下来看先手如何排列才能使最终序列的字典序最小</p>
<p>对于任意 $i,j$，$\gcd(a_i,a_j)&gt;1$，我们连边 $i\leftrightarrow j$，先手要做的就是把这个无向图的边定向成一个 DAG，使得拓扑序的字典序最小</p>
<p>对于每个连通块，我们可以使最小的那个排在前面，然后贪心地 dfs 下去，这样这棵 dfs 树就是最优的 DAG 了</p>
<p>时间复杂度 $\mathcal O(n^2\log a)$</p>
<ul>
<li>F</li>
</ul>
<p>先考虑 $n&#x3D;2$，显然如果 $a_p&gt; a_q$ 那么 $p$ 点先手必胜</p>
<p>如果是菊花树的情况：对于树根 $u$，如果存在一个叶子 $v$ 使得 $a_u&gt;a_v$ 则 $u$ 点先手必胜</p>
<p>考虑如何把这样的情况拓展到一般的树上</p>
<p>设 $f_u$ 为只考虑 $u$ 的子树，棋子放在 $u$ 上是否先手必胜</p>
<p>于是有转移：如果存在 $f_v&#x3D;0$ 且 $a_v&lt;a_u$，则 $f_u&#x3D;1$，否则 $f_u&#x3D;0$</p>
<p>（先手不可能移动到一个先手必胜的子树中，后手到达先手必败的子树后一定会尝试向子树外走，就转化成了 $n&#x3D;2$ 的情况）</p>
<p>于是对于每个点都作为树根 dp 一次即可，时间复杂度 $\mathcal O(n^2)$</p>
<h3 id="AGC011"><a href="#AGC011" class="headerlink" title="AGC011"></a>AGC011</h3><ul>
<li>A</li>
</ul>
<p>排序后贪心，每辆车装满&#x2F;不能接下一个人时发车</p>
<p>时间复杂度 $\mathcal O(n\log n)$</p>
<ul>
<li>B</li>
</ul>
<p>从大到小排序，维护 $f_i$ 表示向前最多吃到哪里</p>
<p>每次暴力向前跳，能吃到 $i$ 就一定能吃到 $f_i$，所以跳跃次数均摊 $\mathcal O(1)$</p>
<p>时间复杂度 $\mathcal O(n\log n)$</p>
<ul>
<li>C</li>
</ul>
<p><del>考场把连通块个数统计写错了，怒恰三个罚时（</del></p>
<p>对于点 $(i,j)$，我们考虑哪些点能和它连通</p>
<p>对于点 $(u,v)$，如果存在两条路径 $i\to u$，$j\to v$ 使得两条路径长度相等，则它们在同一连通块中</p>
<p>而由于这是一个无向图，所以如果 $i$ 能走 $d$ 步到 $u$，则也可以走 $d+2$ 步到 $u$</p>
<p>那么条件就可以转化为 $i\to u$，$j\to v$ 两条路径长的奇偶性相同了</p>
<p>不难发现如果一个连通块中存在奇环则 $i\to u$ 既可以走奇数步又可以走偶数步；而不存在奇环时连通块是一个二分图，则奇数步和偶数步不等价</p>
<p>考虑记录单点的个数 $c0$，二分图的个数 $c1$，非二分图的个数 $c2$</p>
<p>则单点对答案贡献为 $2nc0-c0^2$；两个二分图对答案贡献为 $2c1^2$；两个非二分图对答案贡献为 $c2^2$；一个二分图一个非二分图对答案贡献为 $2c1c2$</p>
<p>时间复杂度 $\mathcal O(n)$</p>
<ul>
<li>D</li>
</ul>
<p>考虑每次放进球会使字符串变成什么</p>
<p>如果左端为 <code>A</code>，则左端会变成 <code>B</code>，球会直接从左端出来</p>
<p>如果左端为 <code>B</code>，则不难发现球会从右端出来，根据大眼观察法可以得到操作后的字符串为原字符串取反后循环左移一位</p>
<p>不难发现 <code>BABAB...</code> 操作后不变；字符串长为偶数时 <code>ABABA...</code> 和 <code>BABAB...</code> 相互转化</p>
<p>所以如果 $k&gt;2n$ 时取 $k’&#x3D;2n+[k\bmod 2&#x3D;1]$ 答案不变</p>
<p>然后维护偏移量直接模拟即可</p>
<p>时间复杂度 $\mathcal O(n)$</p>
<ul>
<li>E</li>
</ul>
<p>「递增的」数可以被拆分为至多 $9$ 个形如 $111\dots1$ 的数</p>
<p>假设答案为 $k$，则要满足 $n&#x3D;\sum_{i\le k}\sum \frac{10^j-1}{9}$</p>
<p>即要求 $9n+9k&#x3D;\sum 10^j$</p>
<p>考虑枚举 $k$，此时 $\sum 10^j$ 的数字和一定 $\le 9k$，即如果 $9n+9k$ 的数字和 $\le 9k$ 时 $k$ 合法</p>
<p>而每次令 $k+1$ 时都只需要维护一个高精加 $9$，总进位次数是均摊 $\mathcal O(1)$ 的</p>
<p>时间复杂度 $\mathcal O(\lg n)$</p>
<ul>
<li>F</li>
</ul>
<p>神题（</p>
<p>对于双向区间没有要求，考虑对于单向区间的要求</p>
<p>由于车都是以 $k$ 为周期，所以以下所有运算在膜 $k$ 意义下进行（对于区间 $[l,r]$，如果 $l&gt;r$ 则代表区间 $[0,r]\cup[l,k)$）</p>
<p>记 $p_0$ 为上行车的始发时间，$p_i$ 为上行车在第 $i$ 个站点停靠的时间</p>
<p>对于下行车，我们把也它当做从 $0$ 走到 $n$，但需要的时间为负数，记 $-q_0$ 为下行车的始发时间，$q_i$ 为下行车在第 $i$ 个站点停靠的时间</p>
<p>记 $a$ 的前缀和为 $sa$，$p$ 的前缀和为 $sp$，$q$ 的前缀和为 $sq$</p>
<p>则对于第 $i$ 段路（单向），上行车的出发时间为 $sa_{i-1}+sp_{i-1}$，到达时间为 $sa_i+sp_{i-1}$；下行车的出发时间为 $-sa_{i-1}-sq_{i-1}$，到达时间为 $-sa_i-sq_{i-1}$</p>
<p>即要求 $(sa_{i-1}+sp_{i-1},sa_i+sp_{i-1})\cap(-sa_{i-1}-sq_{i-1},-sa_i-sq_{i-1})&#x3D;\emptyset$ </p>
<p>转化一下：</p>
<p>$$<br>\begin{cases}<br>sa_{i-1}+sp_{i-1}+kr\not\in(-sa_{i-1}-sq_{i-1},-sa_i-sq_{i-1})\cr<br>sa_i+sp_{i-1}+kr\not\in(-sa_{i-1}-sq_{i-1},-sa_i-sq_{i-1})\cr<br>-sa_{i-1}-sq_{i-1}+kr\not\in(sa_{i-1}+sp_{i-1},sa_i+sp_{i-1})\cr<br>-sa_i-sq_{i-1}+kr\not\in(sa_{i-1}+sp_{i-1},sa_i+sp_{i-1})<br>\end{cases}<br>$$</p>
<p>化简得 $sp_{i-1}+sq_{i-1}\not\in(-2sa_i,-2sa_{i-1})$，记这个区间的补集为 $[l_i,r_i]$</p>
<p>接下来再进行一步题目转化：有一个变量 $x$，初始值任意，每次操作可以给它加上一个正值，使得在膜 $k$ 意义下在当前要求的区间中，并要求最小化加上的值</p>
<p>不难发现每一次 $x$ 需要加值时加到区间的左端点是最优的</p>
<p>所以记 $f_i$ 为当前 $x$ 在膜 $k$ 意义下为 $l_i$ 时，要满足接下来的所有条件的最小代价</p>
<p>考虑用线段树来维护最近的一个 $[l_j,r_j]$ 使得 $l_i\not \in[l_j,r_j]$，则 $f_i&#x3D;f_j+(l_j-l_i\bmod k)$</p>
<p>不难发现这棵线段树只需要支持区间覆盖和单点查询</p>
<p>最后统计答案只要枚举 $x$ 的初始值然后按照上面的转移方法进行计算即可</p>
<p>时间复杂度 $\mathcal O(n\log n)$</p>
<h3 id="AGC012"><a href="#AGC012" class="headerlink" title="AGC012"></a>AGC012</h3><ul>
<li>A</li>
</ul>
<p>从大到小排序，贪心选第 $2,4,\dots,2n$ 大的值作为中位数</p>
<p>时间复杂度 $\mathcal O(n\log n)$</p>
<ul>
<li>B</li>
</ul>
<p>考虑倒序处理所有操作，每次覆盖没被覆盖到的点</p>
<p>由于 $d$ 很小，所以考虑维护 $vis_{u,d}$ 表示点 $u$ 有没有被还能继续覆盖 $d$ 层的点覆盖</p>
<p>总状态数有 $nd$ 个，所以总复杂度 $\mathcal O(nd)$</p>
<ul>
<li>C</li>
</ul>
<p>同 【[APIO2022] 排列】的 91.36 分做法</p>
<ul>
<li>D</li>
</ul>
<p>如果一种颜色的球中最小的不能和其他球中最小的交换，则这种颜色对答案没有贡献</p>
<p>如果一个球不能和这种颜色的球中最小的或者其他颜色的球中最小的交换，则这个球对答案没有贡献</p>
<p>除去这两种球以外不难发现其他所有的球可以任意排列</p>
<p>有一个性质是对于三个球 $i,j,k$，如果要交换 $i,j$，除了直接交换以外还可以交换 $i,k$，再交换 $j,k$，最后交换 $i,k$</p>
<p>然后上述命题证明就显然了（分三类讨论一下，每类都可以用以上两种方法交换）</p>
<p>最后用组合数随便算一下即可</p>
<p>时间复杂度 $\mathcal O(n)$</p>
<ul>
<li>E</li>
</ul>
<p>不难发现最多跳跃 $\log v$ 次，水壶容量一共 $\log v$ 种，每种水壶容量都会把地图分为若干不连通的线段</p>
<p>所以考虑状压，记 $L_{d,i}$ 为水壶容量为 $d$ 时 $i$ 所在的线段的左端点；同样定义 $R_{d,i}$</p>
<p>这两个都可以在 $\mathcal O(n\log v)$ 的时间内预处理</p>
<p>记 $f_s$ 为使用了 $s$ 状态的水壶容量最多可以覆盖多长的前缀；同样定义 $g_s$</p>
<p>每次枚举下一个用哪个容量，利用 $L$ 和 $R$ 可以 $\mathcal O(1)$ 转移</p>
<p>时间复杂度 $\mathcal O(n\log v)$</p>
<ul>
<li>F</li>
</ul>
<p>把 $a$ 排序后不影响答案，所以先排序</p>
<p>考虑什么样的 ${b}$ 是合法的</p>
<p>对于 $a_i$，如果它能成为前缀 $[1,2j-1]$ 的中位数，则要求 $j-1\le\min{i-1,2n-i-1}$，即 $j\le\min{i,2n-i}$</p>
<p>也就是说对于 $b_i$，取值范围为 ${a_i,\dots,a_{2n-i}}$</p>
<p>除此之外，考虑 $b_i$ 到 $b_{i+1}$ 的变化，记 $b_{i+1}$ 时选出的 $a$ 的集合为 $S$</p>
<p>则 $b_{i+1}$ 一定是 $b_i$ 在 $S$ 中的前驱&#x2F;后继&#x2F;不变</p>
<p>即对于任意 $i&lt;j$，都不存在 $b_j&lt;b_i&lt;b_{j+1}$ 或 $b_j&gt;b_i&gt;b_{j+1}$</p>
<p>则 ${b}$ 合法当且仅当上述两个条件满足</p>
<p>考虑倒过来统计，把问题转化为有一个不可重集 $S&#x3D;{a_n}$，一个变量 $x&#x3D;a_n$，第 $i$ 轮给 $S$ 中加入 $a_{n-i}$ 和 $a_{n+i}$，选择一个变量 $x’\in S$，删去 $S$ 中在开区间 $(x’,x)$ 中的值，并把 $x$ 赋为 $x’$</p>
<p>发现在这个过程中我们只关心 $S$ 中 $&lt;x$ 和 $&gt;x$ 的数的个数，所以可以有一个三维的 dp</p>
<p>记 $f_{i,j,k}$ 为操作进行了 $i$ 轮，$&lt;x$ 和 $&gt;x$ 的数分别有 $j$ 个和 $k$ 个的方案数</p>
<p>转移的时候枚举 $x’$ 的位置，维护 $j$ 和 $k$ 即可</p>
<p>注意 $S$ 是不可重集，所以判断一下加入 $a_{n-i}$ 和 $a_{n+i}$ 是否成功</p>
<p>时间复杂度 $\mathcal O(n^4)$</p>
<h3 id="AGC013"><a href="#AGC013" class="headerlink" title="AGC013"></a>AGC013</h3><ul>
<li>A</li>
</ul>
<p>从左往右扫一遍，能加就加，不能加就新开一个</p>
<p>时间复杂度 $\mathcal O(n)$</p>
<ul>
<li>B</li>
</ul>
<p>任选一个点，选两条以它为端点的路径</p>
<p>每条路径都用 dfs 的方式选直到无法扩展到其他点为止</p>
<p>时间复杂度 $\mathcal O(n)$</p>
<ul>
<li>C</li>
</ul>
<p>首先考虑链上的版本该怎么做</p>
<p>对于两只蚂蚁碰撞，我们可以看做不发生碰撞但是相遇时交换编号</p>
<p>这样可以容易地算出每只蚂蚁最终停在哪里，之后只需要确定它最后的编号</p>
<p>不难发现它们在运动中相对位置不会改变，所以坐标第 $i$ 小的一定是 $i$ 号，只需要排序即可</p>
<p>再来看环上的问题，此时环上的相对位置仍然不变</p>
<p>考虑一个顺时针走的蚂蚁，每碰撞一次它的编号就会 $+1$，编号为 $n$ 时编号变为 $1$</p>
<p>逆时针走的蚂蚁同理没碰撞一次编号 $-1$，编号为 $1$ 时变为 $n$</p>
<p>所以我们只需要求出每个蚂蚁的碰撞次数，可以计算出每个蚂蚁走了几整圈，剩下的可以直接二分求出</p>
<p>时间复杂度 $\mathcal O(n\log n)$</p>
<ul>
<li>D</li>
</ul>
<p>不难发现每次操作后总球数不变，考虑每个操作的条件</p>
<p>若先取黑球，则要求黑球个数 $&gt;0$；否则要求白球个数 $&gt;0$</p>
<p>所以可以设 $f_{i,j}$ 为考虑前 $i$ 次操作，还有 $j$ 个黑球的方案数，转移显然</p>
<p>但是 $\sum f_{m,i}$ 并不是答案，因为同一个序列可能对应多个初始的 $f_{0,i}$</p>
<p>考虑把一个序列和一个初始状态一一对应，容易想到最小化初始的 $i$</p>
<p>再记 $g_{i,j}$ 为考虑前 $i$ 次操作，还有 $j$ 个黑球，且其中有至少一次操作时黑球个数 $&#x3D;1$ 且先取黑球的方案数</p>
<p>然后把 $f_{i,j}$ 修改为还没有一次操作时黑球个数 $&#x3D;1$ 且先取黑球的方案数</p>
<p>最后 $\sum g_{m,i}$ 即为答案</p>
<p>时间复杂度 $\mathcal O(nm)$</p>
<ul>
<li>E</li>
</ul>
<p>有一步巧妙的转化：</p>
<p>把题目看做在格子的间隔上放若干板子，有若干个位置不能放板子，头尾必须放板子；每两个板子之间必须放恰好一个红球和一个蓝球，位置任意，可以放在同一个格子中</p>
<p>这样每种隔板方法的贡献恰为 $\prod {a_i}^2$</p>
<p>记 $f_{i,j}$ 为考虑前 $i$ 个格子，最后一个隔板之后放了 $j$ 个球的方案数，显然 $j$ 只有 $0,1,2$ 三种取值</p>
<p>每次转移系数是固定的，所以考虑矩阵快速幂</p>
<p>对于可以放板子的间隔，转移矩阵为</p>
<p>$$<br>\begin{bmatrix}<br>2&amp;1&amp;1\cr<br>2&amp;1&amp;0\cr<br>1&amp;1&amp;1<br>\end{bmatrix}<br>$$</p>
<p>对于不可以放板子的间隔，转移矩阵为</p>
<p>$$<br>\begin{bmatrix}<br>1&amp;0&amp;0\cr<br>2&amp;1&amp;0\cr<br>1&amp;1&amp;1<br>\end{bmatrix}<br>$$</p>
<p>直接矩阵快速幂转移即可</p>
<p>时间复杂度 $\mathcal O(m\log n)$</p>
<ul>
<li>F</li>
</ul>
<p>根据 Hall 定理，不难推出如果 $X$ 中选出了序列 ${a_i}$，且能和 ${b_i}$ 匹配成功当且仅当对于任意 $i$ 有 $a_i\le b_i$（$a$ 和 $b$ 均单调不降）</p>
<p>考虑如何判断这个条件是否成立，直接排序后判断在本题中显然不行</p>
<p>考虑维护数组 $s$，对于 $a_i$，给 $s$ 从 $a_i$ 开始的后缀加上 $1$；对于 $b_i$，给 $s$ 从 $b_i$ 开始的后缀减去 $1$</p>
<p>这样上述条件成立当且仅当对于所有 $s_i$ 都有 $s_i\ge 0$</p>
<p>回到原题，考虑先把所有 $X$ 中的 $a_i$ 选出来并对 $s$ 执行后缀加；$Y$ 中所有的 $c$ 执行后缀减</p>
<p>此时一定存在 $s_i&lt;0$（数量不同） ，而把一个 $a_i$ 变成 $b_i$ 会付出 $1$ 的代价，并把 $[b_i,a_i)$ 中的 $s$ 加上 $1$</p>
<p>对于一个询问，我们可以对加入 $d$ 和 $e$ 分别查询答案后取 $\max$</p>
<p>假设我们加入的数是 $x$，此时会使从 $x$ 开始的后缀加上 $1$，所以要求加上 $x$ 之前的 $s$ 中 $[1,x)$ 要 $\ge 0$，其他的 $\ge -1$</p>
<p>先从后往前扫一遍 $s$ ，如果碰到一个 $&lt;-1$ 的数，可以贪心地加入一个左端点最小的区间，如果加到最后仍然 $&lt;-1$ 则所有询问都无解</p>
<p>再从前往后扫一遍 $s$，如果碰到一个 $&lt;0$ 的数，可以贪心地加入一个右端点最大的区间，即可预处理出所有加入 $x$ 的答案</p>
<p>最后每个询问查询一下加入 $d$ 和 $e$ 的答案即可</p>
<p>时间复杂度 $\mathcal O(n\log n)$</p>
<h3 id="AGC014"><a href="#AGC014" class="headerlink" title="AGC014"></a>AGC014</h3><ul>
<li>A</li>
</ul>
<p>熟悉的卡A.jpg</p>
<p>结论：如果操作不能无限进行下去那么最多进行 $\mathcal O(\log w)$（$w$ 为值域）次</p>
<p>证明可以证两个数的差 $|A-B|$ 在每次操作后会减半</p>
<ul>
<li>B</li>
</ul>
<p>对于每对点 $(a,b)$，都在连一条 $a\to b$ 的无向边</p>
<p>则存在树上边权都为偶数等价于新图上存在欧拉回路</p>
<p>只要判断是否所有点的度数均为偶数即可</p>
<p>时间复杂度 $\mathcal O(n)$</p>
<p>类似的想法：AGC025E</p>
<ul>
<li>C</li>
</ul>
<p>发现每次解锁的格子一定是下一步要走的格子，所以只需要枚举第一步走到哪里，之后只要求出这个点到边界的最短距离然后除以 $k$ 上取整即可</p>
<p>时间复杂度 $\mathcal O(n^2)$</p>
<ul>
<li>D</li>
</ul>
<p>考虑一个叶子及其父亲</p>
<p>显然删去叶子的父亲对于先手是最优的，因为后手一定要去删这个叶子</p>
<p>不断重复上述过程，最后若剩下若干点则先手必胜，否则后手必胜</p>
<p>时间复杂度 $\mathcal O(n)$</p>
<ul>
<li>E</li>
</ul>
<p><del>考场想到了两种方法，但都不会维护（是我数据结构太菜了</del></p>
<p>第一种方法，考虑倒着加蓝边</p>
<p>每次加入蓝边时显然要加一个在红树上和蓝树上都出现过的边，并把这条边连接的点合并起来</p>
<p>所以可以考虑用启发式合并，每个点用一个 <code>multiset</code> 维护它的出边，如果一条出边出现了两次就说明在红树和蓝树上都有，直接合并即可</p>
<p>时间复杂度 $\mathcal O(n\log^2 n)$</p>
<p>第二种方法，考虑正着删蓝边</p>
<p>每次删的蓝边显然都是只被一条路径经过的</p>
<p>所以我们需要维护的就是哪些边被恰好一条路径经过和这条路径是哪条，要支持删除一条路径</p>
<p>可以用树剖+一棵维护覆盖每条边的路径编号异或和和每条边覆盖次数的最小值的线段树维护</p>
<p>时间复杂度 $\mathcal O(n\log^2 n)$，比上面一种方法稍微难写一点（</p>
<ul>
<li>F</li>
</ul>
<p>不太懂这题为啥有赛时 AC（</p>
<p>若一个数为前缀最大值，则称它为「high 元素」，否则称它为「low 元素」</p>
<p>考虑倒推，每次只考虑值在 $[i,n]$ 里的数排好序的时间 $t_i$</p>
<p>不妨设 $t_{i+1}&gt;0$，若 $t_{i+1}&#x3D;0$ 只需要判断 $i$ 在 $i+1$ 左边还是右边就行了</p>
<p>结论：考虑值在 $[i+1,n]$ 里的数，在 $t_{i+1}-1$ 时刻第一个元素一定不是 $i+1$</p>
<p>证明：考虑反证，假设 $t_{i+1}-1$ 时刻第一个元素是 $i+1$，由于此时还没排好序，则 $i+1$ 为 high 元素，$i+1$ 之后一定存在一个 low 元素，所以 $t_{i+1}$ 时刻的第一个元素一定不是 $i+1$，矛盾</p>
<p>于是可以设 $f_i$ 为考虑值在 $[i,n]$ 中的数，在 $t_{i}-1$ 时刻的第一个元素，由结论可得 $f_i&gt;i$</p>
<p>不难发现若 $t_{i+1}-1$ 时刻 $i$ 在 $f_{i+1}$ 与 $i+1$ 之间，则 $t_i&#x3D;t_{i+1}$，否则 $t_i&#x3D;t_{i+1}+1$</p>
<p>所以只需要考虑 $t_{i+1}-1$ 时 $i$ 在 $f_{i+1}$ 与 $i+1$ 之间需要满足什么条件</p>
<p>结论：无论怎么操作，三元组 $(f_{i+1},i,i+1)$ 在序列中出现的顺序是循环同构的，这里三元组 $(a,b,c)$ 与 $(b,c,a)$ 和 $(c,a,b)$ 循环同构</p>
<p>证明：先证一个引理</p>
<p>引理：考虑值在 $[i+1,n]$ 里的数，$f_{i+1}$ 是 high 元素当且仅当它是第一个元素</p>
<p>引理证明：充分性显然，必要性考虑反证，假设 $f_{i+1}$ 是 high 元素且它不是第一个元素</p>
<p>此时考虑 $f_{i+1}$ 前面的元素 $x$，则若 $x$ 和 $f_{i+1}$ 同为 high 元素或同为 low 元素时 $x$ 总是在 $f_{i+1}$ 前面；若希望将 $x$ 与 $f_{i+1}$ 分开则一定要求 $x$ 为 low 元素且 $f_{i+1}$ 为 high 元素，但此时 $f_{i+1}$ 仍是 high 元素且不是第一个元素，又回到了一开始的情况</p>
<p>不断操作下去，会发现无论怎么操作 $f_{i+1}$ 都无法到达第一个位置，与 $f_{i+1}$ 定义矛盾</p>
<p>回到结论，考虑枚举 $f_{i+1},i,i+1$ 的位置关系，若出现了 $(high,low,high)$ 或 $(low,high,low)$ 的情况才会出现不循环同构的情况</p>
<p>若 $f_{i+1}$ 在最前面，则此时 $i$ 和 $i+1$ 均为 low 元素，操作后显然循环同构</p>
<p>若 $i$ 在最前面，若此时 $i$ 为 high 元素，则由引理可得 $f_{i+1}$ 为 low 元素，此时若 $i+1$ 在 $f_{i+1}$ 前则一定不会出现上述情况，否则由 $f_{i+1}&gt;i+1$ 可得 $i+1$ 为 low 元素，也不会出现上述情况；若此时 $i$ 为 low 元素，则 $i+1$ 一定为 low 元素，由引理可得 $f_{i+1}$ 也为 low 元素，操作后也循环同构</p>
<p>若 $i+1$ 在最前面，则此时 $i$ 和 $f_{i+1}$ 均为 low 元素，没有上述情况，操作后显然循环同构</p>
<p>所以无论如何操作，$(f_{i+1},i,i+1)$ 在序列中的位置都循环同构</p>
<p>由于 $t_{i+1}-1$ 时刻一定有 $f_{i+1}$ 在 $i+1$ 前面，所以若 $(f_{i+1},i,i+1)$ 在序列中出现的顺序与三元组 $(f_{i+1},i,i+1)$ 循环同构，则在 $t_{i+1}-1$ 时 $i$ 一定在 $f_{i+1}$ 和 $i+1$ 之间</p>
<p>所以递推的时候只需要查询 $(f_{i+1},i,i+1)$ 在原序列中的顺序即可</p>
<p>时间复杂度 $\mathcal O(n)$</p>
<h3 id="AGC015"><a href="#AGC015" class="headerlink" title="AGC015"></a>AGC015</h3><ul>
<li>A</li>
</ul>
<p>特判 $n&#x3D;1$，$a&gt;b$ 的情况，其他只要在 $[(n-1)a+b,a+(n-1)b]$ 之间的数都合法</p>
<p>时间复杂度 $\mathcal O(1)$</p>
<ul>
<li>B</li>
</ul>
<p>对于 $i$，若其为 <code>U</code>，则在 $i$ 之上的 $n-i$ 层的贡献为 $1$，其余贡献为 $2$；否则在 $i$ 之下的 $i-1$ 层贡献为 $1$，其余贡献为 $2$</p>
<p>时间复杂度 $\mathcal O(n)$</p>
<ul>
<li>C</li>
</ul>
<p>感觉难度虚高了，应该没有 *2200（</p>
<p>由于整个图是一个森林，所以每条存在边都会减少一个连通块，即连通块个数&#x3D;点数-边数</p>
<p>所以只需要维护点数的二维前缀和，横向边的二维前缀和，纵向边的二维前缀和即可做到 $\mathcal O(1)$ 查询</p>
<p>总复杂度 $\mathcal O(nm+Q)$</p>
<ul>
<li>D</li>
</ul>
<p>不妨设 $B$ 的位数比 $A$ 的位数多（否则可以一直删同时有的 $1$）</p>
<p>设 $B$ 最高位为 $2^t$，则 $[A,2^t)$ 中的数一定合法，接下来只需要考虑 $\ge 2^t$ 的数</p>
<p>这时不妨假设 $2^t$ 一定在选出来的集合中，那么 $2^t$ 位就不需要考虑了，所以把 $[2^t,B]$ 中的数全部减去 $2^t$，变成 $[0,B-2^t]$</p>
<p>设 $B-2^t$ 的最高位为 $2^h$，则显然 $[0,2^{h+1})$ 中的数都能被 $[0,B-2^t]$ 中的数表示出来，另外 $[A,2^t)$ 中的数也合法</p>
<p>所以最终合法的数集为 $[A,2^{h+1}+2^t)\cup[A+2^t,2^{t+1})$</p>
<p>时间复杂度 $\mathcal O(\log w)$，$w$ 为值域</p>
<ul>
<li>E</li>
</ul>
<p>考虑经过足够长的时间之后所有点的位置，显然速度大的在前面，所以不妨先按 $v_i$ 从小到大排序</p>
<p>记 $l_i$ 为最小的满足 $x_p\ge x_i$ 的 $p$，$r_i$ 为最大的满足 $x_p\le x_i$ 的 $p$</p>
<p>结论：将 $i$ 染色后能覆盖到 $[l_i,r_i]$ 中所有点</p>
<p>证明：先证 $[l_i,i]$ 中所有点都能被覆盖掉，$[i,r_i]$ 同理</p>
<p>考虑 $j\in[l_i,i]$，若 $x_j&gt;x_i$，则 $j$ 一定会被 $i$ 追上；否则由于 $v_i\ge v_j$ 可得 $i$ 一定能在 $j$ 追上 $l_i$ 之前追上 $l_i$，此时 $j$ 也会被覆盖</p>
<p>于是就变成了给定 $n$ 个区间 $[l_i,r_i]$，要求选若干个区间使得 $[1,n]$ 都被覆盖，求方案数</p>
<p>对这些区间根据 $x_i$ 排序，由 $l_i$ 和 $r_i$ 定义不难看出它们都随 $x_i$ 增大而增大</p>
<p>设 $f_i$ 为选 $[l_i,r_i]$，且覆盖了 $[1,r_i]$ 的方案数</p>
<p>显然合法决策是一个区间，维护这个区间即可做到均摊 $\mathcal O(1)$ 的转移</p>
<p>时间复杂度 $\mathcal O(n\log n)$</p>
<ul>
<li>F</li>
</ul>
<p>不妨设 $x&lt;y$（若 $x&#x3D;y$ 则答案为 $1$，可以特判；若 $x&gt;y$ 可以一样求）</p>
<p>第一问比较简单，直接用斐波那契数列就行了</p>
<p>对于答案为 $k$ 的数对，其中最小的一定是 $(f_k,f_{k+1})$</p>
<p>考虑缩一缩状态，不难发现 $(i,j),(i,j+i),(i,j+2i),\dots$ 答案一样，所以我们把它们缩成 $(i,j)$ 一个状态，其中 $i&lt;j\le2i$</p>
<p>对于答案为 $k$ 的数对 $(i,j)$ 还有 $i&lt; f_{k+1}\lor j&lt; f_{k+2}$ 的要求</p>
<p>假设我们推出了答案为 $k$ 的合法数对 $(i_1,j_1),(i_2,j_2),\dots$</p>
<p>则显然 $(j_1,i_1+j_1),(j_2,i_2+j_2),\dots$ 都是答案为 $k+1$ 的合法数对</p>
<p>除此之外还有 $(f_{k+2},f_{k+2}+f_k)$ 也是答案为 $k+1$ 的合法数对</p>
<p>所以每次从 $k$ 变为 $k+1$ 都新增一个合法数对</p>
<p>于是我们可以做到 $\mathcal O({\log _{1.618}}^2 w)$ 预处理，$\mathcal O(\log_{1.618}w)$ 查询</p>
<p>总复杂度 $\mathcal O(Q\log_{1.618}w)$，其中 $w$ 为值域 </p>
<h3 id="AGC016"><a href="#AGC016" class="headerlink" title="AGC016"></a>AGC016</h3><ul>
<li>A</li>
</ul>
<p>枚举字符，贪心选字符</p>
<p>时间复杂度 $\mathcal O(n^2)$</p>
<ul>
<li>B</li>
</ul>
<p>显然 $a_i$ 要么是总颜色数，要么是总颜色数 $-1$，可以先判一下最大值和最小值是否差一</p>
<p>记最大值有 $c_0$ 个，最小值有 $c_1$ 个，则最少有 $c_1+1$ 种颜色，最多有 $c_1+\lfloor\frac {c_0}2\rfloor$ 种颜色</p>
<p>时间复杂度 $\mathcal O(n)$</p>
<ul>
<li>C</li>
</ul>
<p>若 $H$ 是 $h$ 的倍数且 $W$ 是 $w$ 的倍数则无解</p>
<p>否则可以令 $(k_1h,k_2w)$ 位置的点值为 $-hw$，其他位置点值为 $1$</p>
<p>这样还是可能总和 $\le 0$，由于 $h$ 和 $w$ 中至少有一个不是 $H$ 和 $W$ 的约数，不妨设 $h$ 不是 $H$ 的约数</p>
<p>这是把最后一列中 $\bmod h &#x3D;1$ 的点赋为 $10^9-hw+1$，最右边值为 $-hw$ 的点赋为 $-10^9$</p>
<p>这样总和一定可以 $&gt;0$</p>
<p>时间复杂度 $\mathcal O(HW)$</p>
<ul>
<li>D</li>
</ul>
<p>记序列的异或和为 $s$，不难发现若第一次将 $s$ 放到 $i$ 位置，第二次操作时序列异或和即为 $a_i$</p>
<p>也就是说可以利用这个操作在 $l+1$ 步完成一个长度为 $l$ 的轮换</p>
<p>不妨把 $a_i&#x3D;b_i$ 的数去掉，剩下的数先任意安排轮换使得轮换过后 $a$ 和 $b$ 相等</p>
<p>显然这个轮换由若干环和至多一个链组成，而一个长度为 $l$ 的链需要 $l$ 步操作</p>
<p>那么接下来就要最小化环的个数</p>
<p>显然如果两个环中有相等的数，则这两个环可以合并成一个环，直接用并查集来维护即可</p>
<p>当然若一个环中存在一个数等于 $s$ 那这个环只需要 $l$ 步操作</p>
<p>时间复杂度 $\mathcal O(n\alpha (n))$</p>
<ul>
<li>E</li>
</ul>
<p>考虑如何保证第 $i$ 只鸡存活</p>
<p>对于操作 $(i,x)$，显然要求 $x$ 在执行这次操作前不死，也就是要保护第 $x$ 只鸡</p>
<p>倒序考虑每一个操作，维护一个集合 $S_i$ 表示若最后要保证第 $i$ 只鸡存活现在需要保护哪些鸡</p>
<p>若出现了形如 $(i,x)$ 的操作，若 $x\in S_i$ 则第 $i$ 只鸡一定不能存活，否则将 $x$ 加入 $S_i$</p>
<p>若出现了形如 $(x,y)$ 的操作，若 $x\in S_i\land y\in S_i$ 则第 $i$ 只鸡一定不能存活，若 $x\in S_i$ 则把 $y$ 加入 $S_i$，若 $y\in S_i$ 则把 $x$ 加入 $S_i$</p>
<p>最后考虑每一对鸡 $(i,j)$，若 $S_i\cap S_j\not&#x3D;\emptyset$ 则它们一定不能同时存活</p>
<p>时间复杂度 $\mathcal O(nm+\frac{n^3}w)$</p>
<ul>
<li>F</li>
</ul>
<p>要求先手必胜的方案数，可以先求先手必败的方案数再用总方案数去减</p>
<p>先手必败即要求 $sg(1)&#x3D;sg(2)$</p>
<p>考虑 $sg(u)&#x3D;k$ 的要求：</p>
<ol>
<li>对于任意 $i&lt;k$，$u$ 必须要和至少一个 $sg(v)&#x3D;i$ 的 $v$ 相连</li>
<li>$u$ 和任意 $sg(v)&#x3D;k$ 之间没有边</li>
</ol>
<p>考虑一个集合 $S$，使得 $S$ 中的点的 $sg$ 值均为 $0$</p>
<p>这些点可以任意连向其他点，而其他点至少要向 $S$ 连一条边</p>
<p>去掉 $S$ 中的点后，剩下的点的 $sg$ 值都减去了 $1$（原先 $sg$ 值为 $1$ 的由于后继中没有 $0$ 了所以 $sg$ 值会变成 $0$，其余同理）</p>
<p>所以考虑设 $f_s$ 为考虑集合 $s$ 中的点使得 $sg(1)&#x3D;sg(2)$ 的方案数</p>
<p>每次枚举集合 $t\subseteq s$ 表示此时 $sg$ 值为 $0 $ 的集合，按照上面转移即可</p>
<p>时间复杂度 $\mathcal O(3^nn)$</p>
<h3 id="AGC017"><a href="#AGC017" class="headerlink" title="AGC017"></a>AGC017</h3><ul>
<li>A</li>
</ul>
<p>若存在一包有奇数个饼干则答案为 $2^{n-1}$，否则若 $p&#x3D;0$ 则答案为 $2^n$，否则答案为 $0$</p>
<p>时间复杂度 $\mathcal O(n)$</p>
<ul>
<li>B</li>
</ul>
<p>考虑枚举 $i$ 表示有多少个格子比前面的格子大，可以算出最后一个格子可以取到的最大值和最小值，判断 $B$ 在不在这个区间内即可</p>
<p>时间复杂度 $\mathcal O(n)$</p>
<ul>
<li>C</li>
</ul>
<p>转化一下题意：出现一次 $a_i$ 就在数轴上 $a_i$ 的点上挂 $1$ 单位的绳子，然后把所有绳子向左拉直，如果能恰好覆盖 $[0,n]$ 则合法，否则需要修改的次数即为没被覆盖的线段个数</p>
<p>直接用桶维护一下即可，时间复杂度 $\mathcal O(n+m)$</p>
<ul>
<li>D</li>
</ul>
<p>据说是经典结论？</p>
<p>考虑每个子树 $u$ 计算它的 $sg$ 函数</p>
<p>对于以 $u$ 为根的子树，考虑把它拆开，每个儿子 $v$ 的子树和 $u$ 组成若干新的树，不难发现新树是互相独立的</p>
<p>所以 $sg_u$ 就等于每个新树的 $sg$ 值的异或和</p>
<p>然后不难猜到新树的 $sg$ 值为 $sg_v+1$（可以对树的点数归纳证明），可得 $sg_u&#x3D;\oplus (sg_v+1)$</p>
<p>时间复杂度 $\mathcal O(n)$</p>
<ul>
<li>E</li>
</ul>
<p>对于一个拼图，若 $d_i&#x3D;0$，则令它的右侧权值为 $b_i$，否则为 $d_i+H$；若 $c_i&#x3D;0$，则令它的左侧权值为 $a_i+H$，否则为 $b_i$</p>
<p>不难发现只有当一个拼图的右侧权值和另一个拼图的左侧权值相等的时候才可能拼在一起；一个拼图的左侧权值 $&gt;H$ 时才有可能在最左边；一个拼图的右侧权值 $\le H$ 时才有可能在最右边</p>
<p>考虑建立一个 $2H$ 个点的图，对于每个左右权值分别为 $(a,b)$ 的拼图连一条 $a\to b$ 的有向边</p>
<p>那么原问题就被转化为了在图里选若干个路径使得所有边都在这些路径中，并且起点 $&gt;H$，终点 $\le H$</p>
<p>不难想到欧拉回路，考虑建立一个超级源点 $s$ ，对于每个 $&gt;H$ 的点 $u$ 可以连若干条 $s\to u$ 的边，对于每个 $\le H$ 可以连若干条 $u\to s$ 的边</p>
<p>那么有解等价于存在一种超级源点的连边方式使得图连通且图上存在欧拉回路</p>
<p>可以根据度数判断，并注意一个弱连通块如果不是单点一定要和 $s$ 有连边</p>
<p>时间复杂度 $\mathcal O(n\alpha(n))$</p>
<ul>
<li>F</li>
</ul>
<p>考虑状压，设 $f_{i,s}$ 为考虑了前 $i$ 条路径，第 $i$ 条路径的状态为 $s$（每一步只有两种选择）的方案数</p>
<p>但直接转移复杂度是 $\mathcal O(m4^n)$ 的，显然不可以接受</p>
<p>类比棋盘上的状压问题，逐行转移的 $\mathcal O(m4^n)$ 可以通过逐格转移优化到 $\mathcal O(nm2^n)$</p>
<p>考虑逐层来 dp，记 $f_{i,j,s}$ 为考虑了前 $i-1$ 条路径和第 $i$ 条路径的前 $j$ 层，当前最右链状态为 $s$ 的方案数</p>
<p>记 $s$ 的当前位为 $x$，若 $x&#x3D;1$ 则这条路径只能向右走，$s$ 不变；若 $x&#x3D;0$，这条路径向左走则 $s$ 不变，若向右走则 $s$ 的当前位要改成 $1$，且 $s$ 下一个 $1$ 要改成 $0$，这些操作都可以通过位运算 $\mathcal O(1)$ 解决</p>
<p>时间复杂度 $\mathcal O(nm2^n)$</p>
<h3 id="AGC018"><a href="#AGC018" class="headerlink" title="AGC018"></a>AGC018</h3><ul>
<li>A</li>
</ul>
<p>记 $A$ 中数的 $\gcd $ 为 $g$，显然 $\le \max{A}$ 且是 $g$ 的倍数的数都能出现</p>
<p>时间复杂度 $\mathcal O(n\log w)$，$w$ 为值域</p>
<ul>
<li>B</li>
</ul>
<p>直接贪心，先假设所有活动全选，每次删掉其中参与人数最多的那个即可</p>
<p>时间复杂度 $\mathcal O(nm)$</p>
<ul>
<li>C</li>
</ul>
<p>不妨先把每个人的铜币拿过来，那么对于第 $i$ 个人如果要拿金币则贡献为 $A_i-C_i$，要拿银币则贡献为 $B_i-C_i$，把这两个数记为新的 $A_i$ 和 $B_i$</p>
<p>考虑带反悔的贪心，维护两个大根堆 $qa$，$qb$，分别存储拿金币的贡献和拿银币的贡献</p>
<p>根据贪心策略，第一次显然拿两个大根堆堆顶中最大的最优</p>
<p>考虑到之后可能会反悔掉这次操作，所以再维护两个大根堆 $ra$ 和 $rb$，分别维护反悔选择 $qa$ 中的数的权值和反悔选择 $qb$ 中数的权值</p>
<p>如果选了 $qa$ 中的数，显然要在 $ra$ 中加入 $B_i-A_i$ 的权值表示反悔这一次操作的权值；选 $qb$ 同理</p>
<p>反悔一次之前选的 $qa$，即把这个数变成选了 $qb$ 中的数，同样需要在 $rb$ 中加入 $A_i-B_i$ 表示继续反悔这一次操作，而少了一个 $qa$ 中的数显然还要再选一个 $qa$ 中的数，就和上面一样了</p>
<p>时间复杂度 $\mathcal O(n\log n)$</p>
<ul>
<li>D</li>
</ul>
<p>如果是求最长哈密尔顿回路，那么每条边 $u\to v$ 都可以被经过 $2\min{sz_v,n-sz_v}$ 次</p>
<p>对于哈密尔顿路径，需要在这之中去掉一条路径</p>
<p>性质：在最长哈密尔顿回路中的路径，必然经过树的重心</p>
<p>以树的重心为根，记为 $rt$，则 $rt$ 的所有子树大小必然 $\le \frac{n}2$，则对于一个子树中的点 $u$，必然要连到这个子树外的一个点，即经过树的重心</p>
<p>所以只要删去和 $rt$ 相邻的最短的边即可</p>
<p>注意到一棵树可能有两个重心，显然这时需要去掉连接这两个重心的边</p>
<ul>
<li>E</li>
</ul>
<p>记从一个点 $(x_1,y_1)$ 走到 $(x_2,y_2)$ 的方案数为 $f(x_1,y_1,x_2,y_2)&#x3D;\dbinom{x_2-x_1+y_2-y_1}{x_2-x_1}$</p>
<p>考虑从点 $(0,0)$ 走到以 $(0,0)$ 为左上角，$(x,y)$ 为右下角的矩形的方案数</p>
<p>考虑到 $f(0,0,x+1,y)&#x3D;\sum\limits_{i\le y}f(0,0,x,i)$，可得方案数为 $f(0,0,x+1,y+1)-1$</p>
<p>那么从 $(0,0)$ 走到以 $(x_1,y_1)$ 为左上角，$(x_2,y_2)$ 为右下角的矩形的方案数可以通过容斥得到：$f(0,0,x_2+1,y_2+1)-f(0,0,x_1,y_2+1)-f(0,0,x_2+1,y_1)+f(0,0,x_1,y_1)$</p>
<p>同样地，从一个矩形走到另一个矩形的方案数可以通过容斥转化为求 $16$ 对点之间的方案数</p>
<p>这道题要求经过中间矩形的一个点，那么每条路径的权值即为在中间矩形中经过的点数</p>
<p>考虑枚举进入中间矩形的点和离开中间矩形的点，那么可以通过曼哈顿距离算出在中间矩形中经过的点数</p>
<p>而曼哈顿距离是可以拆开让起点和终点独立的，所以可以在 $\mathcal O(n)$ 的时间内算出一对点之间所有路径的权值和</p>
<p>一共有 $16$ 对点，算 $16$ 次即可</p>
<p>时间复杂度 $\mathcal O(n)$</p>
<ul>
<li>F</li>
</ul>
<p>显然如果有解则填 ${-1,0,1}$ 就足够了</p>
<p>考虑先计算出每棵树中每个点填的数的奇偶性，如果同一个点在两棵树中奇偶性不同则无解</p>
<p>否则建一个超级根，连接两棵树的树根，此时所有位置填的数与它的度数奇偶性相同</p>
<p>对于第一棵树中所有的点 $u$，如果度数为奇数则向第二棵树中的点 $u$ 连一条双向边，称其为「横插边」 </p>
<p>显然此时树中所有点度数均为偶数，存在欧拉回路，跑一遍欧拉回路给每条横插边定向</p>
<p>如果是从第一棵树指向第二棵树则权值设为 $1$，否则设为 $-1$，那么一定满足条件</p>
<p>证明：考虑一个任意的点 $u$，和它相关的环有两种</p>
<p>若和父亲节点有关，则对 $u$ 的贡献为 $\pm 1$，否则对 $u$ 的贡献为 $0$</p>
<p>而和父亲节点有关的环有且仅有一个，所以 $u$ 子树内的权值和一定为 $\pm 1$，满足条件</p>
<p>时间复杂度 $\mathcal O(n)$</p>
<h3 id="AGC019"><a href="#AGC019" class="headerlink" title="AGC019"></a>AGC019</h3><ul>
<li>A</li>
</ul>
<p>首先令 $S&#x3D;\min{S,2H,4Q}$，再令 $D&#x3D;\min{D,2S}$</p>
<p>则答案为 $\lfloor\frac n2\rfloor D+(n-2\lfloor\frac n2\rfloor)S$</p>
<p>时间复杂度 $\mathcal O(1)$</p>
<ul>
<li>B</li>
</ul>
<p>显然对于一个字符 $s_i$，只统计翻转和它不同的字符的贡献可以不重不漏统计所有情况</p>
<p>时间复杂度 $\mathcal O(n)$</p>
<ul>
<li>C</li>
</ul>
<p>首先可以通过镜像翻转让起点在左下角</p>
<p>每通过一个喷泉拐弯可以让答案减少 $20-5\pi$，所以我们需要尽可能多的经过喷泉拐弯</p>
<p>同时走回头路是一定不优的，所以对于每个喷泉，经过之后还能到达哪些喷泉是一个二维偏序问题，可以用线段树+扫描线维护</p>
<p>这样就可以得到从起点到终点最多经过多少个喷泉了</p>
<p>同时注意到每行&#x2F;每列都经过一个喷泉的话必然有一个喷泉要直走，所以此时答案要加上 $5\pi$</p>
<p>时间复杂度 $\mathcal O(n\log n)$</p>
<ul>
<li>D</li>
</ul>
<p>以下下标均在 $\bmod n$ 意义下运算</p>
<p>考虑枚举最后字符串的总位移为向左&#x2F;向右 $k$ 格，不妨设为向右 $k$ 格</p>
<p>预处理出 $ql_i$ 表示最少向左移动 $ql_i$ 可以碰到一个 $1$；同理预处理 $qr_i$</p>
<p>那么对于任意一个需要修改的位置，若 $qr_i\le k$ 则已经可以满足，否则需要至少向左移 $ql_i$ 格或至少向右移 $qr_i$ 格</p>
<p>对于所有的二元组 $(ql_i,qr_i)$，考虑按 $ql$ 从小到大排序，处理出 $qr$ 的后缀最大值</p>
<p>枚举 $L$ 表示至少向左移 $L$ 格可以得到至少向右移 $R$ 格，结合最后总位移为向右 $k$ 格可以算出总移动距离，最后求个最小值即可</p>
<p>时间复杂度 $\mathcal O(n^2)$</p>
<ul>
<li>E</li>
</ul>
<p>首先转化一下题意：先让 $A$ 中的 $1$ 和 $B$ 中的 $1$ 两两匹配，共 $k!$ 种匹配方法；再按任意顺序对这些匹配进行操作，共 $k!$ 种顺序</p>
<p>考虑建一个图论模型，如果位置 $A_i&#x3D;1$ 与位置 $B_j&#x3D;1$ 匹配则连一条 $i\to j$ 的有向边</p>
<p>对于位置 $i$，若 $A_i&#x3D;B_i&#x3D;1$ 则称它为 C 类点；否则若 $A_i&#x3D;1$ 则称它为 A 类点，若 $B_i&#x3D;1$ 则称它为 B 类点</p>
<p>显然 A 类点和 B 类点数量相同，设有 $m$ 个 A 类点，$r$ 个 C 类点，有 $r+m&#x3D;k$</p>
<p>在图上，任意 A 类点的出度为 $1$，B 类点入度为 $1$，C 类点的入度出度都为 $1$</p>
<p>那么一个合法的图显然由若干条由 A 类点出发经过若干 C 类点到达 B 类点的链和若干个由 C 类点组成的环构成</p>
<p>对于一条有 $i$ 个 C 类点的链，一共有 $(i+1)!$ 种可能的边的执行顺序，其中只有一种是合法的（即从 B 类点出发向 A 类点走的顺序）；对于一个环任意一种边的执行顺序都是合法的</p>
<p>所以考虑先把答案乘上 $k!$，每遇到一条链就产生 $\frac{1}{(i+1)!}$ 的系数；同理每个环产生 $1$ 的系数</p>
<p>而每条链的头尾都有标号，不好统计，考虑先给每个 A 类点钦定它链尾的 B 类点，最后再乘上 $m!$ 即可，此时每条链只需要考虑链首的 A 类点的标号</p>
<p>记 $g_i$ 为由 $i$ 个 C 类点构成的链给答案的贡献，显然 $i$ 个 C 类点可以任意排列，有 $i!$ 的贡献，同时 $(i+1)!$ 种可能的边的执行顺序中只有一种合法，还有 $\frac{1}{(i+1)!}$ 的贡献，所以 $g_i&#x3D;\frac{i!}{(i+1)!}$</p>
<p>考虑到我们是把若干个 C 类点分进 $m$ 条链中，还要乘上一个多重组合数的系数，所以考虑每条链的 EGF</p>
<p>设 $g$ 的 EGF 为 $G(x)$，则 $G(x)&#x3D;\sum\limits_{i&#x3D;0}^r\dfrac{g_ix^i}{i!}&#x3D;\sum\limits_{i&#x3D;0}^r\frac{1}{(i+1)!}x^i$</p>
<p>则 $i$ 个 C 类点分进 $m$ 条链产生的贡献即为 $[\dfrac{x^i}{i!}]G^m(x)$</p>
<p>而选出 $i$ 个 C 类点还会产生 $\binom{r}{i}$ 的系数，剩下 $r-i$ 个 C 类点要构成环可以任意连边，产生 $(r-i)!$ 的系数，每个环产生 $1$ 的系数可以不用考虑</p>
<p>综上，可得到答案为 $k!m!\sum\limits_{i&#x3D;0}^r\binom ri(r-i)![\dfrac{x^i}{i!}]G^m(x)$</p>
<p>组合数拆开化简可得 $k!m!r!\sum\limits_{i&#x3D;0}^r[x^i]G^m(x)$</p>
<p>直接多项式快速幂即可在 $\mathcal O(n\log n)$（多项式 $\ln$+$\exp$）&#x2F; $\mathcal O(n\log^2n)$（直接倍增+多项式乘法）时间内完成</p>
<ul>
<li>F</li>
</ul>
<p>显然如果剩下 $a$ 个问题的答案为 <code>YES</code>，$b$ 个问题的答案为 <code>NO</code>，则一定会猜剩下个数多的那个答案，若 $a&#x3D;b$ 则可以随便猜一个，不妨设此时我们一直猜 <code>YES</code></p>
<p>画一张 $n\times m$ 的表格图，不妨设 $n\ge m$，如果当前在 $(x,y)$ 则表示还剩下 $x$ 个问题的答案为 <code>YES</code>，$y$ 个问题的答案为 <code>NO</code></p>
<p>那么如果这个题的答案为 <code>YES</code> 则会向左走一步，否则会向下走一步，形成一条从 $(n,m)$ 到 $(0,0)$ 的折线</p>
<p>显然如果这条折线在直线 $x&#x3D;y$ 下方且向左时猜的答案是正确的；在 $x&#x3D;y$ 上方且向下时猜的答案是正确的，那么就可以保证猜对 $n$ 道题</p>
<p>还漏掉的猜对的题目即为折线在 $x&#x3D;y$ 上且向左的情况</p>
<p>可以枚举一个点 $(i,i)$，计算 $(n,m)$ 到 $(0,0)$ 的折线中有多少经过 $(i,i)$，在这些折线中有一半在经过 $(i,i)$ 时向左走</p>
<p>这一部分的贡献即为 $\dfrac{1}{2\binom{n+m}n}\sum\limits_{1\le i\le m}\binom {2i}i\binom{n+m-2i}{n-i}$</p>
<p>时间复杂度 $\mathcal O(n)$</p>
<h3 id="AGC020"><a href="#AGC020" class="headerlink" title="AGC020"></a>AGC020</h3><ul>
<li>A</li>
</ul>
<p>显然 $b-a$ 为偶数时 <code>Alice</code> 赢，否则 <code>Borys</code> 赢</p>
<ul>
<li>B</li>
</ul>
<p>考虑倒推</p>
<p>记 $[l,r]$ 为考虑 $[i+1,n]$ 内的操作的人数区间</p>
<p>则显然新的 $l$ 应为 $a_i\max{1,\lceil\frac l{a_i}\rceil}$，新的 $r$ 应为 $a_i(\lfloor\frac r{a_i}\rfloor+1)-1$</p>
<p>若出现 $l&gt;r$ 则无解</p>
<p>时间复杂度 $\mathcal O(n)$</p>
<ul>
<li>C</li>
</ul>
<p>记 $s&#x3D;\sum a_i$，显然如果出现 $x$ 一定会出现 $s-x$</p>
<p>所以可以从 $\lceil\frac s2\rceil$ 开始扫，遇到第一个出现的数即为中位数</p>
<p>出现的数可以用 01 背包预处理</p>
<p>时间复杂度 $\mathcal O(\frac{n^3}{w})$</p>
<ul>
<li>D</li>
</ul>
<p>连续相同的字符个数最多为 $q&#x3D;\max{\lceil\frac{a}{b+1}\rceil,\lceil\frac b{a+1}\rceil}$</p>
<p>显然字典序最小的合法序列一定形如 <code>A..ABA..ABA..|B..AB..BAB..B</code></p>
<p>考虑二分 $x$ 表示分界点前面有 $x$ 个 <code>A</code>，则分界点前面有 $\max{0,\lfloor \frac{x-1}q\rfloor}$ 个 <code>B</code></p>
<p>可以算出分界点之后的 <code>AB</code> 数量 $ra$ 和 $rb$，若 $rb\le q(ra+1)$ 则合法</p>
<p>时间复杂度 $\mathcal O(Q(\log w+C-D))$，$w$ 为值域</p>
<ul>
<li>E</li>
</ul>
<p>设 $f_{i,s}$ 表示长度为 $i$，字符串为 $s$ 有几种压缩方法</p>
<p>若 $i&#x3D;1$ 则 $s$ 为 $0$ 时 $f_{i,s}&#x3D;1$，否则 $f_{i,s}&#x3D;2$</p>
<p>否则可以分两类：</p>
<ol>
<li>$s_1$ 不参与循环，则 $f_{i,s}\leftarrow 1+[s_1&#x3D;1]+f_{i-1,s_{2\dots i}}$</li>
<li>$s_1$ 参与循环，则枚举循环次数 $k$ 和循环节长度 $j$，设这 $k$ 个循环节中的字符串取 $\operatorname{and}$ 之后为 $t$，则 $f_{i,s}\leftarrow f_{j,t}f_{i-jk,s_{jk+1\dots i}}$</li>
</ol>
<p>状态数不多，直接记搜即可</p>
<ul>
<li>F</li>
</ul>
<p>先断环成链，钦定最长弧的起点为链的起点</p>
<p>这题因为坐标是实数，所以不能放入 dp 的状态中</p>
<p>由于 $n$ 很小，所以考虑枚举它们小数部分的相对大小，然后就可以离散化了</p>
<p>这样坐标就变成了 $[0,nC]$，并且离散，就可以放入 dp 的状态了</p>
<p>记 $f_{i,j,s}$ 为考虑起点在 $i$ 位置以前的所有线段，最右覆盖到 $j$，线段使用情况为 $s$ 的方案数</p>
<p>根据枚举的小数部分的相对大小，$i$ 位置可以填的线段被 $i\bmod n$ 唯一确定，所以转移是 $\mathcal O(1)$ 的</p>
<p>加上枚举相对大小的复杂度，总复杂度为 $\mathcal O(n^2C^22^nn!)$</p>
<p>最后求出合法方案数了以后要除以总方案数，而总方案数为 $(n-1)!C^{n-1}$</p>
<h3 id="AGC021"><a href="#AGC021" class="headerlink" title="AGC021"></a>AGC021</h3><ul>
<li>A</li>
</ul>
<p>从前往后枚举哪一位开始不压上界即可</p>
<p>时间复杂度 $\mathcal O(\lg n)$ </p>
<ul>
<li>B</li>
</ul>
<p>考虑对每一个点 $P$ 计算概率</p>
<p>如果不存在一条过 $P$ 的直线使得所有点都在这条直线的一侧则显然概率为 $0$ </p>
<p>否则记 $A,B$ 为 $\left\langle \overset{\to}{PA},\overset{\to}{PB} \right\rangle$ 最大的一对点，则 $P$ 点概率为 $\frac{\pi-\left\langle \overset{\to}{PA},\overset{\to}{PB} \right\rangle}{2\pi}$ </p>
<p>时间复杂度 $\mathcal O(n^3)$ </p>
<ul>
<li>C</li>
</ul>
<p>如果一行有奇数个格子，那么放 $1\times 2$ 的骨牌一定会空出一个格子，列同理</p>
<p>所以考虑如果 $n$ 或 $m$ 为奇数，则直接把最后一行&#x2F;最后一列放满 $1\times 2$ 或 $2\times 1$ 的骨牌</p>
<p>现在把 $n$ 和 $m$ 都变成了偶数，考虑把棋盘划分为若干 $2\times 2$ 的块，每一块放两个 $1\times2$ 或 $2\times 1$ 的骨牌，这样一定是最优的</p>
<p>但还有一种情况，$n$ 和 $m$ 均为奇数时，最后还剩一个 $2\times 2$ 的块，还需要放 $1$ 个 $1\times2$ 的骨牌和 $1$ 个 $2\times 1$ 的骨牌，此时可以这样放：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;&gt;^</span><br><span class="line">^.v</span><br><span class="line">v&lt;&gt;</span><br></pre></td></tr></table></figure>

<p>时间复杂度 $\mathcal O(nm)$</p>
<ul>
<li>D</li>
</ul>
<p>不难发现最优情况一定是选一个回文的子序列</p>
<p>设 $f_{l,r,k}$ 为 $[l,r]$ 中用了 $k$ 次修改选出的回文子序列最长长度</p>
<p>枚举 $l,r$ 匹不匹配转移即可</p>
<p>时间复杂度 $\mathcal O(n^3)$</p>
<ul>
<li>E</li>
</ul>
<p>考虑枚举红球个数 $r$，蓝球个数 $b&#x3D;k-r$</p>
<p>如果 $r&lt;n$ 或 $r&lt;b$ 则一定不合法</p>
<p>如果 $r\ge b+n$ 则任意操作序列都合法</p>
<p>如果 $r&#x3D;b$，则最后一次操作一定是喂蓝球，那么合法的操作序列个数和 $(r,b-1)$ 相等</p>
<p>接下来考虑 $b&lt;r&lt;b+n$ 的情况</p>
<p>一共有 $r-b$ 只变色龙是一定合法的（吃的红球数量大于蓝球数量），我们需要满足的就是让吃的两种颜色的球相等的变色龙合法</p>
<p>如果这样的变色龙吃了多于 $2$ 个球，则直接把多的那一部分给一定合法的变色龙，也就是保证吃球相等的变色龙的吃球序列一定是 <code>RB</code></p>
<p>即要求操作序列的前缀中 <code>B</code> 的数量比 <code>R</code> 的数量最多多 $b-(n-(r-b))&#x3D;r-n$ 个</p>
<p>用类似卡特兰数的计算方法即可得到方案数为 $\binom{k}{r}-\binom{k}{2r-n+1}$</p>
<p>时间复杂度 $\mathcal O(n)$</p>
<ul>
<li>F</li>
</ul>
<p>对于列的限制比对于行的限制多，所以考虑一列一列 dp</p>
<p>设 $f_{i,j}$ 为前 $i$ 列，$j$ 行已经有黑格的方案数</p>
<p>考虑枚举这一列新增 $k$ 行有黑格</p>
<p>若 $k&#x3D;0$，则分没有黑格&#x2F;一个黑格&#x2F;多于两个黑格三种情况，多于两个黑格时只需要枚举最值在哪，方案数为 $1+\binom j1+\binom j2$</p>
<p>若 $k&gt;0$，则分新增的黑格是两个最值&#x2F;其中一个最值&#x2F;不是最值三种情况，方案数为 $\binom{j+k}k+2\binom{j+k}{k+1}+\binom{j+k}{k+2}&#x3D;\binom{j+k+2}{k+2}$</p>
<p>那么总转移为 $f_{i,j}&#x3D;(1+j+\frac{j(j-1)}2)f_{i-1,j}+\sum\limits_{k&#x3D;0}^{j-1}f_{i-1,k}\binom{j+2}{k}$，后面把组合数打开是个卷积的形式，可以用 NTT 优化</p>
<p>时间复杂度 $\mathcal O(nm\log n)$</p>
<h3 id="AGC022"><a href="#AGC022" class="headerlink" title="AGC022"></a>AGC022</h3><ul>
<li>A</li>
</ul>
<p>如果字母少于 26 个，直接在后面加一个就行了</p>
<p>否则枚举下界最多压到哪里，再在后面加一个，注意特判一下 <code>z...a</code></p>
<ul>
<li>B</li>
</ul>
<p>把第二个条件转化为 $\gcd(a_i,S)\not&#x3D;1$</p>
<p>要求 $\gcd(a_1,a_2,\dots,a_n)&#x3D;1$，先考虑把 $2$ 和 $3$ 选进去，那么要求 $S$ 一定是 $6$ 的倍数</p>
<p>考虑不和 $6$ 的倍数互素的数，有 $6k,6k+2,6k+3,6k+4$，在 $30000$ 以内正好 $20000$ 个</p>
<p>于是把 $6k+2$ 和 $6k+4$ 匹配作为一组，$6k+3$ 两两匹配作为一组，$6k$ 每个数单独作为一组，贪心选即可</p>
<p>特判一下 $n&#x3D;3$ 的情况</p>
<p>时间复杂度 $\mathcal O(n)$</p>
<ul>
<li>C</li>
</ul>
<p>可以先用 $\mathcal O(n^4)$ 的时间预处理出在只用 $\le p$ 的正整数的情况下能否把 $i$ 变成 $j$</p>
<p>然后贪心选，每次选最小的能使所有 $a_i$ 变成 $b_i$ 的 $p$，用桶维护一下当前 $a_i$ 可能的值即可</p>
<p>时间复杂度 $\mathcal O(n^4)$</p>
<ul>
<li>D</li>
</ul>
<p>答案显然是 $2L$ 的倍数（整数次来回），所以接下来求来回的次数</p>
<p>首先把 $\lfloor\frac{t_i}{2L}\rfloor$ 加入答案，并让 $t_i$ 对 $2L$ 取模，把 $t_i&#x3D;0$ 的位置去掉</p>
<p>先构造一种可行的方案：每次从 $i$ 走到 $i+1$，购物，等车走一圈回来上车，这样就有了一个 $n+1$ 次来回的上界，考虑可以怎样省时间</p>
<p>记 $l_i$ 表示车从右往左开的时候到达 $i$ 点购物，能否在车下一次到达 $i$ 时上车，类似定义 $r_i$</p>
<p>则显然有 $l_i&#x3D;[t_i\le 2x_i],r_i&#x3D;[t_i\le 2(L-x_i)]$</p>
<p>考虑如果有 $i&lt;j,l_i&#x3D;1,r_j&#x3D;1$，则要到 $i$ 购物时可以先去 $j$ 购物，再返回 $i$，即可在一次来回中访问两个商场</p>
<p>不难发现这是唯一一种可以减少来回次数的方式</p>
<p>另外还有一个性质：$l_i&#x3D;1,r_i&#x3D;0$ 的点一定在 $l_i&#x3D;0,r_i&#x3D;1$ 的点的右边（可以解个不等式），所以这两类点一定不会匹配</p>
<p>所以贪心地选 $l_i&#x3D;1,r_i&#x3D;0$ 或 $l_i&#x3D;0,r_i&#x3D;1$ 的点和 $l_i&#x3D;1,r_i&#x3D;1$ 的点匹配，最后剩下的 $l_i&#x3D;1,r_i&#x3D;1$ 的点两两匹配即可</p>
<p>时间复杂度 $\mathcal O(n)$</p>
<ul>
<li>E</li>
</ul>
<p>考虑新加入一个 $0$ 或 $1$ 时如何进行操作最优</p>
<p>加入 $0$：如果前面有两个连续的 $0$，则加入这个 $0$ 并删掉两个 $0$；如果前面有一个 $0$，则直接加入这个 $0$；如果前面是 $1$，可以先不急着删，因为后面的 $0$ 可能加进来把这个 $0$ 删掉</p>
<p>加入 $1$：如果前面是 $1$，则直接加入这个 $1$；如果前面是 $0$，则直接删掉，否则这个 $1$ 会隔开前面可能存在的 $0$ 与后面可能加入的 $0$，一定不优</p>
<p>那么我们相当于要维护一个栈，栈底是连续的一段 $1$，栈顶是不多于 $2$ 个 $0$，显然最终 $1$ 的个数比 $0$ 多就合法</p>
<p>设 $f_{i,j,k}$ 为考虑前 $i$ 个数，栈内有 $j$ 个 $1$ 和 $k$ 个 $0$ 的方案数，直接按照上面的策略转移即可</p>
<p>由于 $0$ 最多只有两个，所以栈底的 $1$ 如果多于 $3$ 个就一定合法，所以其实 $j$ 只有四种本质不同的取值，也就是说本质不同的栈只有 $12$ 种</p>
<p>所以直接 dp 的复杂度为 $\mathcal O(n)$</p>
<ul>
<li>F</li>
</ul>
<p><del>（这种题真的是给人做的吗</del></p>
<p>对于每次操作选择的 $A$ 和 $B$，我们连边 $B\to A$，最后连出来显然是一棵树</p>
<p>不难发现对于每一棵树中，每个节点对答案的贡献均为 $(-1)^{c_i}2^{d_i}x_i$，由于 $2^{d_i}&lt;&lt;10^{100}$，所以相当于要计算不同的 ${(c_i\bmod 2,d_i)}$ 的数量</p>
<p>由于 $d_i$ 仅与 $i$ 在树中的深度相关，所以可以一层一层 dp，用一个多重组合数解决</p>
<p>然后考虑 $c_i$，显然每次它的儿子操作时 $c_i$ 都会加一，它的祖先节点如果在 $i$ 后操作那 $c_i$ 也会加一</p>
<p>我们发现直接考虑 $c_i$ 会非常麻烦，实际上只需要考虑 $i$ 和它的父亲符号是否相等</p>
<p>记 $i$ 号点的儿子数量为 $deg_i$，那么与它符号相反的儿子个数为 $\lceil \frac{deg_i}2\rceil$</p>
<p>那么如果当前层有 $k$ 个节点，上一层有奇数个儿子的节点有 $j$ 个，则不考虑这一层的儿子时这一层的节点与父亲符号不同的点为 $\frac{k+j}2$ 个（不存在不能整除的情况）</p>
<p>设 $f_{i,j}$ 为用了 $i$ 个节点，上一层有奇数个儿子的节点有 $j$ 个 </p>
<p>枚举这一层的节点数 $k$，这一层与父亲符号不同的点数 $x$</p>
<p>那么这一层有奇数个儿子的节点就有 $|x-\frac{k+j}2|+2q$ 个，但实际上 $|x-\frac{k+j}2|+2q$ 与 $|x-\frac{k+j}2|$ 的区别只是儿子的父亲换了一个，对符号并没有影响，所以只需要转移到 $|x-\frac{k+j}2|$</p>
<p>所以转移即为 $f_{i+k,|x-\frac{k+j}2|}\leftarrow f_{i,j}\binom{i+k}{i}\binom{k}{x}$</p>
<p>时间复杂度 $\mathcal O(n^4)$，注意一下 $k\ge j$</p>
<h3 id="AGC023"><a href="#AGC023" class="headerlink" title="AGC023"></a>AGC023</h3><ul>
<li>A</li>
</ul>
<p>前缀和+桶，时间复杂度 $\mathcal O(n\log n)$</p>
<ul>
<li>B</li>
</ul>
<p>先把原矩阵复制三份，变成 $2n\times 2n$ 的矩阵</p>
<p>设 $f_{i,j}$ 为 $(i,j)$ 为左上角要求对称最多延伸多少格</p>
<p>可以 $\mathcal O(n)$ 暴力做第 $i$ 行和第 $j$ 列对称最多延伸到哪里，再和 $f_{i+1,j+1}+1$ 取 $\min $ 即可</p>
<p>时间复杂度 $\mathcal O(n^3)$</p>
<ul>
<li>C</li>
</ul>
<p>要计算贡献恰好为 $i$ 的方案数，可以计算至少删去 $n-i-1$ 个机器使原序列仍然可以被覆盖的方案数</p>
<p>不难发现第一个机器和最后一个机器不能删去，其他位置需要删机器时需要至少隔一格</p>
<p>这个可以直接插板法做，最后乘上全排列数</p>
<p>时间复杂度 $\mathcal O(n)$</p>
<ul>
<li>D</li>
</ul>
<p>神仙题（</p>
<p>如果 $s\le x_1$ 或 $s\ge x_n$ 则直接向正&#x2F;负方向走即可</p>
<p>接下来考虑 $x_1&lt;s&lt;x_n$ 的情况</p>
<p>结论：如果 $x_1\ge x_n$，则一定会先走到 $x_1$，再走到 $x_n$；否则一定先走到 $x_n$，再走到 $x_1$</p>
<p>不妨设 $x_1\ge x_n$（$x_1&lt;x_n$ 时同理）</p>
<p>如果 $s\ge x_{n-1}$，则显然会向负方向走（向负方向的人数更多）；否则分直接向负方向走和先向正方向走两种，前一种直接得证，后一种一定会在某个时刻变成前一种或者走到 $s\ge x_{n-1}$ 的情况</p>
<p>那么此时 $x_n$ 回家的时间取决于 $x_1$ 回家的时间，所以 $x_n$ 中的人投的票一定和 $x_1$ 中的人一样，所以可以让 $x_1\leftarrow x_1+x_n$，然后递归地做下去</p>
<p>递归边界即为 $s\le x_1$ 或 $s\ge x_n$</p>
<p>时间复杂度 $\mathcal O(n)$</p>
<ul>
<li>E</li>
</ul>
<p>记 $a_i$ 排序后的数组为 $b_i$，则总方案数 $sum&#x3D;\prod (b_i-i+1)$</p>
<p>我们考虑一个二元组 $i&lt;j$ 的贡献，根据 $a_i$ 和 $a_j$ 分类</p>
<p>记 $a_i$ 排序后的排名为 $id_i$</p>
<p>如果 $a_i&lt;a_j$，则 $p_i&gt;p_j$ 时会产生贡献，此时会对 $a_i&lt;a_k&lt;a_j$ 的 $k$ 产生影响，则有总方案数：</p>
<p>$$<br>\begin{aligned}<br>&amp;\frac{(a_i-id_i+1)(a_i-id_i)}{2}\frac{sum}{(a_i-id_i+1)(a_j-id_j+1)}\prod_{a_i&lt;a_k&lt;a_j}\frac{a_k-id_k}{a_k-id_k+1}\cr<br>&amp;&#x3D;\frac{sum(a_i-id_i)}{2(s_j-id_j+1)}\prod_{a_i&lt;a_k&lt;a_j}\frac{a_k-id_k}{a_k-id_k+1}<br>\end{aligned}<br>$$</p>
<p>如果 $a_i&gt;a_j$，则可以用总方案数减去 $p_i&lt;p_j$ 的方案数，就和上一种情况一样了</p>
<p>发现限制是一个关于 $i$ 和 $a_i$ 的二维偏序，可以按 $a_i$ 从小到大加入每一个 $i$，用一个线段树来维护每个点的贡献即可</p>
<p>时间复杂度 $\mathcal O(n\log n)$</p>
<ul>
<li>F</li>
</ul>
<p>考虑从下向上合并</p>
<p>考虑两个连通块 $a,b$，其中 $0$ 的个数和 $1$ 的个数分别为 $a_0,a_1,b_0,b_1$，则 $a$ 在 $b$ 前面更优显然要满足 $a_1b_0&lt;a_0b_1\Leftrightarrow \frac{a_1}{a_0}&lt;\frac{b_1}{b_0}$</p>
<p>所以可以用一个优先队列从小到大加入一个点 $\frac{cnt_1}{cnt_0}$ 最小的连通块，然后把它和它的父亲所在的连通块合并，可以用一个并查集维护</p>
<p>时间复杂度 $\mathcal O(n\log n)$</p>
<h3 id="AGC024"><a href="#AGC024" class="headerlink" title="AGC024"></a>AGC024</h3><ul>
<li>A</li>
</ul>
<p>每次操作会使答案取相反数，直接判 $k$ 奇偶性即可</p>
<ul>
<li>B</li>
</ul>
<p>题目等价于选一个已经有序的数值连续的子序列</p>
<p>随便 dp 一下即可</p>
<p>时间复杂度 $\mathcal O(n)$</p>
<ul>
<li>C</li>
</ul>
<p>从后往前扫一遍，不难发现前面一个如果 $a_{i}&gt;a_{i+1}-1$ 时需要操作 $a_i$ 次，如果 $a_i&lt;a_{i+1}-1$ 时无解，否则不需要操作</p>
<p>然后判断一下 $a_1$ 是否为 $0$</p>
<p>时间复杂度 $\mathcal O(n)$</p>
<ul>
<li>D</li>
</ul>
<p>假设现在选定 $u$ 为根，设此时最大深度为 $d$，则最小染色数为 $d$</p>
<p>此时要求每层的所有子树同构，所以按深度从大到小统计，叶子个数不断乘上这层中儿子最多的个数</p>
<p>时间复杂度 $\mathcal O(n^2)$</p>
<ul>
<li>E</li>
</ul>
<p>每次向序列中加一个数不好做，考虑删数</p>
<p>删一个数 $a_i$，要求字典序变小，则要求 $a_{i+1}&lt;a_i$（最后一个数永远可删）</p>
<p>我们考虑枚举序列中最小的数什么时候删，这样这个序列就被分成了左右两个独立的序列</p>
<p>设 $f_{i,j}$ 表示 $i$ 个数的序列，值域 $[1,j]$ 的方案数</p>
<p>枚举第一个 $1$ 的位置和删的时间，得到转移：$f_{i,j}&#x3D;\sum f_{k-1,j-1}f_{i-k,j}\sum\binom{t-1}{i-k}$</p>
<p>而最小值可能不是 $1$，所以最后还要对 $f_i$ 求前缀和才是最终的 dp 值</p>
<p>对于每个 $i,k$，预处理 $\sum\binom{t-1}{i-k}$，即可做到 $\mathcal O(n^3)$</p>
<ul>
<li>F</li>
</ul>
<p>子序列问题考虑子序列自动机</p>
<p>我们用一个二元组 $(s,t)$ 记录一个状态，表示匹配了 $s$ 这个串，自动机后面还剩下 $t$ 这个串</p>
<p>每次有三种转移：</p>
<ol>
<li>匹配 $t$ 的第一个字符</li>
<li>匹配 $t$ 的第一个字符取反</li>
<li>结束匹配，$t&#x3D;\emptyset$</li>
</ol>
<p>而每种匹配在自动机上的路径是唯一的，所以直接 dp 数路径即可</p>
<p>设 $f_{i,p}$ 表示 $|s|+|t|&#x3D;i$，$s+t&#x3D;p$ 的方案数</p>
<p>从小到大枚举 $|s|$，先统计此时的答案（也就是第三种转移），再考虑第二种转移，第一种转移由于 $i$ 和  $p$ 都不会变所以直接加上即可，不需要考虑</p>
<p>时间复杂度 $\mathcal O(n^22^n)$（写好一点大概可以 $\mathcal O(n2^n)$？）</p>
<h3 id="AGC025"><a href="#AGC025" class="headerlink" title="AGC025"></a>AGC025</h3><ul>
<li>A</li>
</ul>
<p>枚举 $a$ 和 $b$ 即可</p>
<p>时间复杂度 $\mathcal O(n\lg n)$</p>
<ul>
<li>B</li>
</ul>
<p>枚举 $a$ 涂几个格子，算出 $b$ 涂几个格子，然后组合数算一下</p>
<p>时间复杂度 $\mathcal O(n)$</p>
<ul>
<li>C</li>
</ul>
<p>对于移棋子的人来说，一定是一走到区间的端点就停下来（除非本来就在区间里，此时不动）</p>
<p>对于选区间的人来说，一定希望棋子左右反复横跳</p>
<p>所以维护两个堆分别维护最小的右端点和最大的左端点</p>
<p>然后轮流从这两个堆里取区间即可</p>
<p>时间复杂度 $\mathcal O(n\log n)$</p>
<ul>
<li>D</li>
</ul>
<p>不难发现距离为 $\sqrt {D_1}$ 的点连边之后是个二分图，我们需要黑白染色从中取一种颜色</p>
<p>所以我们把 $\sqrt {D_1}$ 和 $\sqrt{D_2}$ 分别建出两个二分图，分别进行黑白染色</p>
<p>对于每个点在两个图中的颜色有四种情况，由于一共是 $4n^2$ 个点，所以由抽屉原理一定有一种染色情况有至少 $n^2$ 个点</p>
<p>时间复杂度 $\mathcal O(n^3)$</p>
<ul>
<li>E</li>
</ul>
<p>如果每条边都被覆盖了偶数次，那一次操作 $(u,v)$ 可以让 $u\to v$ 连边，此时所有点一定只有偶度数，可以跑一遍欧拉回路，可以保证每一条边正向和反向次数相等</p>
<p>考虑如果有边被覆盖了奇数次如何转化</p>
<p>此时我们希望被覆盖奇数次的边正向和反向次数差 $1$，所以考虑加一些边</p>
<p>在树上如果当前节点度数为奇数则向父亲加一条边，这样保证每个被覆盖奇数次的边都变成偶数次，偶数次的边都都没有加边</p>
<p>直接在这张图上跑欧拉回路即可定向</p>
<p>最后用树上差分统计下答案即可</p>
<p>时间复杂度 $\mathcal O(n\log n)$</p>
<ul>
<li>F</li>
</ul>
<p>不妨把二进制串反过来，这样容易操作</p>
<p>对于一个次操作，我们可以从大到小枚举每一位，如果 $a_i&#x3D;b_i&#x3D;1$ 就加上不断向前进位</p>
<p>我们发现一次操作中后面的数进行操作必然不会影响到前面操作的数</p>
<p>所以考虑对于一个位置不断向后做完 $k$ 次操作</p>
<p>每次遇到 $a_i&#x3D;b_i&#x3D;1$ 且剩余操作次数 $&gt;0$ 就加上然后不断向前进位</p>
<p>如果每次操作的时候遇到 $1$ 一定会让 $1$ 的总个数变少，所以考虑用一个栈维护 $1$ 存在的位置，跳过连续的全 $0$ 段</p>
<p>这样就可以做到 $\mathcal O(n)$ 了</p>
<h3 id="AGC026"><a href="#AGC026" class="headerlink" title="AGC026"></a>AGC026</h3><ul>
<li>A</li>
</ul>
<p>扫一遍，碰见一样的把后面那个改掉即可</p>
<p>时间复杂度 $\mathcal O(n) $</p>
<ul>
<li>B</li>
</ul>
<p>如果一开始 $a&lt;b$ 则一定不行，如果 $b&gt;d$ 也不行</p>
<p>考虑把 $a$ 对 $b$ 取模，若此时 $a&gt;c$ 则一定不行，如果 $b\le c+1$ 则一定可行</p>
<p>考虑把 $d$ 对 $b$ 取模，若此时 $d&#x3D;0$ 则一定可行</p>
<p>根据裴蜀定理，记 $g&#x3D;\gcd(b,d)$，若存在一个 $c&lt;a+kg&lt;b$ 则一定不可行，否则一定可行</p>
<p>时间复杂度 $\mathcal O(T\log w)$</p>
<ul>
<li>C</li>
</ul>
<p>考虑折半搜索</p>
<p>枚举前一半哪些染红哪些染蓝，算出哈希值，用 <code>map/unordered_map</code> 维护哈希值即可</p>
<p>时间复杂度 $\mathcal O(n2^n)$</p>
<ul>
<li>D</li>
</ul>
<p>对于一个矩形，如果第一行形如 <code>RBRB...</code> 或 <code>BRBR...</code> 则每行都有两种方法，否则只有一种方法</p>
<p>设当前区间为 $[l,r]$，可以根据最小值分成若干的区间，把这些区间的关系用树的形式表示出来</p>
<p>设 $f_u$ 为节点 $u$，形如 <code>RBRB...</code> 或 <code>BRBR...</code> 的方案数，$g_u$ 为节点 $u$ 的方案数</p>
<p>记节点 $u$ 的矩形高为 $h$，最小值有 $c$ 个</p>
<p>则考虑枚举下一行选什么，得到转移：</p>
<p>$f_u&#x3D;2^h\prod f_v,g_u&#x3D;2^c\prod(f_v+g_v)+(2^h-2)\prod f_v$</p>
<p>其中 $f_v+g_v$ 是因为选择 $f_v$ 时由于上下两行无关所以要再加一遍，$2^h-2$ 是把前面多统计的 <code>BRBR...</code> 型的方案减掉</p>
<p>时间复杂度 $\mathcal O(n\log h)$</p>
<ul>
<li>E</li>
</ul>
<p><del>怎么感觉 E 比 D 简单（</del></p>
<p>把原串分成尽量多段，使得每段中 <code>a</code> 和 <code>b</code> 数量相等</p>
<p>若这段以 <code>a</code> 开始，则一定希望选择尽量长的 <code>abab...</code> 段，直接扫一遍即可</p>
<p>若这段以 <code>b</code> 开始，枚举开头多少个 <code>b</code> 不选，剩下的如果有字符不选显然不优，比较一下选一个最优的串即可</p>
<p>最后维护一个单调栈，记栈顶串 $s$，新加入的串 $t$，则如果 $s+t&lt;t$ 一定不选 $s$</p>
<p>时间复杂度 $\mathcal O(n^2)$</p>
<ul>
<li>F</li>
</ul>
<p>考虑对格子黑白染色，设黑格子（膜 $2$ 余 $1$）权值和为 $b$，白格子为 $w$</p>
<p>如果 $n$ 为偶数，则先手一定可以得到 $\max{b,w}$ 的权值，后手也可以至少保住 $\min{b,w}$ 的权值</p>
<p>接下来考虑 $n$ 为奇数</p>
<p>如果先选黑格子，则先手一定可以得到 $b$ 的权值，后手也可以至少保住 $w$ 的权值</p>
<p>只需要考虑先选白格子能不能得到更多的收益即可</p>
<p>如果先手选择了白格子，则接下来后手可以选择一边，先手拿走白格子，后手拿走黑格子</p>
<p>然后先手继续选择一个白格子，变成了一个子问题，由于每次拿都是拿偶数个，则最后一定剩下一个区间先手拿走黑格子，后手拿走白格子</p>
<p>记一个区间 $[l,r]$ 的价值为区间中黑格子权值和减去白格子权值和</p>
<p>假设先手一共选择了 $p_1,\dots,p_k$ 这些白格子，则后手可以通过操作让先手拿黑格子的区间价值最小</p>
<p>二分一个值 $x$，表示先手可不可以得到至少 $w+x$ 的权值</p>
<p>也就是说要判定能不能选出若干白格子 $p_1,\dots,p_k$，使得所有区间 $(p_i,p_{i+1})$ 以及 $[1,p_1)$ 和 $(p_k,n]$ 的价值都 $\ge x$，直接 dp 即可</p>
<p>时间复杂度 $\mathcal O(n\log \sum a)$</p>
<h3 id="AGC027"><a href="#AGC027" class="headerlink" title="AGC027"></a>AGC027</h3><ul>
<li>A</li>
</ul>
<p>记 $s&#x3D;\sum a_i$</p>
<p>若 $s&#x3D;x$，则答案为 $n$；若 $s&lt;x$，则答案为 $n-1$；若 $s&gt;x$ 则不断删除最大的 $a$ 使得 $s\le x$ 即可</p>
<p>时间复杂度 $\mathcal O(n\log n)$</p>
<ul>
<li>B</li>
</ul>
<p>枚举回来扔垃圾的次数 $k$，不难发现每一次出去时带回来下标 $\bmod k$ 相同的垃圾</p>
<p>维护一个前缀和，然后每 $k$ 个分一段直接统计即可</p>
<p>时间复杂度 $\mathcal O(n\ln n)$</p>
<ul>
<li>C</li>
</ul>
<p>对于每一个节点，如果走到它是合法的，那它一定有一个后继点为 <code>A</code>，也有一个后继点为 <code>B</code></p>
<p>考虑把不合法的点删掉，剩下的点中还会出现新的不合法点</p>
<p>直接类似拓扑排序做即可，时间复杂度 $\mathcal O(n)$</p>
<ul>
<li>D</li>
</ul>
<p>称一条 $x+y&#x3D;2k$ 或 $x-y&#x3D;2k$ 的对角线为偶对角线，显然每个偶对角线经过的点都被两条偶对角线经过</p>
<p>考虑给每条偶对角线分配一个质数不同的质数 $p_i$，每个被偶对角线上经过的点的权值为两条经过它的偶对角线的质数乘积</p>
<p>则不在偶对角线上的点的权值为周围四个点的点权的 $\operatorname{lcm}$，也就是围绕它的四条偶对角线上质数的乘积</p>
<p>调整一下分配质数的顺序，使大质数和小质数交替出现即可让四个质数乘积 $\le 10^{15}$</p>
<p>注意特判 $n&#x3D;2$，时间复杂度 $\mathcal O(n^2)$</p>
<ul>
<li>E</li>
</ul>
<p>性质：如果把 <code>a</code> 看成 $1$，<code>b</code> 看成 $2$，则每次修改数列的和膜 $3$ 不变</p>
<p>发现最终字符串中的每个字符都是从原串中的一个子串变来的，考虑一个字母 $c$ 能被什么样的字符串 $s$ 操作得到</p>
<p>记字符串 $s$ 变成数字串之后膜 $3$ 的余数为 $f(s)$，则显然要求 $f(c)&#x3D;f(s)$</p>
<p>但这并不充分，因为存在 <code>abababa...</code> 这样的字符串，不能进行操作</p>
<p>发现加入 $s$ 中存在一个位置 $i$ 使得 $s_i&#x3D;s_{i+1}$ 就变成充分的了，因为每次都可以选择一个形如 <code>aab</code> 或 <code>baa</code> 的位置进行操作，操作之后一定还可以继续操作</p>
<p>考虑什么样的字符串 $t$ 能被 $s$ 通过操作得到，可以考虑贪心，每次选最近的一个可以得到 $t_i$ 前缀，最后剩下一个未被匹配的后缀（未匹配的后缀的 $f$ 值一定为 $0$），可以证明当 $s$ 中含有两个相邻的字母相同时每一个合法的 $t$ 都对应了一个这样贪心的划分，每一个划分都对应了一个合法的 $t$</p>
<p>设 $f_i$ 为前 $i$ 个字符可以表示的 $t$ 个数，转移显然（</p>
<p>时间复杂度 $\mathcal O(n\log n)$（用了二分）</p>
<ul>
<li>F</li>
</ul>
<p>考虑枚举第一步选择 $u$，连到了 $v$，则 $u$ 不能再被操作，考虑两棵树都以 $u$ 为根，转化成有根树处理</p>
<p>设一个节点 $u$ 在 <code>A</code> 树上的父亲为 $fa_u$，在 <code>B</code> 树上的父亲为 $fb_u$</p>
<p>若 $fa_u\not &#x3D;fb_u$ 则 $u$ 需要被操作，否则不能被操作</p>
<p>对于一个点 $u$，若 $u$ 不能被操作，则 $fa_u$ 也不能被操作</p>
<p>对于一个点 $u$，若 $u$ 需要被操作，$fa_u$ 也要被操作，则 $u$ 一定在 $fa_u$ 之前被操作；若 $u$ 需要被操作，$fb_u$ 也需要被操作，则 $fb_u$ 一定在 $u$ 之前被操作</p>
<p>可以根据先后关系建出一张有向图，跑一遍拓扑排序，如果有环则不合法</p>
<p>时间复杂度 $\mathcal O(Tn^3)$</p>
<h3 id="AGC028"><a href="#AGC028" class="headerlink" title="AGC028"></a>AGC028</h3><p>这什么神仙 round（</p>
<ul>
<li>A</li>
</ul>
<p>如果有解则答案一定是 $\operatorname{lcm}(n,m)$，用 <code>map</code> 维护一个桶判一下即可</p>
<p>时间复杂度 $\mathcal O(n\log n)$</p>
<ul>
<li>B</li>
</ul>
<p>对于每个区间 $(l,r)$ 计算贡献，这里贡献指 $(l,r)$ 中所有元素作为一个连通块出现产生的贡献</p>
<p>若 $l\ge 1,r\le n$，则 $(l,r)$ 会对答案产生 $2!\binom{n}{r-l+1}(r-l-1)!(n-(r-l+1))!&#x3D;\frac{2n!}{(r-l+1)(r-l)}$，只和区间长度 $r-l$ 有关，每个区间长度一起统计即可</p>
<p>剩下有 $l&#x3D;0$ 和 $r&#x3D;n+1$ 的情况，单独统计即可</p>
<p>时间复杂度 $\mathcal O(n)$</p>
<ul>
<li>C</li>
</ul>
<p>稍微转化一下题面，变为选出来的边边权可以在 $a_u$ 和 $b_v$ 中选一个，这样由于选大的那个一定不优，所以不影响答案</p>
<p>发现有三种合法的情况：</p>
<ol>
<li>所有点全选 $a$</li>
<li>所有点全选 $b$</li>
<li>存在一个点同时选 $a$ 和 $b$</li>
</ol>
<p>前两种显然，第三种可以把每个点拆成 $a$ 和 $b$ 两个点，也容易构造出方案</p>
<p>如果同时不满足这三种情况，则一定是所有点要么选 $a$，要么选 $b$，此时最少只能连出两个环，所以不合法</p>
<p>前两种直接算，最后一种枚举这个点然后取剩下的所有 $a$ 和 $b$ 中前 $n-2$ 小的即可</p>
<p>时间复杂度 $\mathcal O(n\log n)$</p>
<ul>
<li>D</li>
</ul>
<p>不难发现这道题把点放在圆上和放在直线上是等价的（两条边交叉的条件相同），所以直接把环变成链</p>
<p>考虑每个连通块的贡献，发现每个连通块都存在恰好一个区间 $[l,r]$，使得 $l$ 和 $r$ 都在连通块中且所有连通块中的点都在 $[l,r]$ 中</p>
<p>设 $f_{l,r}$ 为只考虑 $[l,r]$ 中的点的情况下 $[l,r]$ 为上述类型的区间的方案数</p>
<p>考虑容斥，先随便连边再减去 $l$ 和 $r$ 不在同一连通块的方案数</p>
<p>显然区间 $[l,r]$ 长度为奇数时 $f_{l,r}&#x3D;0$，若 $[l,r]$ 中有一点强制连向区间外的点则也有 $f_{l,r}&#x3D;0$</p>
<p>记 $cnt_{l,r}$ 表示 $[l,r]$ 中可以连边的点数，$g_i$ 表示 $i$ 个点随便连边的方案数</p>
<p>显然在 $i$ 为奇数时 $g_i&#x3D;0$，否则 $g_i&#x3D;(i-1)(i-3)\cdots3\cdot1&#x3D;(i-1)g_{i-2}$</p>
<p>则有 $f_{l,r}&#x3D;g_{cnt_{l,r}}-\sum f_{l,k}g_{cnt_{k+1,r}}$，然后对于每个区间统计答案即可</p>
<p>时间复杂度 $\mathcal O(n^3)$</p>
<ul>
<li>E</li>
</ul>
<p>要求字典序最小的字符串，显然考虑贪心，只需要考虑一个位置能不能放 $0$ 即可</p>
<p>记当前 $A$ 集合中前缀最大值个数有 $ca$ 个，$A$ 中最大值为 $pa$；同样定义 $cb$ 和 $pb$；记原序列中在当前位置之后的前缀最大值的数集为 $p$</p>
<p>假设当前位置之后成为 $A$ 中前缀最大值的数集为 $a$，有 $pa&lt;a_1&lt;\dots&lt;a_{|a|}$；同样定义 $b$，$pb&lt;b_1&lt;\dots&lt;b_{|b|}$</p>
<p>重要结论：若存在合法的分组方法，则必然存在一种方法使得 $a$ 和 $b$ 中至少有一个集合中所有的元素都是 $p$ 中的元素</p>
<p>否则如果 $a$ 和 $b$ 中都有不在 $p$ 中的元素则可以交换这两个元素所在的集合使得它们都变成非前缀最大值</p>
<p>不妨设 $a$ 中的元素都在 $p$ 中出现，显然剩下 $p$ 中的元素都在 $b$ 中出现，设有 $k$ 个，记 $m&#x3D;|b|-k$，即 $b$ 中不在 $p$ 中出现的元素个数</p>
<p>最终要求两个集合的前缀最大值个数相等，即 $ca+|a|&#x3D;cb+|b|\Leftrightarrow ca+|p|-k&#x3D;cb+m+k\Leftrightarrow 2k+m&#x3D;ca-cb+|p|$</p>
<p>考虑给每个数一个权值，$p$ 中的数给 $2$ 的权值，不在 $p$ 中的数给 $1$ 的权值，最终就是要判定存不存在一个上升子序列的权值和为 $ca-cb+|p|$</p>
<p>不难发现若权值和为 $x$ 的上升子序列存在，则权值和为 $x-2$ 的上升子序列存在（删掉一个权值为 $2$ 的或者两个权值为 $1$ 的），所以维护 $f_{i,0&#x2F;1}$ 表示从 $i$ 开始权值和为偶数&#x2F;奇数的权值和最大的上升子序列</p>
<p>这个可以用两棵线段树类似 LIS 维护，时间复杂度 $\mathcal O(n\log n)$</p>
<ul>
<li>F</li>
</ul>
<p><del>不理解这种题为什么会有人赛时通过（</del></p>
<p>考虑分治，设分界线为 $x&#x3D;mid$，考虑下半部分跨过分界线对上半部分每个点的贡献</p>
<p>考虑当前计算的上半部分的行 $row$</p>
<p>一些关键性质：</p>
<ol>
<li>记 $(row,i)$ 可以到达的第 $mid$ 行的点集为 $S_i$，则 $\max {S_i}$ 和 $\min{S_i}$ 都随 $i$ 单调递增（否则两条路径一定相交，矛盾）</li>
<li>记全集 $U_{row}&#x3D;\bigcup\limits_{1\le i\le m} S_i$，$ul_i&#x3D;\min{S_i}$，$ur_i&#x3D;\max{S_i}$，则 $S_i&#x3D;U_{row}\cap[ul_i,ur_i]$（否则两条路径一定相交，矛盾）</li>
<li>记 $d_i$ 为 $(mid,i)$ 能够到达的 $(x,y)$ 中最大的 $x$，$T_{i}$ 为 $(mid,i)$ 能够到达的下半部分的点集，则对于 $i&lt;j&lt;k$，若满足 $d_j\ge d_i$ 或 $d_j\ge d_k$ 则有 $T_i\cap T_k\subseteq T_j$（证明显然，可以画个图）</li>
</ol>
<p>考虑维护 $val_i$ 表示当前在 $T_i$ 中且不在 $T_j(j&gt;i)$ 中的点权值和，这样从右边加一个点时不断更新左边的 $val_i$，从左边删一个点时直接减去 $val_i$ 就行了（由性质 2 可得一个点所需要考虑的 $T_i$ 在一个区间上）</p>
<p>由性质 3，发现若一个点 $i$ 从一个关于 $d_i$ 单调减的单调队列中弹出了，则 $val_i$ 就不会再改变了，所以一共需要更新的 $val_i$ 其实只有 $\mathcal O(n)$ 个</p>
<p>考虑对于 $j&lt;i$ 计算 $val_j$ 和 $val_i$ 中相交的部分，记 $d&#x3D;\max\limits_{i&lt;k&lt;j}{d_k}$，则不难发现 $\le d$ 的部分已经在 $k$ 中去掉了，不需要考虑</p>
<p>则我们需要去掉的即为 $both(j,i,d+1)$，即 $T_j\cap T_i$ 中行数 $\ge d+1$ 的部分</p>
<p>综上，我们需要预处理 $ul$，$ur$，$U_{row}$，$d$ 和 $both$，接下来一个一个考虑如何预处理</p>
<p>显然 $ul$ 和 $ur$ 可以直接递推得到</p>
<p>对于 $U_{row}$，可以考虑对于每个 $(mid,i)$ 维护一个 $low_i$ 表示可以到达 $(mid,i)$ 的 $(x,y)$ 中最小的 $x$，则所有 $row \ge low_i$ 的 $U_{row}$ 中都有 $i$</p>
<p>此时 $low$ 和 $d$ 都可以通过同样的递推方式得到</p>
<p>接下来考虑如何计算 $both$</p>
<p>记 $b_{i,j}$ 为去掉不可以从 $x&#x3D;mid$ 中任意一点到达的点后的 $a_{i,j}$，$sum_{i,j}&#x3D;\sum\limits_{k\le j} b_{i,k}$</p>
<p>记 $dl_{i,j}$ 为 $(mid,j)$ 可以到达的 $(i,x)$ 中最小的 $x$，$dr_{i,j}$ 为 $(mid,j)$ 可以到达的 $(i,x)$ 中最大的 $x$</p>
<p>则 $both(i,j,d)=\sum [k\ge d\land dl_{k,j}\le dr_{k,i}](sum_{k,dr_{k,i}}-sum_{k,dl_{k,j}-1})$</p>
<p>记 $met_{i,j}$ 为满足 $dl_{k,j}\le dr_{k,i}$ 的 $k$ 中最小的 $k$</p>
<p>则 $both(i,j,d)=\sum[k\ge d\land k\ge met_{i,j}](sum_{k,dr_{k,i}}-sum_{k,dl_{k,j}-1})$，可以预处理 $sum_{k,dr}$ 关于 $k$ 的前缀和 $pr$ 和 $sum_{k,dl}$ 关于 $k$ 的前缀和 $pl$</p>
<p>接下来只需要预处理 $dl$，$dr$ 和 $met$</p>
<p>记 $nxt_{i,j}$ 表示<strong>在 $b$ 意义下</strong>可以从 $(i,x)$ 走到 $(i+1,x)$ 中 $x\ge j$ 的最小 $x$，则 $dl_{i+1,j}&#x3D;nxt_{i,dl_{i,j}}$</p>
<p>记 $pre_{i,j}$ 表示<strong>在 $b$ 意义下</strong>可以从 $(i,x)$ 走到 $(i+1,x)$ 中 $x\le j$ 的最大 $x$，$to_{i,j}$ 为可以从 $(i,j)$ 走到 $(i,x)$ 中最大的 $x$，则有 $dr_{i+1,j}&#x3D;to_{i+1,pre_{i,dr_{i,j}}}$</p>
<p>$nxt$，$pre$ 和 $to $ 都很容易递推预处理</p>
<p>对于 $met_{i,j}$，有性质若 $j&lt;k$ 且 $met_{i,j}$ 和 $met_{i,k}$ 均存在，则 $met_{i,j}\le met_{j,k}$，所以可以维护一个单调的变量 $k$，每次尝试增大 $k$ 直到找到 $met_{i,j}$ 或者有 $k&gt;d_i$ 或 $k&gt;d_j$，显然此时 $met_{i,j}$ 不存在</p>
<p>预处理 $met_{i,j}$ 的总复杂度即为 $\mathcal O(n^2)$ 的了</p>
<p>预处理完之后计算就好算了，刚加入时 $val_i$ 可以用 $both(i,i,mid)$ 算出来</p>
<p>时间复杂度 $\mathcal O(n^2\log n)$，注意不要 <code>memset</code>，否则复杂度会退化</p>
<p><del>（这是我第一次见到 5kb 的 AGC 题，但写起来逻辑其实挺清晰的</del></p>
<h3 id="AGC029"><a href="#AGC029" class="headerlink" title="AGC029"></a>AGC029</h3><ul>
<li>A</li>
</ul>
<p>显然一个 <code>W</code> 能操作的次数为它之前 <code>B</code> 的个数，直接相加即可</p>
<p>时间复杂度 $\mathcal O(n)$</p>
<ul>
<li>B</li>
</ul>
<p>先把相等的数放到一起统计</p>
<p>若两个数不相等且加起来是 $2$ 的幂次，则连一条边，不难发现连出来的是一个森林</p>
<p>（如果有环则可以根据环中所有数互不相等所以 $2$ 的幂次互不相等，最大的 $2$ 的幂次一定大于剩下所有 $2$ 的幂次的和推出矛盾）</p>
<p>直接贪心即可，注意本身就是 $2$ 的幂次的数可以自己和自己匹配</p>
<p>时间复杂度 $\mathcal O(n\log w)$</p>
<ul>
<li>C</li>
</ul>
<p>显然答案具有可二分性，所以只需要考虑答案为 $k$ 时能否构造出一组解</p>
<p>若 $a_{i-1}&lt;a_i$ 则直接在 $s_{i-1}$ 后加 <code>a</code> 即可满足条件</p>
<p>否则需要在 $s_i$ 取 $s_{i-1}$ 的前缀的基础上把 $s_i$ 的最后一位加 $1$，根据答案最多为 $k$ 不断向前进位</p>
<p>不难发现字符串中不为 <code>a</code> 的位置有 $\mathcal O(n)$ 个，可以直接用栈维护</p>
<p>时间复杂度 $\mathcal O(n\log n)$</p>
<ul>
<li>D</li>
</ul>
<p>可以把题目转化为最小化先手最多向下走的步数</p>
<p>记 $f_i$ 为到达第 $i$ 列时最少在第几行，根据 $f_i$ 的单调性可以用 <code>set</code> 在 $\mathcal O(n\log n)$ 的时间内求出</p>
<p>求出 $f_i$ 后枚举最后停在第几列，根据 $f_i$ 算出最后停在第几行</p>
<p>时间复杂度 $\mathcal O(n\log n)$</p>
<ul>
<li>E</li>
</ul>
<p><del>智商不够，数据结构来凑（</del></p>
<p>考虑如何计算 $u$ 的答案，记 $u\to 1$ 的路径为 $p_1&#x3D;1\to p_2\to\dots\to p_k&#x3D;u$</p>
<p>把这一条链单独拉出来，把整棵树看成有若干子树挂在这一条链上</p>
<p>对于挂在 $p_k$ 上的子树，不难发现所有 $&gt;\max{p_1,\dots,p_{k-1}}$ 的点的子树都不会被经过，其他点都会被经过；挂在其他点上同理</p>
<p>记 $f_u$ 为 $u$ 子树中除去 $&gt;\max{p_1,\dots,p_{k-1}}$ 的点的子树以外的点的数量</p>
<p>$f$ 可以直接用一棵支持区间加区间清零和合并的线段树维护</p>
<p>从上到下扫一遍即可，时间复杂度 $\mathcal O(n\log n)$</p>
<p>据说正解是高妙的 $\mathcal O(n)$（？</p>
<ul>
<li>F</li>
</ul>
<p>Hall 定理：二分图 $G$ 左边有 $n$ 个点，右边有 $m$ 个点（$n\le m$），存在完备匹配当且仅当对于任意左边点集 $S$，记 $f(S)$ 为和左边点集 $S$ 相连的点集，都有 $|f(S)|\ge |S|$</p>
<p>这题中对于一个边集 $S$，记 $f(S)$ 为 $S$ 中边涉及到的点集，则要求 $|f(S)|\ge |S|+1$，形式和 Hall 定理类似</p>
<p>考虑建立一个二分图，左边代表 $n$ 个点，右边代表 $n-1$ 条边，跑一遍匹配</p>
<p>如果不存在完备匹配，则一定有 $|f(S)|\le |S|$ 的边集出现，显然不合法</p>
<p>记 $cp_i$ 表示在完备匹配中第 $i$ 条边所匹配到的点</p>
<p>在完备匹配中一定有且仅有一个没有匹配的点，即为 $rt$，则考虑从 $rt$ 开始递归构造答案</p>
<p>记当前节点为 $u$，选一个与 $u$ 相连的还没被选过的边 $v$，连边 $u\to cp_v$，对 $cp_v$ 递归构造</p>
<p>这样构造显然不会产生环，所以构造出的答案一定合法</p>
<p>如果构造失败，则一定是左边所有的点都无法匹配右边的边了，记没有被选过的边集为 $S$，则根据选过的点一定比选过的边多 $1$ 可得 $|f(S)|\le |S|$，所以此时一定无解</p>
<p>时间复杂度 $\mathcal O(n\sqrt n)$</p>
<h3 id="AGC030"><a href="#AGC030" class="headerlink" title="AGC030"></a>AGC030</h3><ul>
<li>A</li>
</ul>
<p>答案为 $b+\min{a+b+1,c}$</p>
<ul>
<li>B</li>
</ul>
<p>考虑枚举最后停在哪个节点上，设为 $i$</p>
<p>不妨设最后是从 $0$ 顺时针走到 $x_i$（逆时针和顺时针同理）</p>
<p>我们称 $[i+1,r]$ 为左边，$[1,i-1]$ 为右边，不难发现要求左边选的点数等于右边的点数或者右边的点数+1</p>
<p>所以直接拿前缀和和后缀和维护即可</p>
<p>时间复杂度 $\mathcal O(n)$</p>
<ul>
<li>C</li>
</ul>
<p>首先对于一个 $k$，有一个 $k\times k$ 的方法，即每条对角线放一种颜色</p>
<p>比如 $k&#x3D;4$ 时有：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1234</span><br><span class="line">4123</span><br><span class="line">3412</span><br><span class="line">2341</span><br></pre></td></tr></table></figure>

<p>发现在矩阵边长为偶数时，每条对角线上可以有两个数交替出现</p>
<p>比如 $k&#x3D;8$ 时可以构造这样一个 $4\times 4$ 的矩阵：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1234</span><br><span class="line">8567</span><br><span class="line">3412</span><br><span class="line">6785</span><br></pre></td></tr></table></figure>

<p>这样我们就有一个 $\frac k2$ 级别的构造方案了</p>
<ul>
<li>D</li>
</ul>
<p>考虑分别计算每个位置对 $(i,j),i&lt;j$ 产生的贡献</p>
<p>设 $f_{k,i,j}$ 为考虑完成前 $k$ 个操作后，$a_i&gt;a_j$ 的方案数</p>
<p>不难发现对于所有与操作 $k$ 无关的 $(i,j)$ 它的 $f_{k,i,j}$ 都会变成 $2f_{k-1,i,j}$</p>
<p>所以考虑把 $f_{k,i,j}$ 的定义变成完成前 $k$ 个操作后，$a_i&gt;a_j$ 的概率</p>
<p>这时与操作 $k$ 无关的 $(i,j)$ 的 $f_{k,i,j}$ 就和 $f_{k-1,i,j}$ 一样了</p>
<p>即每次需要更改的 $f$ 值只有 $\mathcal O(n)$ 个，直接暴力修改即可</p>
<p>最后统计答案时要把概率乘上总方案数 $2^q$，变成方案数</p>
<p>时间复杂度 $\mathcal O(qn)$</p>
<ul>
<li>E</li>
</ul>
<p>神题（</p>
<p>我们在每个字符串的 <code>01</code> 之间画一条红线，<code>10</code> 之间画一条蓝线，不难发现红蓝线一定间隔出现</p>
<p>现在每一次操作即为移动一条线，要求每两条线之间的距离时刻保持在 $1$ 或 $2$</p>
<p>考虑枚举初始串的第一条线与终止串的哪一条线匹配，这样所有线的匹配方式就确定了</p>
<p>此时可能会出现两端的线无法匹配的情况，所以考虑在每个串两端以红蓝线间隔的方式补线</p>
<p>此时显然有答案下界，即所有线需要移动的最短距离之和</p>
<p>下证这个下界一定取得到：</p>
<p>首先由题意，不可能出现相邻两条线一个向左移一个向右移（否则一定会出现至少三个同样的字符）</p>
<p>所以移线方式一定是一些连续的左移段&#x2F;右移段中间被不移动的线分隔</p>
<p>而连续的左移段&#x2F;右移段一定可以取到这个下界（每次移动最右边&#x2F;最左边需要移动的线一定合法，否则在终止串中一定会出现至少三个同样的字符）</p>
<p>于是直接枚举初始串的第一条线匹配终止串的哪一条线，再枚举每条线计算距离即可</p>
<p>时间复杂度 $\mathcal O(n^2)$</p>
<ul>
<li>F</li>
</ul>
<p>首先可以把两个数都确定的数对删掉，剩下的就是只有一个数确定或者两个都不确定的</p>
<p>考虑从大到小一个一个把数加进去</p>
<p>对于两个数都不确定的数对，它们的位置是不确定的，可以把它们认为是无标号的，在最后乘上一个排列数</p>
<p>而对于有一个数确定的数对，它们的位置已经确定，可以把它们认为是有标号的，转移的时候直接乘上系数</p>
<p>设 $f_{i,j,k}$ 表示加到 $i$，有 $j$ 个目前两个数都不确定的数对还有一个数没填，有 $k$ 个确定了一个数的数对另一个数没填</p>
<p>如果 $i$ 在确定的数中出现了，则有和 $j$ 匹配&#x2F;不匹配两种转移</p>
<p>如果 $i$ 没在确定的数中出现，则有和 $j$ 匹配&#x2F;和 $k$ 匹配&#x2F;不匹配三种转移，其中和 $k$ 匹配需要乘上 $k $ 的转移系数</p>
<p>时间复杂度 $\mathcal O(n^3)$</p>
<h3 id="AGC031"><a href="#AGC031" class="headerlink" title="AGC031"></a>AGC031</h3><ul>
<li>A</li>
</ul>
<p>设字母 $i$ 出现了 $a_i$ 次，则答案为 $\prod(a_i+1)$</p>
<p>时间复杂度 $\mathcal O(n)$</p>
<ul>
<li>B</li>
</ul>
<p>首先把相邻两个同色的石头去掉</p>
<p>设 $f_i$ 为考虑前 $i$ 个石头不同的染色数</p>
<p>则有 $f_i&#x3D;\sum\limits_{j&lt;i,c_i&#x3D;c_{j+1}} f_j$</p>
<p>用桶维护即可，时间复杂度 $\mathcal O(n)$</p>
<ul>
<li>C</li>
</ul>
<p><del>直接考场降智了属于是（</del></p>
<p>显然 $\operatorname{popcount}(A\operatorname{xor} B)$ 是奇数，可以先判掉</p>
<p>考虑归纳构造</p>
<p>显然 $n&#x3D;1$ 的时候序列为 $0,1$ 或者 $1,0$</p>
<p>$n\ge 2$ 的时候可以用两个 $n-1$ 的答案拼起来，前面那个可以用 csp 考的那个格雷码，后面的可以递归构造</p>
<p>时间复杂度 $\mathcal O(n2^n)$</p>
<ul>
<li>D</li>
</ul>
<p><del>这场的 D 和 F 真的是人能做的吗（</del></p>
<p>记 $a\circ b$ 为置换 $a$ 和置换 $b$ 的复合，即满足 $p_i&#x3D;a_{b_i}$ 的排列 $p$，显然它满足结合律但不满足交换律</p>
<p>记 $\epsilon$ 为单位元，即 $\epsilon&#x3D;{1,2,\dots,n}$，满足 $a\circ \epsilon&#x3D;a$，$\epsilon\circ a&#x3D;a$</p>
<p>即 $a^{-1}$ 为 $a$ 的逆，满足 $a\circ a^{-1}&#x3D;\epsilon$</p>
<p>还有如下运算性质：$(p\circ q)^{-1}&#x3D;q^{-1}\circ p^{-1}$，原因是 $p\circ q\circ q^{-1}\circ p^{-1}&#x3D;\epsilon$</p>
<p>由于 $f(p,q)_{p_i}&#x3D;q_i$，可得 $f(p,q)\circ p&#x3D;q$，即 $f(p,q)&#x3D;q\circ p^{-1}$</p>
<p>稍微往后推几项：</p>
<p>$$<br>a_1&#x3D;p<br>$$<br>$$<br>a_2&#x3D;q<br>$$<br>$$<br>a_3&#x3D;q\circ p^{-1}<br>$$<br>$$<br>a_4&#x3D;q\circ p^{-1}\circ q^{-1}<br>$$<br>$$<br>a_5&#x3D;q\circ p^{-1}\circ q^{-1}\circ p\circ q^{-1}<br>$$<br>$$<br>a_6&#x3D;q\circ p^{-1}\circ q^{-1}\circ p\circ p\circ q^{-1}<br>$$<br>$$<br>a_7&#x3D;q\circ p^{-1}\circ q^{-1}\circ p\circ p\circ p^{-1}\circ q\circ p\circ q^{-1}<br>$$<br>$$<br>a_8&#x3D;q\circ p^{-1}\circ q^{-1}\circ p\circ q\circ p^{-1}\circ q\circ p\circ q^{-1}<br>\dots<br>$$</p>
<p>记 $C&#x3D;q\circ p^{-1}\circ q^{-1}\circ p$，通过大眼观察法可得 $a_i&#x3D;C\circ a_{i-6}\circ C^{-1}$</p>
<p>可以用快速幂解决，时间复杂度 $\mathcal O(n\log k)$</p>
<ul>
<li>E</li>
</ul>
<p>数据范围非常网络流（</p>
<p>考虑枚举偷珠宝的个数 $k$，然后分开考虑两个维度</p>
<p>把偷走的珠宝按坐标大小排序</p>
<p>那么坐标 $\le a$ 的最多偷 $b$ 颗 $\Leftrightarrow$ 后 $k-b$ 个坐标 $&gt;a$，坐标 $\ge a$ 的最多偷 $b$ 颗 $\Leftrightarrow$ 前 $k-b$ 个坐标 $&lt;a$</p>
<p>那么第 $i$ 个偷走的珠宝就有了坐标的上下界 $[L_i,R_i]$</p>
<p>于是按匹配的套路连边跑最大费用最大流即可</p>
<p>由于 $L_i,R_i$ 都单调增，所以任意符合条件的匹配都可以重新匹配成升序的形式，所以直接匹配是正确的</p>
<p>网络流题不需要复杂度（</p>
<ul>
<li>F</li>
</ul>
<p>把路径倒过来考虑，那么状态 $(u,x)$ 经过一条边 $(u,v,w)$ 之后会变成 $(v,2x+w)$</p>
<p>考虑有哪些状态是等价的</p>
<p>对于一条边 $(u,v,w)$，在这条边上走两次可以得到 $(u,x)\to (v,2x+w)\to (u,4x+3w)$，那么 $(u,x)$ 与 $(u,4x+3w)$ 等价，同样走多次可以得到 $(u,x)$ 与 $(u,2^{2k}x+(2^{2k}-1)w)$ 和 $(v,2^{2k+1}x+(2^{2k+1}-1)w)$ 等价</p>
<p>对于两条边 $(u,v_1,w_1)$ 和 $(u,v_2,w_2)$，可得 $(u,x)$，$(u,4x+3w_1)$，$(u,4x+3w_2)$ 等价</p>
<p>由于 $\gcd(4,p)&#x3D;1$，所以 $4x$ 可以取遍 $[0,p)$ 中的任意整数，也就是说 $(u,x)$ 与 $(u,x+3(w_1-w_2))$ 等价</p>
<p>记 $g&#x3D;\gcd(p,|w_1-w_i|)$，由于图连通，所以 $(u,x)$ 与 $(u,x+3g)$ 等价</p>
<p>记 $q&#x3D;\gcd(3g,p)$（显然 $q&#x3D;g$ 或 $q&#x3D;3g$）则 $(u,x)$ 与 $(u,y)$ 等价当且仅当 $x\equiv y\pmod q$</p>
<p>由于所有边的边权在 $\bmod g$ 意义下同余，记余数为 $z$</p>
<p>显然带个余数计算不方便，我们就把所有边的边权减去 $z$，所有状态中的 $x$ 加上 $z$，这样 $(u,x’&#x3D;x+z)$ 经过 $(u,v,w’&#x3D;w-z)$ 后会变为 $(v,2x’+w’&#x3D;2x+w+z&#x3D;(2x+w)’)$</p>
<p>此时我们不难发现 $(u,x)$ 与 $(u,4x)$ 等价（$(u,x)\to(v,2x+w)\to(u,4x+3w)\Leftrightarrow (u,4x)$）</p>
<p>设 $x&#x3D;2^s X+tg$，那么显然只用考虑 $s&#x3D;0,1$，$t&#x3D;0,1,2$ 的情况，一共 $6n$ 个状态</p>
<p>于是可以用并查集维护这 $6n$ 个状态的等价性</p>
<p>考虑一组询问 $(u,v,r)$，存在这样的路径需要存在 $s,t$ 使得 $(v,z)\Leftrightarrow (u,2^sz+tg)$，且 $(u,2^sz+tg)\Leftrightarrow (u,r+z)$</p>
<p>枚举 $s,t$ 之后前面的可以在并查集上查询，后者可以化成 $2^{s+2k_1}z+(t+3k_2)g\equiv r+z\pmod q\Leftrightarrow 2^{s+2k_1}\equiv r+z-tg\pmod q$</p>
<p>预处理一下 $2$ 的幂次即可</p>
<p>时间复杂度 $\mathcal O(p+n\alpha(n))$</p>
<h3 id="AGC032"><a href="#AGC032" class="headerlink" title="AGC032"></a>AGC032</h3><ul>
<li>A</li>
</ul>
<p>显然每次插入一个 $i$ 都是序列中最后一个没被插入的 $i$</p>
<p>于是我们考虑从后往前看这个序列，如果在这个数 $a_i$ 之前有 $a_i-1$ 个数已经被插入序列中了，那么就把这个数放进去</p>
<p>时间复杂度 $\mathcal O(n^2)$</p>
<ul>
<li>B</li>
</ul>
<p><del>vp 不会 A，然后把 B 给秒了（</del></p>
<p>首先先把每条能连的边连上，那么与 $i$ 号点相连的点的编号和为 $\frac{n(n+1)}2-i$</p>
<p>如果 $n$ 是奇数，那么断掉 $i\to n-i$ 这条边，那么每个点的和都为 $\frac{n(n+1)}2-n$，满足条件</p>
<p>如果 $n$ 是偶数，那么断掉 $i\to n-i+1$ 这条边，那么每个点的和都为 $\frac{n(n+1)}2-n-1$，满足条件</p>
<p>时间复杂度 $\mathcal O(n^2)$</p>
<ul>
<li>C</li>
</ul>
<p>显然如果有解那么一定存在欧拉回路，也就是所有点的度数都为偶数</p>
<p>vp 时候的错误做法：</p>
<p>把欧拉路构造出来然后进行类似括号匹配的操作，遇到前面有的值就取出来构成一个环</p>
<p>最后取出来的环数 $\ge 3$ 则有解</p>
<p>hack 数据：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">6 9</span><br><span class="line">1 2</span><br><span class="line">2 3</span><br><span class="line">3 4</span><br><span class="line">4 5</span><br><span class="line">5 6</span><br><span class="line">6 1</span><br><span class="line">1 3</span><br><span class="line">3 5</span><br><span class="line">5 1</span><br></pre></td></tr></table></figure>

<p>构造出来的回路为 <code>1234561351</code>，这个算法只能取出两个回路：<code>1234561</code> 和 <code>1351</code>，实际上存在三个回路：<code>1231</code>，<code>3453</code> 和 <code>5615</code></p>
<p>正确做法：</p>
<p>对度数进行分类讨论</p>
<p>如果存在一个点度数 $\ge 6$，那么一定有解</p>
<p>如果所有点度数 $&#x3D; 2$ 或者只存在一个点度数 $&#x3D;4$ 其他都 $&#x3D;2$ 则无解</p>
<p>如果存在至少三个点度数 $&#x3D;4$ 则一定有解</p>
<p>如果恰好存在两个点度数 $&#x3D;4$，有两种情况：</p>
<p>记这两个点为 $u,v$，如果 $u,v$ 分别挂了两个环，$u\to v\to u$ 本身形成一个环则有解，如果 $u\to v$ 有四条不同的简单路径则无解</p>
<p>时间复杂度 $\mathcal O(n)$</p>
<ul>
<li>D</li>
</ul>
<p>显然每个数最多只会被操作一次，且没被操作的数为原序列的上升子序列</p>
<p>设 $f_i$ 为 $i$ 不操作的最小代价</p>
<p>对于 $j&lt;i$ 如果 $a_j&gt;a_i$ 则需要把它右移，否则需要把它左移</p>
<p>时间复杂度 $\mathcal O(n^2)$</p>
<ul>
<li>E</li>
</ul>
<p>结论：对原序列排序，存在一个断点，左边最小和最大匹配并且都 $&lt;M$，右边最小和最大匹配并且都 $\ge M$</p>
<p>证明可以枚举每一种情况，根据 $x+y-M&lt;x,x+y-M&lt;y$ 和原序列单调递增可以证明这是最优的</p>
<p>那么显然要让断点越靠左越好，于是二分这个断点位置即可</p>
<p>时间复杂度 $\mathcal O(n\log n)$</p>
<ul>
<li>F</li>
</ul>
<p>引理：</p>
<blockquote>
<p>在 $[0,1]$ 的线段上随机撒 $n-1$ 个点把线段分成 $n$ 段，这 $n$ 条线段中最短的长度期望为 $\frac 1{n^2}$</p>
</blockquote>
<p>证明：</p>
<p>根据 $E(\min)&#x3D;\int_{0}^{\frac 1n} P(\min\ge x)\mathrm dx$ 可以转化为求最小值 $\ge x$ 的概率</p>
<p>由于每条线段都要 $\ge x$，那么不妨把这些线段的长度全部减去 $x$</p>
<p>那么就变成了在长度为 $[0,1]$ 的线段上随机撒 $n-1$ 个点，这 $n-1$ 个点都要在 $[0,1-nx]$ 上的概率，即为 $(1-nx)^{n-1}$</p>
<p>于是 $E(\min)&#x3D;\int_{0}^{\frac 1n} (1-nx)^{n-1}\mathrm dx&#x3D;-\frac 1n\int_0^{\frac 1n}(1-nx)^{n-1}\mathrm d(1-nx)&#x3D;\frac 1{n^2}$</p>
<p>（中间的变换：$-\frac 1n\mathrm d(1-nx)&#x3D;-\frac 1n\cdot (-n)\mathrm dx&#x3D;\mathrm dx$）</p>
<p>推论：</p>
<blockquote>
<p>在 $[0,1]$ 的线段上随机撒 $n-1$ 个点把线段分成 $n$ 段，这 $n$ 条线段中第 $k$ 短的长度期望为 $\frac 1n\sum\limits_{1\le i\le k}\frac 1{n-i+1}$</p>
</blockquote>
<p>证明：</p>
<p>考虑次短长度的期望，即相当于最短值的期望加上所有线段减去最短线段之后的最短线段的期望</p>
<p>也就是 $E(\min_2)&#x3D;\frac{1-nE(\min)}{(n-1)^2}+E(\min)&#x3D;\frac{1}{n(n-1)}+\frac{1}{n^2}&#x3D;\frac1n(\frac 1n+\frac1{n+1})$</p>
<p>归纳即可得证</p>
<p>然后对题目做一步转化，以第一条线段的极角为 $0$，把 $[0,\frac 23\pi)$ 的线段染成红色，$[\frac 23\pi,\frac 43\pi)$ 的线段染成绿色，$[\frac 43\pi,2\pi)$ 的线段染成蓝色，然后把所有的线段极角对 $\frac 23\pi$ 取模</p>
<p>对于两条异色线段成的角度，不难发现已经把 $\frac 23\pi$（周长&#x2F;面积来说是 $\frac 13$）减掉了</p>
<p>对于两条同色直线，不难发现选择它们一定不会是最优答案</p>
<p>于是题目就转化成了在 $[0,\frac 13]$ 的线段上随机撒 $n-1$ 个点，把这 $n-1$ 个点随机染成红绿蓝中的一种，$0$ 处染红色，$\frac 13$ 处染绿色，求异色段的最小值期望</p>
<p>显然钦定 $k$ 段同色的概率为 $P(k)&#x3D;[k&lt;n]\frac 1{3^k}$，那么恰好 $k$ 段同色的概率即为 $P(k)-P(k+1)$</p>
<p>考虑枚举最小的异色段在所有线段中的排名 $i$，外加上之前的推论可以算出最终的期望：</p>
<p>$$<br>\begin{aligned}<br>E(n)&amp;&#x3D;\frac1{3n}\sum_{i&#x3D;1}^n (\frac{1}{3^{i-1}}-[i&lt;n]\frac{1}{3^i})\sum_{j&#x3D;1}^i\frac 1{n-j+1}\cr<br>&amp;&#x3D;\frac1{3n}\sum_{j&#x3D;1}^n\frac 1{n-j+1}\sum_{i&#x3D;j}^{n} (\frac{1}{3^{i-1}}-[i&lt;n]\frac{1}{3^i})\cr<br>&amp;&#x3D;\frac1{3n}\sum_{j&#x3D;1}^n\frac 1{n-j+1}\frac{1}{3^{j-1}}\cr<br>&amp;&#x3D;\sum_{i&#x3D;1}^n\frac 1{3^in(n-i+1)}<br>\end{aligned}<br>$$</p>
<p>时间复杂度 $\mathcal O(n\log n)$（瓶颈在快速幂）</p>
<h3 id="AGC033"><a href="#AGC033" class="headerlink" title="AGC033"></a>AGC033</h3><ul>
<li>A</li>
</ul>
<p>多源最短路，bfs 解决，复杂度 $\mathcal O(nm)$</p>
<ul>
<li>B</li>
</ul>
<p>显然两个维度互不影响，可以分开考虑</p>
<p>维护 $[l_i,r_i]$ 表示第 $i$ 步棋子在 $[l_i,r_i]$ 可以让棋子留在棋盘上</p>
<p>于是倒序维护即可，复杂度 $\mathcal O(n)$</p>
<ul>
<li>C</li>
</ul>
<p>如果选择非叶子可以使直径长度 $-2$，选择叶子可以使直径长度 $-1$</p>
<p>所以只用考虑直径长度，显然直径长度 $\equiv 2\pmod 3$ 时先手必败</p>
<p>时间复杂度 $\mathcal O(n)$</p>
<ul>
<li>D</li>
</ul>
<p>根据题意可以模拟一个 dp 出来：</p>
<p>设 $f_{l,r,d,u}$ 为 $[l,r]\times[d,u]$ 这个矩形的凌乱度，然后按题意模拟转移</p>
<p>但这样时间复杂度 $\mathcal O(n^5)$，空间复杂度 $\mathcal O(n^4)$，都不可以接受</p>
<p>注意到凌乱度是最多 $2\log n$，考虑交换一下 dp 的值和其中的一个维度</p>
<p>设 $f_{l,r,d,k}$ 为以 $(l,d)$ 为左上角，$r$ 为下边界，凌乱度为 $k$ 最大能向右扩展到哪里</p>
<p>竖着切可以直接转移，横着切显然满足决策单调性（单调增函数和单调减函数求 $\min$）</p>
<p>这样时间和空间复杂度都优化到了 $\mathcal O(n^3\log n)$</p>
<ul>
<li>E</li>
</ul>
<p>我们不妨设 $s_1$ 为 <code>R</code>，先考虑 $s$ 中不存在 <code>B</code> 的情况</p>
<p>这时我们要求环上没有两个 <code>B</code> 连在一起</p>
<p>先转到链上做，设 $f_i$ 为 $i$ 段，没有两个 <code>B</code> 连在一起的方案数，显然有转移 $f_i&#x3D;f_{i-1}+f_{i-2}$</p>
<p>由于在环上，我们枚举第一段是 <code>R</code> 还是 <code>B</code></p>
<p>如果是 <code>R</code> 则其他随便选，有 $f_{n-1}$ 种方案；如果是 <code>B</code> 则两边一定是 <code>R</code>，有 $f_{n-3}$ 种方案</p>
<p>注意特判 $n&#x3D;2$ 的情况</p>
<p>接下来考虑存在 <code>B</code> 的情况</p>
<p>这时仍然要求环上没有两个 <code>B</code> 连在一起，除此以外还有一些其他的限制</p>
<p>我们把环上每一个 <code>BRRRRRRR...</code> 作为一段，显然段长只有为偶数的时候才会合法（否则一定存在两个位置，其中之一离两边的 <code>B</code> 距离都是偶数，另一个离两边的 <code>B</code> 距离都是奇数）</p>
<p>记 $s_i$ 中的每一个极长连续 <code>R</code> 段长度为 $l_i$，那么对于 $i&gt;1$，如果 $l_i$ 为偶数，那么可以不用管，如果 $l_i$ 为奇数，则要求环上连续 <code>R</code> 段长度 $\le l_i$</p>
<p>对于 $i&#x3D;1$，则要求环上连续 <code>R</code> 段长度 $\le l_i+1$</p>
<p>这样就可以算出 <code>R</code> 在环上最多连续的个数，就可以直接用前缀和维护 dp 了</p>
<p>由于是在环上，所以可以枚举第 1 个位置所在的环上一段的长度 $L$，贡献系数乘上 $L$ 即可</p>
<p>时间复杂度 $\mathcal O(n)$</p>
<ul>
<li>F</li>
</ul>
<p>记原图为 $G_0$，操作后的图为 $G$</p>
<p>考虑 $(a,b,c)$ 一定在树上顺序出现时怎么做</p>
<p>结论：$u,v$ 之间有边当且仅当 $G_0$ 中存在一条路径 $u\to p_1\to\dots\to p_k\to v$，使得 $u,p_1,\dots,p_k,v$ 在树上顺序出现</p>
<p>这样我们对于每个点 $u$ 可以它为根 dfs 统计有多少个 $v$ 和 $u$ 有连边</p>
<p>考虑如何把 $G_0$ 中三元组 $(a,b,c)$ 转化成在树上顺序出现</p>
<p>结论：如果 $a,b,c$ 在树上顺序出现，且 $(a,b),(a,c)$ 在 $G_0$ 中出现，那么可以去掉 $(a,c)$ 加入 $(b,c)$ 使得答案不变</p>
<p>于是考虑一条一条加入 $G_0$ 中的边 $(u,v)$，并维护 $f_{u,v}$ 表示以 $u$ 为树根时 $u$ 和 $v$ 有连边的最近祖先的编号</p>
<p>根据 $f_{u,v}$ 和 $f_{v,u}$ 分类讨论：</p>
<ol>
<li>$f_{u,v}&#x3D;v$，$f_{v,u}&#x3D;u$（这两个式子一定同时成立）时，这条边已经存在就不用加进去了</li>
<li>$f_{u,v}$ 存在且不为 $v$ 时，根据上述结论可以转化为加入 $(f_{u,v},v)$ 这条边</li>
<li>$f_{v,u}$ 存在且不为 $u$ 时，同理可转化为加入 $(f_{v,u},u)$ 这条边</li>
<li>$f_{u,v}$ 和 $f_{v,u}$ 均不存在时，先加入 $(u,v)$ 这条边，也就是令 $f_{u,v}&#x3D;v,f_{v,u}&#x3D;u$，然后要对以 $u$ 为树根时 $v$ 的子树进行修改：如果遇到一个节点 $p$，有 $f_{u,p}$ 不存在时，令 $f_{u,p}&#x3D;v$，否则转化为加入 $(v,p)$ 这条边，并且 $p$ 的子树就不用修改了（更新以 $v$ 为树根时 $u$ 的子树同理）</li>
</ol>
<p>最后对于每个点 $u$ 用一遍 dfs 统计有多少个 $v$ 和 $u$ 有连边就行了</p>
<p>时间复杂度 $\mathcal O(n^2)$</p>
<h3 id="AGC034"><a href="#AGC034" class="headerlink" title="AGC034"></a>AGC034</h3><ul>
<li>A</li>
</ul>
<p>有连续两个障碍就不能越过，先判掉</p>
<p>如果 $c&lt;d$ 一定可以，$c&gt;d$ 判断一下 $[b,d]$ 之间有没有 <code>...</code> 可以让两个棋子交换位置</p>
<p>时间复杂度 $\mathcal O(n)$</p>
<ul>
<li>B</li>
</ul>
<p><code>BC</code> 的相对位置不变，倒序看每个 <code>A</code> 能操作几次即可</p>
<p>时间复杂度 $\mathcal O(n)$</p>
<ul>
<li>C</li>
</ul>
<p>考虑二分答案，转化为判定一个 $x$ 能不能符合条件</p>
<p>显然当 $a_i\le b_i$ 的时候系数选 $l_i$，否则选 $r_i$</p>
<p>于是构造函数：</p>
<p>$$<br>f_i(x)&#x3D;\begin{cases}l_ix&amp;(x\in[0,b_i])\cr l_ib_i+r_i(x-b_i)&amp;(x\in(b_i,X])\end{cases}<br>$$</p>
<p>那么如果可以构造 $\sum x_i&#x3D;x$，使得 $\sum f_i(x_i)\ge \sum l_ib_i$ 就可以满足条件</p>
<p>不难发现 $\sum f_i(x_i)$ 最大时最多只有一个 $x_i$ 不为 $0 $ 且没有取到 $X$，于是枚举这个位置，剩下的贪心取即可</p>
<p>时间复杂度 $\mathcal O(n\log \sum b)$</p>
<ul>
<li>D</li>
</ul>
<p>有一个显然的暴力做法：建一个完全二分图跑最大费用流</p>
<p>但是边数是 $\mathcal O(n^2)$ 的，显然不能接受</p>
<p>对于 $(x_1,y_1),(x_2,y_2)$ 两个点之间的曼哈顿距离 $|x_1-x_2|+|y_1-y_2|$，可以拆成 $\max{x_1+y_1-x_2-y_2,x_1-y_1-x_2+y_2,-x_1+y_1+x_2-y_2,-x_1-y_1+x_2+y_2}$</p>
<p>于是可以建四个中间节点表示这四个状态，然后每个点向这四个点连对应权值的边即可</p>
<p>这样边数就降到 $\mathcal O(n)$ 了</p>
<ul>
<li>E</li>
</ul>
<p><del>赛后 5min 调出来的（</del></p>
<p>考虑枚举最后所有棋子在哪个起点上，然后以这个点为根进行 dp</p>
<p>设 $sz_u$ 为 $u$ 子树中棋子个数，$g_u$ 为 $u$ 中棋子离 $u$ 的距离和，$f_u$ 为 $u$ 中操作后棋子离 $u$ 的最小距离和</p>
<p>$sz$ 和 $g$ 都容易计算，考虑如何计算 $f$，记 $sum&#x3D;\sum\limits_{v\in son(u)} g_v$</p>
<p>显然如果 $2\nmid sum$ 则 $f_u$ 至少为 1，可以先加上去，然后把 $g_v$ 中最大的减去 1</p>
<p>如果 $\max{g_v}\le \frac {sum}2$，那么 $f_u$ 不变</p>
<p>如果 $\max{g_v}&gt;\frac{sum}2$，那么如果可以通过把 $g_v$ 调整为 $f_v$ 的方式使得它 $\le \frac{sum}2$ 则 $f_u$ 不变，否则把 $g_v$ 调整成 $f_v$，然后 $f_u $ 要加上 $2f_v-sum$</p>
<p>时间复杂度 $\mathcal O(n)$</p>
<ul>
<li>F</li>
</ul>
<p>科技题（</p>
<p>记 $f_i$ 为数字为 $i$ 的期望步数，$p_i$ 表示选 $i$ 做操作的概率，则有转移：</p>
<p>$$<br>f_i&#x3D;\begin{cases}0&amp;(i&#x3D;0)\cr1+\sum f_{i\operatorname{xor}j}p_j&amp;(i&gt;0)\end{cases}<br>$$</p>
<p>记 $f_i$ 的集合幂级数为 $F(x)$，$p_i$ 的集合幂级数为 $P(x)$，$1$ 的集合幂级数为 $\epsilon(x)$</p>
<p>则有 $F(x)&#x3D;\epsilon(x)+F(x)P(x)+c$，其中 $c$ 为常数，多项式乘法定义为 $\operatorname{xor}$ 卷积</p>
<p>带入 $x&#x3D;1$ 可得 $c&#x3D;-\epsilon(1)&#x3D;-2^n$（$P(x)$ 的各项系数和为 $1$）</p>
<p>移一下项可得 $F(x)&#x3D;\frac{\epsilon(x)+c}{1-P(x)}$，由于是 $\operatorname{xor}$ 卷积，所以可以直接 FWT 后点值相除</p>
<p>但是这样的常数项还是有问题的，$\operatorname{FWT}(1-P(x))_0&#x3D;0$，直接求逆元会导致 $[x^0]F(x)$ 出问题</p>
<p>设当前 $[x^0]F(x)&#x3D;d$，则希望把这项的 $d$ 给减掉，在 FWT 之后就相当于所有项把 $d$ 给减掉</p>
<p>时间复杂度 $\mathcal O(n2^n)$</p>
<h3 id="AGC035"><a href="#AGC035" class="headerlink" title="AGC035"></a>AGC035</h3><ul>
<li>A</li>
</ul>
<p>以下下标均对 $n$ 取模</p>
<p>$x_{i-1}\operatorname{xor}x_{i}\operatorname{xor}x_{i+1}&#x3D;0,x_{i}\operatorname{xor}x_{i+1}\operatorname{xor}x_{i+2}&#x3D;0\Rightarrow x_{i-1}&#x3D;x_{i+2}$</p>
<p>考虑对 $n\bmod 3$ 分类讨论</p>
<ol>
<li>$n\not\equiv 0\pmod 3$ 时，显然要求 $a_i$ 全部相等</li>
<li>$n\equiv 0\pmod 3$ 时，要求 $a_i$ 全部相等或者一个值有 $\frac {2n}3$ 个另一个值是 $0$ 且有 $\frac n3$ 个或者每个值有 $\frac n3$ 个且异或和为 $0$</li>
</ol>
<p>时间复杂度 $\mathcal O(n\log n)$（用 map 维护）</p>
<ul>
<li>B</li>
</ul>
<p>显然 $m$ 为奇数时无解，考虑构造 $m$ 为偶数时的解</p>
<p>先任意把边定向，把出度为奇数的点拿出来，并两两配对</p>
<p>对于一对点 $(u,v)$，我们希望把一条 $u\to v$ 的路径方向全部取反，这样中间经过的节点的奇偶性不会被影响，$u$ 和 $v$ 由奇数变为偶数</p>
<p>于是随便从原图中取一个生成树然后树上差分即可</p>
<p>时间复杂度 $\mathcal O(n\log n)$</p>
<ul>
<li>C</li>
</ul>
<p>赛后 1min 过题.jpg</p>
<p>考场上极其麻烦的做法：</p>
<p>$n$ 为奇数时，我们把 $(1,2i,2i+1)$ 分为一组，构造成类似菊花图的样子即可</p>
<p>$n&#x3D;2^k$ 时显然无解</p>
<p>其他情况，我们把 $(n,n-1,n\operatorname{xor}(n-1)),(n,n-2,n\operatorname{xor}(n-2))$ 分为一组，其他的按照 $(1,2i,2i+1)$ 分组，构造成两个菊花图然后加 $1\to n$ 这条边就行了，但还有一个 $n&#x3D;6$ 要处理</p>
<p>$n&#x3D;6$ 时，在 $n&#x3D;5$ 的基础上增加一条 $6\to 2\to 1\to 5\to 6$ 的路径即可</p>
<p>时间复杂度 $\mathcal O(n)$</p>
<p>简单做法：</p>
<p>$n$ 为奇数和上面一样</p>
<p>$n$ 为偶数时，考虑在 $n-1$ 的基础上把 $n$ 加进去</p>
<p>发现 $n\to \operatorname{lowbit}(n)\to 1\to n-\operatorname{lowbit}(n)+1\to n$ 符合条件</p>
<p>时间复杂度 $\mathcal O(n)$</p>
<ul>
<li>D</li>
</ul>
<p>正着做不好做，考虑把这个过程倒过来，变成在一个序列中加入一张牌</p>
<p>考虑当前 $l,r$ 号牌已经被加入了，$l$ 的贡献系数为 $x$，$r$ 的贡献系数为 $y$，则在 $(l,r)$ 中加入一张牌的贡献系数就为 $x+y$，看着像一个区间 dp 的形式</p>
<p>设 $f_{l,r,x,y}$ 为 $l,r$ 号牌已经被加入了，$l$ 的贡献系数为 $x$，$r$ 的贡献系数为 $y$ 的最小代价</p>
<p>则 $f_{l,r,x,y}&#x3D;\min{f_{l,k,x,x+y}+f_{k,r,x+y,y}+(x+y)a_k}$，边界 $f_{l,l+1,x,y}&#x3D;0$</p>
<p>答案即为 $f_{1,n,1,1}$</p>
<p>状态数有 $\mathcal O(n^22^n)$ 个（实际上好像是 $\mathcal O(2^n)$ 个，但我不会证）</p>
<p>直接 dfs 的话会发现每次 dfs 到的节点都不会重复，所以直接 dfs 做这个 dp 即可</p>
<ul>
<li>E</li>
</ul>
<p>原题目就相当于问有多少个不同的被删的数的集合</p>
<p>显然要删除 $x$ 就要在删 $x$ 之前删除 $x+2$ 和 $x-k$，考虑把图建出来，一个删数集合合法等价于点集在图上不成环</p>
<p>$k$ 为偶数时，原图可以分成奇数和偶数两个连通块，每个连通块相当于一条链，每个点有一个长 $\frac k2$ 的返祖边，一个点集合法也就等价于在一条链上没有连续 $\frac k2+1$ 个点被选进点集中，随便 dp 一下即可</p>
<p>$k$ 为奇数时，原图可以分为奇数和偶数两条链，中间有一些 $x\to x+k$ 的边</p>
<p>考虑把一个奇数 $x$ 和偶数 $x+k$ 放到一层里，一个点集合法等价于不存在一个奇数 $x$ 选了一个长度超过 $k+1$ 的路径并且终点在偶数链上</p>
<p>逐层 dp，设 $f_{i,j,k}$ 为前 $i$ 层，$i$ 之前跨越两条链的路径长度为 $j$，偶数链连续选了 $k$ 个节点的方案数</p>
<p>枚举当前层怎么选即可，时间复杂度 $\mathcal O(n^3)$</p>
<ul>
<li>F</li>
</ul>
<p>关键性质：两个操作序列等价当且仅当存在一个操作序列中 $k_i&#x3D;j$，$l_j&#x3D;i-1$，另一个中 $k_i&#x3D;j-1$，$l_j&#x3D;i$</p>
<p>规定存在 $k_i&#x3D;j-1$，$l_j&#x3D;i$ 的操作序列是不合法的，接下来就是二项式反演的板子了（</p>
<p>设 $f_i$ 为钦定 $i$ 对不合法的方案数，有 $f_i&#x3D;\binom ni\binom mii!(m+1)^{n-i}(n+1)^{m-i}$</p>
<p>设 $g_i$ 为恰好 $i$ 对不合法的方案数，有 $f_i&#x3D;\sum\limits_{j\ge i} \binom ijg_j$</p>
<p>二项式反演一下，得到 $g_i&#x3D;\sum\limits_{j\ge i}(-1)^{j-i}\binom ij f_j$</p>
<p>答案即为 $g_0&#x3D;\sum(-1)^if_i&#x3D;\sum(-1)^i\binom ni\binom mii!(m+1)^{n-i}(n+1)^{m-i}$</p>
<p>时间复杂度 $\mathcal O(n)$</p>
<h3 id="AGC036"><a href="#AGC036" class="headerlink" title="AGC036"></a>AGC036</h3><ul>
<li>A</li>
</ul>
<p>把 $(x_1,y_1)$ 放在原点上，然后用叉积算面积构造一个即可（</p>
<ul>
<li>B</li>
</ul>
<p>记 $nxt_i$ 为如果序列中只有 $x_i$，下一次出现序列中只有一个数的位置</p>
<p>连 $i\to nxt_i$ 的边，如果跨过 $n$ 则边权为 1，否则边权为 0</p>
<p>于是找到 0 所在的环的环长，然后 $k$ 对它取模，后面可以直接暴力跳</p>
<p>时间复杂度 $\mathcal O(n)$</p>
<ul>
<li>C</li>
</ul>
<p>结论：原题等价于求不定方程 $x_1+x_2+\dots+x_n&#x3D;3m$，$0\le x_i\le 2m$ 且 $x_i$ 中奇数的个数的奇偶性和 $m$ 的奇偶性相同的解的个数</p>
<p>可以枚举奇数的个数然后用容斥+插板法做</p>
<p>注意到 $[0,2m]$ 中偶数比奇数多一个，所以可以按存不存在 $x_i&#x3D;2m$ 分类然后做</p>
<p>时间复杂度 $\mathcal O(n)$</p>
<ul>
<li>D</li>
</ul>
<p>神仙题（</p>
<p>一个有向图不存在负环等价于差分约束条件下有解</p>
<p>记 $q_i&#x3D;x_i-x_{i+1}$，因为有 $i\to i+1$ 边权为 $0$ 的边，所以有 $x_i\ge x_{i+1}\Leftrightarrow q_i\ge 0$</p>
<p>对于 $i&lt;j$，$i\to j$ 边权为 $-1$ 的边，如果要保留下来就要求 $x_i-1\ge x_j\Leftrightarrow \sum\limits_{i\le k&lt;j}q_k\ge 1$</p>
<p>对于 $i&gt;j$，$i\to j$ 边权为 $1$ 的边，如果要保留下来就要求 $x_i+1\ge x_j\Leftrightarrow \sum\limits_{j\le k&lt;i}q_k\le 1$</p>
<p>显然取 $q_i\ge 2$ 不会使答案变得更优，所以取 $q_i\in{0,1}$</p>
<p>设 $f_{i,j}$ 为取 $q_i&#x3D;1,q_j&#x3D;1$ 的最小代价，转移的时候枚举前一个 $1$ 在哪即可</p>
<p>时间复杂度 $\mathcal O(n^3)$</p>
<ul>
<li>E</li>
</ul>
<p>首先把连续一样的字母删掉，记 <code>A</code> 出现了 $c_A$ 次，<code>B</code> 出现了 $c_B$ 次，<code>C</code> 出现了 $c_C$ 次，不妨设 $c_A\le c_B\le c_C$</p>
<p>考虑先删 <code>C</code> 直到 $c_B&#x3D;c_C$ 为止</p>
<p>显然先删形如 <code>ACB</code> 或 <code>BCA</code> 或 <code>C</code> 在首尾的 <code>C</code> 最优，如果此时还有 $c_C&gt;c_B$ 则只能删 <code>AC</code> 或者 <code>CA</code></p>
<p>容易发现此时一定能删到 $c_C&#x3D;c_B$</p>
<p>接下来考虑删除 <code>BC</code> 或 <code>CB</code>，此时需要注意形如 <code>ACBA</code> 或者 <code>ABCA</code> 的 <code>BC</code> 是不能删的</p>
<p>容易发现此时一定能删到 $c_A&#x3D;c_B&#x3D;c_C$（每个 <code>B</code> 或 <code>C</code> 都至少对应一个 <code>A</code>）</p>
<p>时间复杂度 $\mathcal O(n)$</p>
<ul>
<li>F</li>
</ul>
<p>考虑每个位置上填的数都有什么限制</p>
<p>对于 $i$，要求 $\lceil\sqrt{n^2-i^2}\rceil\le p_i\le \lfloor\sqrt{4n^2-i^2}\rfloor$，记 $L_i&#x3D;\lceil\sqrt{n^2-i^2}\rceil-1,R_i&#x3D;\lfloor\sqrt{4n^2-i^2}\rfloor$，另外 $i&gt;n$ 时 $L_i&#x3D;-1$</p>
<p>即把要求转化为了 $L_i&lt;p_i\le R_i$</p>
<p>先弱化一下，考虑没有下界 $L_i$ 该怎么做</p>
<p>此时可以把 $R_i$ 从小到大排序一下，答案即为 $\prod R_i-i+1$</p>
<p>对于只有上界的情况有了一种快速的解法，考虑直接把下界给容斥掉，对于每个 $i$ 去计算钦定 $i$ 个数违反下界的方案数</p>
<p>先把这 $2n$ 个位置排序一下，$i&lt;n$ 时以 $L_i$ 为第一关键字，$R_i$ 为第二关键字排序，$i\ge n$ 时以 $R_i$ 为关键字排序</p>
<p>设 $f^{(k)}_{i,j}$ 表示考虑前 $i$ 个位置，钦定了 $j$ 个违反下界，一种钦定 $k$ 个违反下界的方案数</p>
<p>记当前位置是 $x$，接下来分类讨论：</p>
<ol>
<li>若 $x\ge n$，此时不存在下界，之前的 $j$ 个违反下界的位置的 $L$ 都必然比 $R_x$ 小，记之前有 $c$ 个位置 $\ge n$，则有转移 $f_{i,j}&#x3D;f_{i-1,j}(R_x-c-j+1)$</li>
<li>若 $x&lt;n$，且当前位置违反下界，之前 $j-1$ 个违反下界的位置的 $L$ 都必然比 $L_x$ 小，记之前有 $c$ 个位置 $\ge n$，则有转移 $f_{i,j}&#x3D;f_{i-1,j-1}(L_x-c-(j-1)+1)$</li>
<li>若 $x&lt;n$，且当前位置不违反下界，那么所有 $k$ 个违反下界的位置的 $L$ 都必然比 $R_x$ 小（$x&lt;n$ 时 $R_x&gt;\sqrt 3n$），记之前有 $c$ 个位置 $&lt;n$，则有转移 $f_{i,j}&#x3D;f_{i-1,j}(R_x-n-k-(c-j)+1)$</li>
</ol>
<p>最后答案即为 $\sum(-1)^if_{2n,i}^{(i)}$</p>
<p>时间复杂度 $\mathcal O(n^3)$</p>
<h3 id="AGC037"><a href="#AGC037" class="headerlink" title="AGC037"></a>AGC037</h3><ul>
<li>A</li>
</ul>
<p>维护前一段字符串和当前字符串，两个字符串不相等就分段</p>
<p>时间复杂度 $\mathcal O(n)$</p>
<ul>
<li>B</li>
</ul>
<p>贪心去选，最优方案一定是能作为第三个就作为第三个，能作为第二个就作为第二个，否则只能作为第一个</p>
<p>于是在贪心的过程中维护选择的方案数即可</p>
<p>时间复杂度 $\mathcal O(n)$</p>
<ul>
<li>C</li>
</ul>
<p>考虑倒着做，从 $b$ 变到 $a$，每次的操作是选择一个 $i$ 使 $b_i$ 变成 $b_i-b_{i-1}-b_{i+1}$</p>
<p>对于 $b$ 中的最大值 $b_i$，显然要操作 $i-1$ 或者 $i+1$ 需要先操作 $i$</p>
<p>于是直接把最大值操作到不能操作为止（还可以操作的话一定还不能操作 $i-1$ 和 $i+1$）</p>
<p>这样每个数操作一次至少会减半</p>
<p>时间复杂度 $\mathcal O(n\log n\log w)$，$w$ 为值域</p>
<ul>
<li>D</li>
</ul>
<p>记数字 $i$ 在 D 矩阵中在第 $r_i$ 行</p>
<p>于是 B 矩阵就是要求每一列中 $r$ 是个 $1\dots m$ 的排列</p>
<p>考虑建立一个二分图匹配模型，左边一列点表示 $r$，右边一列点表示每一行，求出这个二分图的 $m$ 个完美匹配即可</p>
<p>C 矩阵就把 B 中每一列按 $r$ 排个序即可</p>
<p>时间复杂度 $\mathcal O(n^3\sqrt n)$</p>
<ul>
<li>E</li>
</ul>
<p>不妨设字符串中最小的字符为 <code>a</code></p>
<p>于是可以通过一次操作来把一段 <code>a</code> 放到字符串的最后，之后就可以用一次操作把最后一段 <code>a</code> 的个数翻倍</p>
<p>我们肯定要选 <code>a</code> 的个数最多的一段，接下来考虑让 <code>a</code> 段后面的字典序最小</p>
<p>记最开始 <code>a</code> 段为 $A$，前面的一段为 $B$</p>
<p>不难发现最后的答案串为 $2^{k-1}$ 倍的 $A$ 和 $B^{R}$ 的一段前缀，于是目标就变为让 $B^R$ 的字典序最小</p>
<p>记 $s$ 为原字符串加上翻转字符串，由于 $BA$ 在 $s$ 中，所以 $A^RB^R&#x3D;AB^R$ 也在 $s$ 中</p>
<p>于是直接在 $s$ 里找一个字典序最小的长度为 $n$ 的字符串，把开头的 <code>a</code> 段个数乘上 $2^{k-1}$，剩下的取后面的一段前缀即可</p>
<p>时间复杂度 $\mathcal O(n^2)$</p>
<ul>
<li>F</li>
</ul>
<p>首先考虑如何判断一个序列是不是好的</p>
<ol>
<li>序列只有一个数，一定是好的</li>
<li>序列所有数相同，且长度 $\ge L$，一定是好的</li>
<li>记序列中最小数为 $x$，所有的连续的 $x$ 段的长度为 $len_i$，把每一段合并成 $\lfloor \frac{len_i}L\rfloor$ 个 $x+1$，继续判断</li>
</ol>
<p>每次合并需要 $O(L)$，序列长度减小 $L-1$，排序需要 $\mathcal O(n\log n)$，所以这个过程的复杂度为 $\mathcal O(n\log n)$</p>
<p>考虑把要求的东西加强一下，变成对于每个数有两个权值 $L_i$ 和 $R_i$，对于每个好的数列 $[i,j]$ 去求 $L_iR_j$ 的和</p>
<p>仍然用上面的步骤</p>
<ol>
<li>序列只有一个数，一定是好的</li>
<li>序列所有数相同，且长度 $\ge L$，一定是好的，这时可以 $\mathcal O(n)$ 求出答案</li>
<li>记序列中最小的数为 $x$，所有连续的 $x$ 段长度为 $len_i$，对于每一段按照 2 的方法求出答案，合并成 $\lfloor \frac{len_i}L\rfloor$ 个 $x+1$，求出这些 $x+1$ 的 $L$ 和 $R$，继续这些步骤</li>
</ol>
<p>现在的问题就是要在合并的时候更新 $L$ 和 $R$</p>
<p>不难发现每次已经求出了一个 $x$ 连续段内的答案，记这个连续段为 $[l,r]$，我们更新 $[l,r]$ 中的 $L_i$ 和 $R_i$ 的目的是要求在 $[l,r]$ 两边的 $x+1$ 段对 $[l,r]$ 中的 $x$ 产生的贡献，不妨考虑 $r$ 右边的 $x+1$ 段对 $[l,r]$ 中的 $x$ 的贡献（即更新 $L$）</p>
<p>记 $i$ 离 $r$ 的距离为 $q$，则 $L_i$ 应该贡献给合并后 $\lfloor \frac{len_i}L\rfloor-\lfloor\frac qL\rfloor$ 位置的 $L$（贡献 $\lfloor\frac qL\rfloor$ 个 $x+1$ 给后面的 $x+1$ 段）</p>
<p>注意在之后计算 $x+1$ 的时候会重复计算 $x$ 的答案，需要减掉，长度为 1 的序列直接在最开始答案加上 $n$ 即可</p>
<p>复杂度计算和之前一样，为 $\mathcal O(n\log n)$</p>
<p>注意特判 $L&#x3D;1$ 的情况，这时每次合并减少 $L-1&#x3D;0$ 个数，会一直合并下去</p>
<h3 id="AGC038"><a href="#AGC038" class="headerlink" title="AGC038"></a>AGC038</h3><ul>
<li>A</li>
</ul>
<p><del>日常卡 A（×</del></p>
<p>构造类似于</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">00011</span><br><span class="line">00011</span><br><span class="line">11100</span><br><span class="line">11100</span><br></pre></td></tr></table></figure>

<p>的矩阵即可，时间复杂度 $\mathcal O(n^2)$</p>
<ul>
<li>B</li>
</ul>
<p>如果一个区间 $[i,i+k-1]$ 中 $a_{i+k-1}$ 是最大值且 $a_{i-1}$ 是 $[i-1,i+k-2]$ 中的最小值，那么这个区间一定不用统计</p>
<p>最后加上可能排序之后不变的区间</p>
<p>时间复杂度 $\mathcal O(n\log n)$</p>
<ul>
<li>C</li>
</ul>
<p>莫反的板子？</p>
<p>记值域为 $w$</p>
<p>$$<br>\begin{aligned}<br>S(n,A)&amp;&#x3D;\frac 12(\sum_{i&#x3D;1}^n\sum_{j&#x3D;1}^n\frac{A_iA_j}{\gcd(A_i,A_j)}-\sum_{i&#x3D;1}^nA_i)\cr<br>&amp;&#x3D;\frac 12(\sum_{i&#x3D;1}^n\sum_{j&#x3D;1}^n\sum_{d|A_i,d|A_j}\frac{A_iA_j}{d[\gcd(A_i,A_j)&#x3D;d]}-\sum_{i&#x3D;1}^nA_i)\cr<br>&amp;&#x3D;\frac 12(\sum_{d&#x3D;1}^w\frac 1d\sum_{i&#x3D;1}^n\sum_{j&#x3D;1}^nA_iA_j[\gcd(A_i,A_j)&#x3D;d]-\sum_{i&#x3D;1}^nA_i)\cr<br>&amp;&#x3D;\frac 12(\sum_{d&#x3D;1}^w\frac 1d\sum_{i&#x3D;1}^n\sum_{j&#x3D;1}^nA_iA_j[d|A_i][d|A_j]\sum_{qd|A_i,qd|A_j}\mu(q)-\sum_{i&#x3D;1}^nA_i)\cr<br>&amp;&#x3D;\frac 12(\sum_{d&#x3D;1}^w\frac 1d\sum_{q&#x3D;1}^w\mu(q)\sum_{i&#x3D;1}^n\sum_{j&#x3D;1}^nA_iA_j[qd|A_i][qd|A_j]-\sum_{i&#x3D;1}^nA_i)<br>\end{aligned}<br>$$</p>
<p>记 $f(d)&#x3D;\sum_{i&#x3D;1}^nA_i[d|A_i]$，可以 $\mathcal O(n\ln w)$ 预处理，则</p>
<p>$$<br>\begin{aligned}<br>S(n,A)&amp;&#x3D;\frac 12(\sum_{d&#x3D;1}^w\frac 1d\sum_{q&#x3D;1}^w\mu(q)f^2(qd)-\sum_{i&#x3D;1}^nA_i)\cr<br>&amp;&#x3D;\frac 12(\sum_{t&#x3D;1}^wf^2(t)\sum_{d|t}\frac{\mu(\frac td)}{d}-\sum_{i&#x3D;1}^nA_i)<br>\end{aligned}<br>$$</p>
<p>记 $g(t)&#x3D;\sum_{d|t}\frac{\mu(\frac td)}d$，可以 $\mathcal O(n\ln w)$ 预处理，则</p>
<p>$$<br>S(n,A)&#x3D;\frac 12(\sum_{t&#x3D;1}^w f^2(t)g(t)-\sum_{i&#x3D;1}^n A_i)<br>$$</p>
<p>时间复杂度 $\mathcal O(n\ln w)$</p>
<ul>
<li>D</li>
</ul>
<p>先把 0 类边加入，形成若干连通块，每个连通块都是树</p>
<p>记连通块个数为 $k$</p>
<p>如果没有 1 类边，那么边数最少 $n-1$，最多 $n-k+\frac{k(k-1)}{2}$</p>
<p>如果有 1 类边，那么边数最少 $n$，最多 $n-k+\frac{k(k-1)}2$，同时判断一下 1 类边是否合法（连通两个不同的连通块），并且 $k&#x3D;2$ 时一定不合法</p>
<p>时间复杂度 $\mathcal O(n\alpha(n))$</p>
<ul>
<li>E</li>
</ul>
<p>设每个数第一次到达 $B_i$ 的时刻为 $t_i$，则题目实际上求的是 $E(\max{t_i})$，考虑进行 min-max 容斥</p>
<p>$$<br>\begin{aligned}<br>E(\max S)&amp;&#x3D;\sum_{T\in S,T\not &#x3D;\emptyset}(-1)^{|T|+1}E(\min T)\cr<br>&amp;&#x3D;\sum_{T\in S,T\not &#x3D;\emptyset}(-1)^{|T|+1}(\frac{\sum A}{s(T)}\sum P(c_T))\cr<br>&amp;&#x3D;\sum_{T\in S,T\not &#x3D;\emptyset}(-1)^{|T|+1}(\frac{\sum A}{s(T)}\sum_{k&#x3D;0}^{\sum(B-1)} \sum_{\sum_{i\in T} c_i&#x3D;k}\binom{k}{c_1c_2\dots c_{|T|}}\prod \frac{A_i^{c_i}}{s^{c_i}(T)})\cr<br>&amp;&#x3D;\sum_{T\in S,T\not &#x3D;\emptyset}(-1)^{|T|+1}(\sum_{k&#x3D;0}^{\sum(B-1)} \frac{(\sum A)k!}{s^{k+1}(T)}\sum_{\sum_{i\in T} c_i&#x3D;k}\prod \frac{A_i^{c_i}}{c_i!})<br>\end{aligned}<br>$$</p>
<p>思路为把期望变为每个状态出现的概率乘上期望持续时间</p>
<p>其中 $s(T)&#x3D;\sum_{i\in T}A_i$</p>
<p>这个式子可以用 dp 来维护，设 $f_{i,j,k}$ 为考虑到前 $i$ 个数，$s(T)&#x3D;j$，$\sum_{i\in T} c_i&#x3D;k$ 的贡献数</p>
<p>那么可以得出 $f_{i,j,k}&#x3D;f_{i-1,j,k}-\sum_{w&lt;B_i}f_{i-1,j-A_i,k-w}\frac{A_i^w}{w!}$，最后再乘上 $\frac{(\sum A)k!}{j^{k+1}}$ 的系数即可</p>
<p>注意到转移中 $w$ 的总枚举量为 $\sum B$，所以实际复杂度为 $\mathcal O(n^3)$</p>
<ul>
<li>F</li>
</ul>
<p>每个环是独立的，所以对于每一个环分开考虑</p>
<p>我们可以对 $A_i,B_i,P_i,Q_i$ 四个量的关系分类计算轮换 P 和轮换 Q 的代价</p>
<p>不难想到可以用最小割来解决这个问题</p>
<p>由于建出来的网络流图是二分图，所以时间复杂度 $\mathcal O(n\sqrt n)$</p>
<h3 id="AGC039"><a href="#AGC039" class="headerlink" title="AGC039"></a>AGC039</h3><ul>
<li>A</li>
</ul>
<p>出现两个连续的字母就把后面那个改掉，注意判断一下头尾是否相等</p>
<p>时间复杂度 $\mathcal O(n)$</p>
<ul>
<li>B</li>
</ul>
<p>不难发现有解的图一定是二分图</p>
<p>我们考虑贪心，枚举一个点 $u\in V_1$，从 $u$ 开始 bfs，bfs 深度为 $k$ 的放到 $V_k$ 里，这样一定是最优的</p>
<p>时间复杂度 $\mathcal O(nm)$</p>
<ul>
<li>C</li>
</ul>
<p>记 $x$ 取反为 $\bar x$</p>
<p>不难发现一个 $x$ 的答案为 $x\bar xx$ 最靠后的不为整个串的后缀且为 $x$ 的子串的位置</p>
<p>对于一个串 $x$，称满足 $y\bar yy\bar y\dots y&#x3D;x$ 的最短的 $y$ 为 $x$ 的周期，则答案为 $2|y|$</p>
<p>于是可以设 $f_i$ 为周期为 $i$ 的数的个数，可以 dp 求出 $f$</p>
<p>时间复杂度 $\mathcal O(nd(n))$（$d(n)$ 为 $n$ 的约数个数）</p>
<ul>
<li>D</li>
</ul>
<p>考虑求 $\triangle ABC$ 的内心 $I$ 的坐标</p>
<p>我们取 $\overset{\frown}{BC}$ 的中点为 $D$，$\overset{\frown}{CA}$ 的中点为 $E$，$\overset{\frown}{AB}$ 的中点为 $F$</p>
<p>可以证明 $I$ 为 $\triangle DEF$ 的垂心</p>
<p>记 $\triangle DEF$ 的重心为 $G$，则有 $\overset{\to} {OI}&#x3D;3\overset{\to}{OG}$</p>
<p>显然 $G$ 的坐标为 $(\frac{x_D+x_E+x_F}3,\frac{y_D+y_E+y_F}3)$，则 $I$ 的坐标为 $(x_D+x_E+x_F,y_D+y_E+y_F)$</p>
<p>于是枚举一段弧求出中点求出出现的次数即可</p>
<p>时间复杂度 $\mathcal O(n^2)$</p>
<ul>
<li>E</li>
</ul>
<p>考虑枚举和 $1$ 号点相连的点 $i$</p>
<p>记 $(1,i)$ 中向 $(i,2n)$ 连线的点为 ${p_1,p_2,\dots, p_k}$，其中 $p_1&lt;p_2&lt;\dots&lt;p_k$</p>
<p>记 $(i,2n)$ 中向 $(1,i)$ 连线的点为 ${q_1,q_2,\dots,q_k}$，其中 $q_1&gt;q_2&gt;\dots&gt;q_k$</p>
<p>则如果不成环一定要求 $p_1\to q_1,p_2\to q_2,\dots,p_k\to q_k$</p>
<p>那么记 $f_{l,r,i}$ 为 $[l,r]$ 中间的点，$i$ 向外界连边的方案数，那么答案为 $\sum f_{2,2n,i}$</p>
<p>则枚举 $p$ 为上文中的 $p_1$，$q$ 为 $q_1$，那么 $f_{l,r,i}\leftarrow f_{l,p,j}f_{q,r,k}f_{p+1,q-1,i}$</p>
<p>直接做时间复杂度 $\mathcal O(n^7)$，由于有 $\frac 1{7!}$ 的常数所以可以过</p>
<p>当然也可以优化到 $\mathcal O(n^5)$</p>
<ul>
<li>F</li>
</ul>
<p>记第 $i$ 行的最小值为 $x_i$，第 $j$ 行的最小值为 $y_i$</p>
<p>我们按每行&#x2F;列的权值加入一行一列，不妨设当前加入的是行，之前加入了 $k$ 列，那么它的贡献次数即为 $m-k$</p>
<p>因为每次加入的是最小值所以考虑容斥</p>
<p>设 $f_{t,i,j}$ 为加入了权值 $\le t$ 的行&#x2F;列已经确定的贡献，记之前的状态为 $g$，考虑转移：</p>
<ol>
<li>加入 $k$ 行 $\ge t$ 的数，则有 $f_{t,i,j}\leftarrow g_{i-k,j}\binom{n-i+k}kt^{k(m-j)}(K-t+1)^{kj}$（此时还有 $m-j$ 列的限制比 $t$ 更强，所以这里 $n-t+1$ 的次数为 $ij$）</li>
<li>加入 $k$ 列 $\ge t$ 的数，则有 $f_{t,i,j}\leftarrow g_{i,j-k}\binom{m-j+k}kt^{k(n-i)}(K-t+1)^{ki}$</li>
<li>加入 $k$ 行 $&gt;t$ 的数，则有 $f_{t,i,j}\leftarrow (-1)^kg_{i-k,j}\binom{n-i+k}kt^{k(m-j)}(K-t)^{kj}$</li>
<li>加入 $k$ 列 $&gt;t$ 的数，则有 $f_{t,i,j}\leftarrow (-1)^kg_{i,j-k}\binom{m-j+k}kt^{k(n-i)}(K-t)^{ki}$</li>
</ol>
<p>时间复杂度 $\mathcal O(kn^3)$，有点卡常，实现的时候尽量减少取模次数</p>
<h3 id="AGC040"><a href="#AGC040" class="headerlink" title="AGC040"></a>AGC040</h3><ul>
<li>A</li>
</ul>
<p>谷值取 $0$ 然后直接扫一遍即可，时间复杂度 $\mathcal O(n)$</p>
<ul>
<li>B</li>
</ul>
<p>我们不妨设 $r$ 最小的那个区间在第一个集合中</p>
<p>枚举第一个集合的 $l$ 然后把所有左端点 $\le l$ 的放入第一个集合（放入第二个集合一定不优）</p>
<p>当然全选的情况需要把最长的区间放入第二个集合</p>
<p>时间复杂度 $\mathcal O(n\log n)$</p>
<ul>
<li>C</li>
</ul>
<p><del>28min 做完 B 开始罚座（</del></p>
<p>发现任意删除一次剩下的数下标的奇偶性不会变，考虑把偶数位的 <code>A</code> 全部变成 <code>B</code>，<code>B</code> 全部变成 <code>A</code></p>
<p>这样不能删除的就是相邻两个全是 <code>A</code> 或 <code>B</code> 的情况了</p>
<p>显然 <code>A</code> 或 <code>B</code> 的个数超过 $\frac n2$ 时不合法，用总方案数减掉就好了</p>
<p>时间复杂度 $\mathcal O(n)$</p>
<ul>
<li>D</li>
</ul>
<p>我们把两个人的时间-位移（$x$ 轴为位移）图像画出来，不难发现答案就是把 Bob 的图像不断向下平移直到和 Alice 的图像不交时在 $x$ 轴上的截距，设为 $p$</p>
<p>枚举 $p$ 在哪个石板上，设为 $k$，记 $\sum a_i&#x3D;sa$</p>
<p>考虑这样一条路径：Bob 先沿自己的图像走，和 Alice 的图像相交之后就沿 Alice 的图像走，最终走到 $(n,sa)$</p>
<p>我们希望 $k$ 后面的石板数量尽可能少，那么就希望 $k$ 后面的图像增长速度尽可能快（斜率尽可能大）</p>
<p>发现一个石板在这条路径上的斜率最大为 $\max{a_i,b_i}$，不难想到按 $\max{a_i,b_i}$ 排序后选一个满足 $\sum \max{a_i,b_i}\ge sa-b_k$ 前缀</p>
<p>而这个最大值是可以在 $a_i&gt;b_i$ 的放在后面，$a_i&lt;b_i$ 的放在前面时取到</p>
<p>所以对于每个 $k$ 去二分出一个符合条件的前缀，最后算答案即可</p>
<p>时间复杂度 $\mathcal O(n\log n)$</p>
<ul>
<li>E</li>
</ul>
<p>发现原先的两个操作相当于给任意一个字段加上一个单调不降&#x2F;不升序列</p>
<p>根据调整法可以得到在最优状态下总可以找到一种使得每一种操作的区间不交</p>
<p>设 $a_i&#x3D;b_i+c_i$，其中 $b_i$ 是通过第一个操作加上的数，$c_i$ 是通过第二个操作加上的数</p>
<p>为了方便，设 $a_0&#x3D;0,a_{n+1}&#x3D;0$</p>
<p>考虑 dp，设 $f_{i,j}$ 为前 $i$ 个数，$b_i&#x3D;j$ 的最小操作次数</p>
<p>有转移：$f_{i,j}&#x3D;\min{f_{i-1,k}+[k&gt;j]+[a_{i-1}-k&lt;a_i-j]}&#x3D;\min{f_{i-1,k}+[j&lt;k]+[j&lt;k+a_i-a_{i-1}]}$</p>
<p>发现 $f_{i,j}$ 在 $j$ 上升时不降，并且 $f_{i,0}\le f_{i,a_i}+2$（这是因为用 $f_{i,a_i}$ 相同的 $k$ 转移过来也最多会增加 $2$）</p>
<p>于是对于每个 $f_i$ 存 $f_{i,j}$ 相同的区间，每次可以根据单调性用单调栈转移</p>
<p>时间复杂度 $\mathcal O(n)$</p>
<ul>
<li>F</li>
</ul>
<p>我们记一个状态为 $(x,d)$ 表示前面一个棋子在 $x$，后面一个棋子距离它 $d$</p>
<p>那么每次可以进行三种操作：</p>
<ol>
<li>让 $x$ 和 $d$ 同时加一</li>
<li>$d&gt;1$ 时让 $d$ 减一</li>
<li>让 $d&#x3D;0$</li>
</ol>
<p>最终需要进行 $n$ 次操作使得状态为 $(B,B-A)$</p>
<p>显然第一种操作需要进行 $B$ 次，考虑枚举第二种操作进行几次，设为 $k$</p>
<p>先只考虑前两种操作，则合法的操作序列个数为 $\binom{B+k-1}{k}-\binom{B+k-1}{k-1}$（可以用类似卡特兰数的折线法做）</p>
<p>接下来在一个合法的前两种操作的操作序列上考虑第三种操作，发现为了让 $d&#x3D;B-A$，要在最后一次 $d&#x3D;A-k$ 的时候进行第三种操作，并且在操作序列合法的情况下不关心剩下的 $n-B-k-1$ 个第三种操作的位置</p>
<p>显然第三种不能放在第二种操作前面，那么一共有 $[0,A-k]$ 一共 $A-k+1$ 一个位置可以放第三种操作</p>
<p>那么相当于要求在 $A-k+1$ 个位置里面放 $n-B-k-1$ 个操作，每个位置可以放 $0$ 个或多个操作</p>
<p>由隔板法可知方案数为 $\binom{n-B-k-1+A-k+1-1}{A-k+1-1}$</p>
<p>注意在 $n&#x3D;B+k$ 时只有 $k&#x3D;A$ 才合法</p>
<p>时间复杂度 $\mathcal O(n)$</p>
<h3 id="AGC041"><a href="#AGC041" class="headerlink" title="AGC041"></a>AGC041</h3><ul>
<li>A</li>
</ul>
<p>如果 $b-a$ 为偶数直接相遇即可，否则需要走到一边等一回合再相遇</p>
<p>时间复杂度 $\mathcal O(n)$</p>
<ul>
<li>B</li>
</ul>
<p>考虑从大到小排个序，显然前 $p$ 个一定可行</p>
<p>考虑第 $i$ 个（$i&gt;p$）是否可行</p>
<p>显然如果 $a_i+m&lt;a_p$ 一定不行，否则我们可以给前 $p-1$ 个和后 $n-i$ 个都加上 $m$</p>
<p>然后在用前缀和可以算出 $(p,i)$ 中可以消耗掉多少个评委的分数</p>
<p>时间复杂度 $\mathcal O(n\log n)$</p>
<ul>
<li>C</li>
</ul>
<p>若 $n&#x3D;3$，可以有一个简单的构造：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a..</span><br><span class="line">a..</span><br><span class="line">.bb</span><br></pre></td></tr></table></figure>

<p>这样我们可以解决所有 $3|n$ 的情况</p>
<p>考虑其他情况，此时每行每列必须有 $3$ 的倍数个骨牌</p>
<p>$n&#x3D;4$ 时，有这样一个构造：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">abcc</span><br><span class="line">abdd</span><br><span class="line">eegh</span><br><span class="line">ffgh</span><br></pre></td></tr></table></figure>

<p>$n&#x3D;6$ 时，有这样一个构造：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">abc...</span><br><span class="line">abc...</span><br><span class="line">ddeeff</span><br><span class="line">gghhii</span><br><span class="line">...jkl</span><br><span class="line">...jkl</span><br></pre></td></tr></table></figure>

<p>这样可以组合出所有 $\ge 4$ 的偶数的情况</p>
<p>$n&#x3D;5$ 时，有这样一个构造：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">abc..</span><br><span class="line">abc..</span><br><span class="line">ddehh</span><br><span class="line">f.eii</span><br><span class="line">fggjj</span><br></pre></td></tr></table></figure>

<p>这样 $\ge 4$ 的数中只剩下 $7$ 需要单独构造了</p>
<p>$n&#x3D;7$ 时，类似 $n&#x3D;5$ 有这样一个构造：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">abc....</span><br><span class="line">abc....</span><br><span class="line">kkdde..</span><br><span class="line">llf.e..</span><br><span class="line">..fgghh</span><br><span class="line">...mnii</span><br><span class="line">...mnjj</span><br></pre></td></tr></table></figure>

<p>这样所有 $\ge 4$ 的情况都解决了，$3|n$ 可以用 $n&#x3D;3$ 的情况组合出来，剩下 $n&#x3D;2$ 显然无解，所以就做完了</p>
<p>时间复杂度 $\mathcal O(n^2)$</p>
<ul>
<li>D</li>
</ul>
<p>转化一下第三个条件，即要求前 $\lfloor \frac n2\rfloor+1$ 个数大于后 $\lfloor \frac n2\rfloor$ 个数</p>
<p>考虑初始时让所有 $a_i&#x3D;n$，然后不断减一个前缀</p>
<p>维护一个 $s$ 表示前 $\lfloor \frac n2\rfloor+1$ 个数减去后 $\lfloor \frac n2\rfloor$ 个数</p>
<p>显然初始时 $s&#x3D;n$，而每次减一个前缀 $s$ 都会减少，最后要求 $s&gt;0$</p>
<p>计算出减每个前缀会让 $s$ 减少多少，然后就转化为了一个完全背包问题，直接做即可</p>
<p>时间复杂度 $\mathcal O(n)$</p>
<ul>
<li>E</li>
</ul>
<p>先考虑构造合法的情况</p>
<p>考虑枚举最后移动到哪根导线，设为 $r$</p>
<p>倒序考虑每个平衡器 $(u,v)$，维护 $f_i$ 表示 $i$ 是否能到达 $r$</p>
<p>若 $f_u&#x3D;f_v$ 则这个平衡器没有意义，任意定向即可</p>
<p>否则由 $0$ 指向 $1$，此时修改 $f_u&#x3D;f_v&#x3D;1$</p>
<p>不难发现这就是让 $f_u$ 和 $f_v$ 取一个或，可以直接用 <code>bitset</code> 维护</p>
<p>这样即可在 $\mathcal O(\frac {nm}w)$ 的时间内求得每个 $u$ 能不能到达每个 $r$</p>
<p>一个 $r$ 合法则要求任意 $u$ 都能到达 $r$，于是把 $n$ 个 <code>bitset</code> 全部 <code>and</code> 一下，值为 $1$ 的即为一个合法的 $r$</p>
<p>得到合法的 $r$ 以后再按上述过程定向每个平衡器即可</p>
<p>这部分的时间复杂度为 $\mathcal O(\frac{nm}w)$</p>
<p>再考虑构造不合法的情况</p>
<p>显然 $n&#x3D;2$ 时一定无解</p>
<p>考虑维护 $f_i$ 表示 $i$ 号导线最后会移动到哪里，$cnt_i$ 表示有多少根导线最后会移动到第 $i$ 根导线</p>
<p>仍然倒序考虑每个平衡器 $(u,v)$，若 $cnt_{f_u}&lt;n-1\land cnt_{f_v}&lt;n-1$ 则任意定向；否则若 $cnt_{f_u}&#x3D;n-1$ 则由 $u$ 指向 $v$</p>
<p>考虑 $u\to v$ 的平衡器，这会使 $cnt_{f_u}$ 减一，$cnt_{f_v}$ 加一，$f_u&#x3D;f_v$，由于 $n&gt;2$，则两个 $cnt$ 一定不会同时等于 $n-1$，所以一定有解</p>
<p>这部分时间复杂度 $\mathcal O(m)$</p>
<p>总复杂度 $\mathcal O(\frac{nm}w)$</p>
<ul>
<li>F</li>
</ul>
<p>先考虑一个最基本的容斥</p>
<p>钦定 $k$ 个点不被覆盖，则这一行一列的点都不能被选，其他点可选可不选，容斥系数为 $(-1)^k$</p>
<p>考虑优化这个容斥，由于每列都是连通的，所以考虑钦定 $k$ 列中有点不被覆盖</p>
<p>我们希望做的时候行也是连通的，所以可以把笛卡尔树建出来，在笛卡尔树上 dp</p>
<p>考虑一个长为 $len$ 连通行，若其中钦定了 $k$ 列不被覆盖，则一共有两种转移：</p>
<ol>
<li><p>这行不选不被覆盖的点，剩下 $len-k$ 个点可选可不选，贡献为 $2^{len-k}$</p>
</li>
<li><p>这行选不被覆盖的点，剩下 $len-k$ 个点不能被选，贡献为 $\sum\limits_{1\le i\le k}(-1)^{i}\binom{k}{i}&#x3D;-[k&gt;0]$</p>
</li>
</ol>
<p>但这个容斥并不能保证钦定的列中一定选了点不被覆盖，所以考虑再容斥一次</p>
<p>在钦定的 $k$ 列中再钦定 $t$ 列不选择不被覆盖的点，容斥系数为 $(-1)^t$</p>
<p>此时第一类转移不变，第二类转移的贡献就变为 $-[k&gt;t]$，由于 $k\ge t$，所以只需要考虑 $t$ 是否和 $k$ 相等</p>
<p>记 $f_{u,k,0&#x2F;1}$ 表示笛卡尔树上节点 $u$，第一个容斥中钦定了 $k$ 列，$[t&#x3D;k]$ 为 $0&#x2F;1$ 的方案数</p>
<p>转移的时候发现要对第二维求和，第三位取 <code>and</code>，所以直接类似树上背包转移即可</p>
<p>注意每个节点要加上这个节点代表的一列的贡献，在合并完之后要乘上两类转移和的行数次方</p>
<p>时间复杂度 $\mathcal O(n^2)$</p>
<h3 id="AGC043"><a href="#AGC043" class="headerlink" title="AGC043"></a>AGC043</h3><p>这套题是真离谱（</p>
<ul>
<li>A</li>
</ul>
<p>对于一条路径一次可以翻一段连续的障碍，直接 dp 即可</p>
<p>时间复杂度 $\mathcal O(n^2)$</p>
<ul>
<li>B</li>
</ul>
<p>首先先把所有数都减去 $1$，这样不影响答案</p>
<p>显然答案只可能为 $0,1,2$，一个一个来看</p>
<p>若答案为 $2$，手玩几个就可以发现原序列只可能由 $0,2$ 组成，这种序列答案也只可能为 $0,2$，所以考虑把序列中的所有数都除上 $2$，于是只需要判定一个 $01$ 序列的答案是否为 $1$</p>
<p>若答案为 $1$，不难发现此时 $0$ 和 $2$ 是等价的，可以把 $2$ 视作 $0$，由于存在 $1$，这种序列的答案只可能为 $0,1$，所以考虑把序列中 $2$ 变成 $0$ 后变成判定一个 $01$ 序列的答案是否为 $1$</p>
<p>这样两种序列都可以转化成 $01$ 序列判定答案是否为 $1$ 的问题</p>
<p>此时相邻两项作差取绝对值等价于相邻两项取异或</p>
<p>然后就是套路地看一个位置 $(n,i)$ 对最上面的点 $(1,1)$ 的贡献次数，显然为 $\binom{n-1}{i-1}$</p>
<p>由于只需要求组合数的奇偶性，所以预处理阶乘中 $2$ 的次数即可</p>
<p>时间复杂度 $\mathcal O(n)$</p>
<ul>
<li>C</li>
</ul>
<p>由于 $10^{18}$ 实在太大了，所以原题等价于把所有点 $(u,v,w)$ 按 $u+v+w$ 从大到小排序以后能取就取</p>
<p>因为前面取的数不被后面所影响，所以不妨给所有无向边定个向，从 $u+v+w$ 小的指向大的</p>
<p>由于要取一个独立集，所以一个点能取当且仅当它的后继节点中没有要取的点</p>
<p>联想图上的博弈论模型：一个点先手必败当且仅当它的后继节点中没有先手必败的点，和这题的定义重合</p>
<p>所以要取的点即为 $sg$ 值为 $0$ 的点，而求 $sg$ 函数可以在三张图中独立地求</p>
<p>最后计算答案是一个 $\operatorname{xor}$ 卷积的形式，暴力卷或 <code>FWT</code> 卷都行</p>
<p>时间复杂度 $\mathcal O(n)$</p>
<ul>
<li>D</li>
</ul>
<p>先转化一下题意，不难发现要求每个前缀最大值之间最多有两个数</p>
<p>把一个数列根据前缀最大值拆成若干长度 $\in[1,3]$ 的序列，显然要求长度为 $1$ 的个数 $\ge$ 长度为 $2$ 的个数，并且长度 $1$ 的个数减长度 $2$ 的个数为 $3$ 的倍数</p>
<p>记 $f_{i,j}$ 为已经考虑了 $[i,3n]$ 中的位置，长度为 $1$ 的个数减长度为 $2$ 的个数为 $j$ 的方案数</p>
<p>转移显然，时间复杂度 $\mathcal O(n^2)$</p>
<ul>
<li>E</li>
</ul>
<p>题意：构造一根封闭的绳子，使得点集 $S$ 存在时若 $a_S&#x3D;0$ 则不能解下来，否则可以解下来（显然不能剪断绳子）</p>
<p>显然若存在 $S\subset T$ 使得 $a_S&#x3D;0\land a_T&#x3D;1$ 则无解</p>
<p>我们考虑 $a_S&#x3D;0$ 且任意去掉 $x\in S$ 的点 $x$ 后都有 $a_{S&#x2F; x}&#x3D;1$ 的状态 $S$</p>
<p>显然满足了这些 $S$ 的构造一定能满足原题的条件</p>
<p>先考虑一个满足条件的 $S$，显然可以先不考虑 $S$ 以外的点（只要集中在一侧就好了）</p>
<p>考虑对 $|S|$ 归纳构造</p>
<p>若 $|S|&#x3D;1$，只要绕这个点一圈即可</p>
<p>若 $|S|&#x3D;k$ 有一个构造方案，考虑 $|S|&#x3D;k+1$ 的情况，假设在 $k$ 的基础上在左边加一个点</p>
<p>首先先把 $|S|&#x3D;k$ 的情况的绳子左边断开，并反方向复制一遍，考虑如下的构造：</p>
<p><img src="https://cdn.luogu.com.cn/upload/image_hosting/60xwyzom.png"> </p>
<p>其中红色为 $|S|&#x3D;k$ 的情况的绳子左边断开；蓝色为反方向复制的绳子，绿色为为了把 $k+1$ 套住新加的绳子</p>
<p>不难发现若删除 $[1,k]$ 中的点可以直接解开，删除 $k+1$ 由于有反方向的绳子也可以解开，而不删点显然不能解开，所以这样的构造满足条件</p>
<p>构造完了以后把绳子在 $(0,1)$ 处闭合即可</p>
<p>而满足条件的 $S$ 可能有多个，所以把这些都构造出来，在 $(0,1)$ 处首位拼接即可</p>
<p>可以这样拼接的原因是 $S$ 之间互不包含，满足一个状态 $S$ 的绳子一定可以在另一个满足要求的 $T$ 状态下解开</p>
<p>这样就构造好了，$2.5\times 10^5$ 的限制很松，写的好一点应该是不会超出限制的</p>
<ul>
<li>F</li>
</ul>
<p>拜读一下 dxm 2021国集的论文</p>
<p>考虑对于每个珠宝店对珠宝重量排序</p>
<p>设 $x_{i,j}$ 表示在珠宝 $(i,1),\dots,(i,j)$ 中选了多少个（即第 $i$ 个珠宝店的前缀和）</p>
<p>对于每个询问 $A$，可以写出这样一个线性规划的模型：</p>
<p>对于每一个 $i$，要求 $0&#x3D;x_{i,0}\le x_{i,1}\le\dots\le x_{i,k_i}&#x3D;A$</p>
<p>对于每一个 $(i,j)$，要求 $0\le x_{i,j}-x_{i,j-1}\le C_{i,j}$</p>
<p>对于每一个限制 $(u,v,w)$ 和 $u$ 中的每一个珠宝 $(u,i)$，记 $j$ 为满足 $S_{v,j}\le S_{u,i}+w$ 的最大值，则要求 $x_{u,i}-x_{v,j}\le 0$</p>
<p>最小化 $\sum P_{i,j}(x_{i,j}-x_{i,j-1})$</p>
<p>可以化成这样一个形式：$\min{\sum\limits_{i,j}(\infty\max{0,x_{i,j}-x_{i,j+1}}+\infty\max{0,x_{i,j+1}-x_{i,j}-C_{i,j+1}}+P_{i,j+1}\max{0,x_{i,j+1}-x_{i,j}})+\sum\limits_{i}(\infty x_{i,0}+\infty\max{0,x_{i,0}-x_{i,k_i}+A})+\sum\limits_{u,v,w,i}\infty\max{0,x_{u,i}-x_{v,j}}}$</p>
<p>根据论文，先给这个式子前面取个负号然后再对偶一下就是一个最小费用流模型，再给这个最小费用流取个负号就是答案</p>
<p>由于对 $(i,0)$ 点没有流量平衡限制，所以考虑拿 $(i,0)$ 做源汇点，从 $(i,0)$ 连出去看做从源点连出去，连向 $(i,0)$ 看做连向汇点</p>
<p>考虑多组询问，首先先取 $A&#x3D;0$ 跑一遍费用流</p>
<p>不难发现边权为 $-A$ 的总流量和答案的总流量相同</p>
<p>记费用流的结果为 $c$，流量为 $f$，那么就需要求 $-\min{c-Af}$</p>
<p>由于费用流本身保证了凸性，所以记录下凸壳，然后以 $A$ 为斜率二分即可求出答案</p>
<h3 id="AGC044"><a href="#AGC044" class="headerlink" title="AGC044"></a>AGC044</h3><ul>
<li>A</li>
</ul>
<p>直接记搜，显然每次只有 $7$ 种转移（直接 $-1$ 到底，除以 $2,3,5$ 上&#x2F;下取整）</p>
<ul>
<li>B</li>
</ul>
<p>维护 $dis_{i,j}$ 表示 $(i,j)$ 点的答案，每次移走一个人用 0&#x2F;1 bfs 更新即可</p>
<p>显然初始时 $dis_{i,j}&#x3D;\min{i,j}-1$，每个点会被更新 $dis_{i,j}$ 次，所以总次数为 $\sum_{i\le\lfloor \frac n2\rfloor} i\times 4(n-i-1)&#x3D;\mathcal O(n^3)$</p>
<p>总复杂度 $\mathcal O(n^3)$</p>
<ul>
<li>C</li>
</ul>
<p>AGC057C 的弱化版</p>
<p>用一个三进制的 trie 维护一下，<code>S</code> 操作相当于交换 $1$ 儿子和 $2$ 儿子，<code>R</code> 操作相当于每次向 <code>2</code> 儿子方向走，回溯的时候轮换三个儿子</p>
<p>时间复杂度 $\mathcal O(|T|n+3^n)$</p>
<ul>
<li>D</li>
</ul>
<p>首先先用 $62$ 次全 <code>a</code> 串问出每种字符出现的次数，加起来可以求出字符串长度</p>
<p>结论：记一个字符串 $S$ 的编辑距离为 $d_S$，则 $d_T-d_S&#x3D;|T|-|S|$ 当且仅当 $S$ 是 $T$ 的子串</p>
<p>所以可以通过这一个结论判断出一个串是不是答案串的子串</p>
<p>考虑对字符集分治，每次用类似归并排序的方法合并</p>
<p>可做到操作 $L\lceil\log 62\rceil&#x3D;768$ 次</p>
<ul>
<li>E</li>
</ul>
<p>18 年 USACO 一道题的加强版</p>
<p>首先环上的问题不好做，考虑断环成链</p>
<p>不妨设 $a_1&#x3D;\max{a}$，显然走到 $1$ 了以后不继续走是最优的</p>
<p>所以令 $a_{n+1}&#x3D;a_1$ 就把环上的问题变到序列上了</p>
<p>记 $E_i$ 为走到 $i$ 之后的期望收益</p>
<p>显然有 $E_i&#x3D;\max{a_i,\frac{E_{i-1}+E_{i+1}}2-b_i}$，与原题相比多了一个 $-b_i$</p>
<p>考虑等式两边减去 $c_i$，即 $E_i-c_i&#x3D;\max{a_i-c_i,\frac{E_{i-1}+E_{i+1}}2-c_i-b_i}$</p>
<p>记 $F_i&#x3D;E_i-c_i$，则 $F_i&#x3D;\max{a_i-c_i,\frac{F_{i-1}+F_{i+1}}2+\frac{c_{i-1}+c_{i+1}}2-c_i-b_i}$</p>
<p>令 $c_1&#x3D;c_2&#x3D;0$，$c_{i+1}&#x3D;2c_i+2b_i-c_{i-1}$，则有 $F_i&#x3D;\max{a_i-c_i,\frac{F_{i-1}+F_{i+1}}2}$</p>
<p>直接求 $(i,a_i-c_i)$ 的上凸壳即可</p>
<p>时间复杂度 $\mathcal O(n)$</p>
<ul>
<li>F</li>
</ul>
<p>我们把 $k$ 个俱乐部组成的集合写成 $k$ 行 $n$ 列的 01 矩阵</p>
<p>首先考虑没有两个俱乐部相同的情况</p>
<p>此时若一个 $k\times n$ 的矩阵 $M$ 合法，则 $M^T$ 也合法</p>
<p>记 $M$ 的补集为 $M^c$，为 $(2^n-k)\times n$ 的矩阵，则 $M$ 合法，$M^c$ 也合法</p>
<p>记 $g(n)$ 为 $M$ 合法时最小的行数 $k$</p>
<p>那么有 $M^T$ 合法，$(M^T)^c$ 也合法，而 $(M^T)^c$ 为 $(2^{g(n)}-n)\times g(n)$ 的矩阵</p>
<p>而显然 $g(n)$ 列的矩阵合法的 $k$ 的最小值为 $g(g(n))$</p>
<p>则有 $g(g(n))\le 2^{g(n)}-n$</p>
<p>记 $G(n)$ 为使 $G(G(n))\le 2^{G(n)}-n$ 成立的最小值，特别地，令 $G(1)&#x3D;0$</p>
<p>引理 $1$：$g(n)&#x3D;G(n)$，同时存在 $k$ 行的合法矩阵当且仅当 $G(n)\le k\le 2^{n}-G(n)$</p>
<p>考虑对 $n$ 归纳，$n&#x3D;2$ 时显然成立</p>
<p>若 $G(n)\le k&lt;n$，则考虑一个 $n\times k$ 的矩阵 $M$，显然若 $M$ 合法则 $M^T$ 合法，而 $G(k)\le k\le n\le 2^{G(n)}-G(G(n))\le 2^{k}-G(k)$ 成立，所以存在合法的 $M$</p>
<p>若 $n\le k\le 2^{n-1}$，则考虑一个 $(n-1)\times n$ 的矩阵：$\{\{1\},\{1,2\},\{2,3\},\dots,\{n-2,n-1\}\}$，剩下的 $k-n+1$ 行每行填至少 $3$ 个 $1$ 或全部填 $0$，此时的矩阵一定合法，且 $n\ge 3$ 时一定有至少 $k-n+1$ 种填法，所以此时也成立</p>
<p>最后 $2^{n-1}&lt;k\le 2^{G(n)}-n$ 时，取之前矩阵的补集即可</p>
<p>至此引理 $1$ 得证</p>
<p>接下来考虑计算 $k\times n$ 的合法矩阵有多少个，设为 $c(n,k)$</p>
<p>显然 $c(n,k)&#x3D;c(k,n)&#x3D;c(n,2^n-k)$，所以只需要考虑 $k\le n\le 2^{k-1}$ 的 $c(n,k)$ 即可</p>
<p>引理 $2$：若 $6\le k\le n\le2^{k-1}$，则 $c(n,k)&gt;1000$</p>
<p>考虑一个合法的转置矩阵，先构造两个 $(k-2)\times k$ 的合法矩阵：</p>

$$
\{\{1,2\},\{2,3\},\dots,\{k-2,k-1\}^c\}
$$
$$
\{\{1,2\}^c,\{2,3\}^c,\dots,\{k-2,k-1\}\}
$$


<p>其中上标 $c$ 表示补集</p>
<p>再在这两个矩阵中加 $n-k+2$ 行，每行 $1$ 的数量都不为 $2$ 或 $k-2$，则矩阵一定合法</p>
<p>所以有 $c(n,k)\ge 2\binom{2^k-2\binom{k}{2}}{n-k+2}$</p>
<p>在 $6\le k\le n\le 2^{k-1}$ 时显然有 $c(n,k)&gt;1000$</p>
<p>所以我们只需要考虑 $k\le 5$ 的情况，此时直接爆搜就可以了</p>
<p>最后还需要考虑有两个俱乐部相同的情况，此时由于不同的俱乐部有 $g(n)-1$ 个，又任意两个人不能选同样的俱乐部集合，所以有 $2^{g(n)-1}\ge n$</p>
<p>而打个表可知满足条件且 $c(n,g(n))\le 1000$ 的只有 $n&#x3D;4,n&#x3D;7,n&#x3D;8$ 三种</p>
<p>再写个爆搜可知 $n&#x3D;4$ 时有一种情况，$n&#x3D;7$ 时有两种情况，$n&#x3D;8$ 时没有合法情况</p>
<p>所以在 $n&#x3D;4$ 时把答案 $+1$，$n&#x3D;7$ 时把答案 $+2$ 即可</p>
<h3 id="AGC045"><a href="#AGC045" class="headerlink" title="AGC045"></a>AGC045</h3><ul>
<li>A</li>
</ul>
<p>倒序考虑每一个操作</p>
<p>考虑维护一个集合 $S$ 表示能做到答案为 $0$ 的数集</p>
<p>初始时 $S&#x3D;{0}$</p>
<p>若此操作为 $0$，则相当于 $S\leftarrow {x|x\in S\lor x\oplus a_i\in S}$</p>
<p>若此操作为 $1$，则相当于 $S\leftarrow {x|x\in S\land x\oplus a_i\in S}$</p>
<p>不难想到用线性基来维护 $S$</p>
<p>若此操作为 $0$，则相当于在线性基中加入 $a_i$</p>
<p>若此操作为 $1$，则相当于在线性基中查询是否有 $a_i$，若有则 $S$ 不变，若没有则 $S$ 变为空集</p>
<p>时间复杂度 $\mathcal O(n\log w)$，$w$ 为值域</p>
<ul>
<li>B</li>
</ul>
<p>不妨令 $0$ 为 $-1$，那么一个字符串的不平衡度为它所有前缀和的极差</p>
<p>考虑计算 $f(x)$ 表示最小值 $\ge x$ 时最大值最小是多少</p>
<p>不妨先把所有的 <code>?</code> 设置为 $1$，然后从前往后贪心</p>
<p>每次遇到一个 <code>?</code>，若果将它改为 $-1$ 不会超过最小值的限制那么改为 $-1$ 一定不劣</p>
<p>这样就可以在 $\mathcal O(n)$ 内求出 $f(x)$</p>
<p>记把所有 <code>?</code> 设置为 $1$ 后的前缀和最小值为 $m$，那么显然有 $f(m)-2\le f(m-2)$</p>
<p>所以只要求出 $f(m)$ 和 $f(m-1)$ 的值就可以了</p>
<p>时间复杂度 $\mathcal O(n)$</p>
<ul>
<li>C</li>
</ul>
<p>不妨设 $a\le b$</p>
<p>发现一个字符串合法当且仅当把它所有长度 $\ge a$ 的全 $0$ 子串变为 $1$ 后存在长度 $\ge b$ 的全 $1$ 子串</p>
<p>考虑计算不合法的字符串数，可以用两个简单 dp 算出来</p>
<p>时间复杂度 $\mathcal O(n^2)$</p>
<ul>
<li>D</li>
</ul>
<p>显然把排列画成图是若干个环的形式</p>
<p>由于排列是均匀随机生成的，所以不妨每次选择一个亮着的灯中编号最小的进行操作</p>
<p>如果它不是自环，那么显然可以一起把这个环中的所有点全部点亮</p>
<p>如果它是自环，那就输了</p>
<p>所以可以把胜利条件转化一下：记 $[1,A]$ 第一个自环在 $t$ 处（若没有自环则 $t&#x3D;A+1$，则 $[A+1,n]$ 中所有点所在的连通块中一定要有一个点在 $[1,t)$ 中</p>
<p>考虑枚举这个 $t$，要求 $t$ 前面不能有自环</p>
<p>考虑容斥一下，钦定 $t$ 前面的 $k$ 个点为自环，贡献系数为 $(-1)^k\binom{t-1}{k}$，然后把问题转化为有 $a+b+c$ 个点，其中 $b$ 个点的连通块中一定要有一个点是前 $a$ 个点</p>
<p>考虑先把前 $a$ 个点任意排列，有 $a!$ 种方法</p>
<p>然后把 $b$ 个点插入前 $a$ 个点形成的环，第 $i$ 个点有 $a+i-1$ 种方法</p>
<p>最后 $c$ 个点没有限制，第 $i$ 个点有 $a+b+i$ 种方法</p>
<p>所以总方案数为 $(a+b+c)!\frac{a}{a+b}$</p>
<p>时间复杂度 $\mathcal O(A^2+n)$</p>
<ul>
<li>E</li>
</ul>
<p>对于一个 $a_i$ 移到 $b_i$ 的球，连一条 $a_i\to b_i$ 的边</p>
<p>先考虑 $c_i&#x3D;1$ 的情况，此时若有解当且仅当不存在底图为 $\ge 2$ 的环的弱连通块</p>
<p>充要性显然（可以画图看一看）</p>
<p>再考虑一般情况，我们称额外代价为除了 $\sum[a_i\not&#x3D;b_i]$ 以外的代价，一条额外边的代价只在进入的连通块处统计</p>
<p>此时把弱连通块分成三种</p>
<ol>
<li><p>一个点自环，此时如果移一个点进来可以产生 $c_i-1$ 的贡献，同时产生 $2$ 的代价</p>
</li>
<li><p>底图为 $\ge 2$ 的环，此时如果移一个点进来可以产生 $\sum(c_i-1)$ 的贡献，同时产生 $1$ 的代价</p>
</li>
<li><p>其他弱连通块中的自环可以产生 $c_i-1$ 的贡献，同时产生 $1$ 的代价；其他点可以产生 $c_i-1$ 的贡献，同时产生 $0$ 的代价</p>
</li>
</ol>
<p>我们记总贡献为 $sum$，使用的一类连通块有 $Y$ 个，二类连通块一共有 $X$ 个，则要求 $sum\ge X+Y$，而一二类点产生贡献需要其他连通块中的点移进去，所以必须要选至少一个三类连通块中的点</p>
<p>所以把所有 $0$ 代价点选进去，然后把一类连通块的点和三类连通块中的自环按贡献排序跑一遍双指针即可</p>
<p>时间复杂度 $\mathcal O(m\log m)$</p>
<ul>
<li>F</li>
</ul>
<p>首先可以根据 $pa+qb&#x3D;kc$ 把 $a,b,c$ 调整到 $\gcd(a,c)&#x3D;1$ 且 $\gcd(b,c)&#x3D;1$</p>
<p>我们要求的即一些极小二元组 $(p,q)$ 使得 $pa+qb&#x3D;kc$</p>
<p>记 $d\equiv \frac ab\pmod c$，由于 $\gcd(b,c)&#x3D;1$，所以 $b$ 的逆元存在</p>
<p>那么不难发现这些二元组是 $(0,c),(1,c-d),(2,c-2d),\dots(c,0)$</p>
<p>但这些二元组不一定每一个都是极小的</p>
<p>对于极小的二元组，显然有对于任意 $j&lt;i$，$c-jd&lt;c-id\Leftrightarrow id&lt;jd\pmod c$ 成立</p>
<p>考虑一个横坐标 $\bmod c$，纵坐标 $\bmod d$ 意义下的坐标系，从原点开始，每次按 $(1,1)$ 方向走，每次纵坐标为 $0$ 时就是一个合法的二元组 $(\frac xd,c-x)$，如果此时是合法点对中横坐标最大的那个则是一个极小点对</p>
<p>不难发现这个过程可以用一个类似辗转相除的算法加速，得到的答案为 $\mathcal O(\log w)$ 个等差数列</p>
<p>然后考虑二分一下答案，设为 $mid$</p>
<p>则要判定在这些极小二元组中能否找到一个 $mid$ 个二元组 $(p,q)$ 的组合使得 $\sum p\le x$ 且 $\sum q\le y$</p>
<p>发现这是一个闵可夫斯基和的形式，而极小的二元组画到坐标系里又是一个下凸壳的形式，所以直接对每个等差数列分开考虑即可</p>
<p>时间复杂度 $\mathcal O(T\log^2w)$</p>
<h3 id="AGC046"><a href="#AGC046" class="headerlink" title="AGC046"></a>AGC046</h3><ul>
<li>A</li>
</ul>
<p>答案为 $\dfrac{360\frac x{\gcd(360,x)}}x$</p>
<ul>
<li>B</li>
</ul>
<p>设 $f_{i,j}$ 为增加了 $i$ 列，覆盖到了增加的 $j$ 行的方案数</p>
<p>每次转移的时候可以选择 $\le j$ 的转移也可以选择 $&gt;j$ 的，此时要把行一起转移进来</p>
<p>简单用个前缀和维护一下即可</p>
<p>时间复杂度 $\mathcal O(cd)$</p>
<ul>
<li>C</li>
</ul>
<p>发现操作次数最多不会超过 $1$ 出现的次数，所以可以让 $k$ 对 $n$ 取个 $\min$</p>
<p>考虑根据序列中 $0$ 的位置给序列分段，算出每段中 $1$ 的个数</p>
<p>从后往前 dp，显然一段的 $1$ 只能是这一段本来就有的或者是从后面通过一次操作移过来的</p>
<p>设 $f_{i,j,k}$ 为考虑到第 $i$ 段，后面还可以给前面贡献 $j$ 个 $1$，总共需要 $k$ 次操作的方案数</p>
<p>转移的时候考虑这一段是移出去还是移进来，用前缀和维护转移即可</p>
<p>时间复杂度 $\mathcal O(n^3)$</p>
<ul>
<li>D</li>
</ul>
<p>考虑对每个答案序列唯一对应一个操作序列</p>
<p>发现可以用一个答案序列唯一确定三个变量 $(x,y,z)$，表示用原序列 $x$ 以后的后缀，$y$ 个自由的 $0$ 和 $z$ 个自由的 $1$，要求 $x$ 最小</p>
<p>倒序考虑答案序列，若可以对应到原序列则 $x$ 减去 $1$，否则加入到 $y $ 或 $z $ 中</p>
<p>记 $g_{i,j,k}$ 为三元组 $(i,j,k)$ 能表示多少个答案序列，可以通过一个简单的 dp 求出</p>
<p>记 $f_{i,j,k}$ 为三元组 $(i,j,k)$ 能否通过操作得到，转移的时候考虑是删去 $i$ 中的两个还是删去 $i$  中的一个还是删去两个自由变量</p>
<p>最后答案即为 $\sum f_{i,j,k}g_{i,j,k}$</p>
<p>时间复杂度 $\mathcal O(n^3)$</p>
<ul>
<li>E</li>
</ul>
<p>首先考虑什么时候有解</p>
<p>发现有解当且仅当 $2\min{a_i}\ge \max{a_i}$</p>
<p>充分性显然，下证必要性</p>
<p>取一个集合 $S\in {1,2,\dots,k}$，发现 ${S,\bar S,S}$ 组成的序列是合法的</p>
<p>而在这个序列中一些数被选了两次，其他数被选了一次</p>
<p>由于 $2\min{a_i}\ge \max{a_i}$，则原数集一定可以拆成这样的序列</p>
<p>所以必要性得证</p>
<p>接下来考虑构造一个字典序最小的解</p>
<p>考虑什么样符合条件的序列 $P$ 能成为答案序列的前缀</p>
<p>设 $b_i$ 表示数 $i$ 还需要出现多少次，$x&#x3D;\min{b_i},y&#x3D;\max{b_i}$，$Q$ 为 $P$ 最后 $k$ 个数组成的排列（由于 $P$ 是合法序列所以最后 $k$ 个数一定是排列）</p>
<p>有解当且仅当下面两个条件中至少成立一个：</p>
<ol>
<li><p>$2x\ge y$</p>
</li>
<li><p>$y&#x3D;2x+1$，且 $Q$ 中所有在 $b $ 中取到最大值的数都在 $b$ 中取到最小值的数之前</p>
</li>
</ol>
<p>证明和上面类似</p>
<p>所以枚举一次向 $P$ 中加入哪些数即可</p>
<p>时间复杂度 $\mathcal O(k^2\sum a)$</p>
<ul>
<li>F</li>
</ul>
<p>引理 $1$：竞赛图中若没有三元环则是 DAG</p>
<p>证明：考虑反证，假设图中最小环为 $p_1,p_2,\dots,p_k(k\ge 4)$，则考虑 $p_1$ 和 $p_3$ 之间的边，无论以什么方向连都会产生一个更小的环，矛盾</p>
<p>考虑一张竞赛图，若其中存在一个入度为 $0$ 的点，则可以去掉这个点，转化为一个更小的子问题，所以只需要考虑所有点入度 $&gt;0$ 的情况</p>
<p>任意取一个点 $u$，记 $V$ 表示 $u$ 的前驱集合，$V’ $ 表示 $u$ 的后继集合</p>
<p>引理 $2$：$V$ 的导出子图是 DAG</p>
<p>证明：若 $V$ 不是 DAG，则有三元环，设为 $p_1,p_2,p_3$，则 $((p_1,p_2,p_3),u)$ 不合法</p>
<p>记 $S_v(v\in V’)$ 表示 $v$ 的后继中在 $V$ 集合中的点集</p>
<p>引理 $3$：若对于 $p_1,p_2\in V’$，边 $p_1\to p_2$ 存在，则 $S_{p_1}\subseteq S_{p_2}$</p>
<p>证明：考虑反证，若存在 $v\in V$ 使得 $v\in S_{p_1}\land v\notin S_{p_2}$ 成立，则 $((d,v,p_1),p_2)$ 不合法，矛盾</p>
<p>引理 $4$：$V’$ 的导出子图是 DAG</p>
<p>证明：考虑反证，若存在三元环 $p_1,p_2,p_3$，则 $S_{p_1}&#x3D;S_{p_2}&#x3D;S_{p_3}&#x3D;\emptyset$ 成立（否则取 $v\in S_{p_1}$，有 $((p_1,p_2,p_3),v)$ 不合法）</p>
<p>再任取 $p_4\in V’$，若不存在 $p_4\to p_i$ 的边，则 $((p_1,p_2,p_3),p_4)$ 不合法，所以一定存在 $p_4\to p_i$ 的边，则 $S_{p_4}\subseteq S_{p_i}&#x3D;\emptyset$，即 $S_{p_4}&#x3D;\emptyset$</p>
<p>由于 $V$ 的导出子图为 DAG，所以取其中入度为 $0$ 的点，由于 $V’ $ 中所有 $S$ 都为空集，所以这个点的总入度为 $0$，与入度 $&gt;0$ 矛盾，得证</p>
<p>接下来考虑形如 $(p_1,p_2,q_1,q_2)$ 的不合法情况，其中 $p_1,p_2\in V,q_1,q_2\in V’$，不妨设有边 $p_1\to p_2$，$q_1\to q_2$</p>
<p>根据引理 $3$ 可知 $((p_1,p_2,q_1),q_2)$ 不合法的情况不存在</p>
<p>若 $((p_1,q_1,q_2),p_2)$ 不合法，则 $p_1\in S_{q_2},p_2\in S_{q_1},p_2\in S_{q_2}$，可知 $S_v$ 一定是 $V$ 中拓扑序的一段前缀</p>
<p>而对于其他形式的不合法情况，这个条件也是充分的</p>
<p>记 $a_i&#x3D;|S_v|$，其中 $v$ 在 $V’$ 的导出子图中拓扑序为 $i$，可以把限制进行如下转换：</p>
<ol>
<li><p>$0\le a_1\le a_2\le\dots\le a_{|V’|}$，且 $a_{|V’|}\ge 1$（由于所有点入度 $&gt;0$ 所以 $V$ 中拓扑序最小的点一定在 $a_{|V’|}$ 中）</p>
</li>
<li><p>对于任意 $1\le i\le |V’|$，有 $|V|-a_i+i\le k$</p>
</li>
<li><p>对于任意 $1\le i\le |V|$，有 $\sum[a_i\ge i]+i-1\le k$</p>
</li>
</ol>
<p>第三个条件可以直接拿所有的 $j&#x3D;a_i$ 来判，所以可以转化为对于任意 $1\le i\le |V’|$ 有 $|V’|-i+a_i\le k$</p>
<p>即每个 $a_i$ 都有个范围，且要求递增</p>
<p>设 $f_{i,j}$ 表示考虑前 $i$ 个数，$a_i&#x3D;j$ 的方案数，用前缀和维护转移即可</p>
<p>时间复杂度 $\mathcal O(n^4)$</p>
<h3 id="AGC047"><a href="#AGC047" class="headerlink" title="AGC047"></a>AGC047</h3><ul>
<li>A</li>
</ul>
<p>小数化成分数，发现分母只有质因数 $2$ 和 $5$，所以直接维护这两个质因数的个数即可</p>
<p>注意不要拿 <code>double</code> 进行运算，会掉精度</p>
<p>时间复杂度 $\mathcal O(n\log_2w\log_5 w)$，$w$ 为值域</p>
<ul>
<li>B</li>
</ul>
<p>首先按字符串长度排序，考虑什么样的串可以通过变换当前串得到</p>
<p>显然一个合法的串可以表示成当前串的一个后缀（可以为空）加上这个后缀之前的一个字符</p>
<p>直接拿 <code>trie</code> 维护一下即可</p>
<p>时间复杂度 $\mathcal O(w\sum |S|)$，$w$ 为字符集大小</p>
<ul>
<li>C</li>
</ul>
<p>由于乘积不好算，所以给它取个 $\log$，变成求和</p>
<p>取完 $\log$ 就可以用 <code>FFT</code> 求出每个和出现了多少次，然后再求答案即可</p>
<p>质数 $p&#x3D;200003$ 的原根为 $2$</p>
<p>时间复杂度 $\mathcal O(p\log p)$</p>
<ul>
<li>D</li>
</ul>
<p>考虑第一棵树上的每一个非叶子节点 $u$，计算在第一棵树上以 $u$ 作为 $\operatorname{LCA}$ 的答案</p>
<p>考虑标记所有 $u$ 的左子树的叶子在第二棵树中对应的点，统计的时候只需要从 $u$ 右子树的叶子在第二棵树中对应的点不断向上跳即可</p>
<p>时间复杂度 $\mathcal O(2^nn^2)$</p>
<ul>
<li>E</li>
</ul>
<p>先考虑一个基本操作：二进制左移，只需要不断翻倍就行了</p>
<p>考虑把 $a$ 二进制拆分，就变成了若干个 $b\times 2^k$ 相加，而 $b\times 2^k$ 可以通过左移得到</p>
<p>所以现在只需要支持这样三元运算 <code>x?y:0</code> 即可</p>
<p>把它转化一下，变成 <code>max(0,y-((x==0)&lt;&lt;30))</code>，所以只需要支持一个求 <code>max(0,x-y)</code> 的操作</p>
<p>这个依然可以直接二进制拆分得到</p>
<p>总操作次数大概在 $\mathcal O(\log^3 w)$ 左右，只要写的不太浪费应该都能过</p>
<ul>
<li>F</li>
</ul>
<p>考虑一个最基本的 dp：$f_{l,r,0&#x2F;1}$ 表示吃掉了 $[l,r]$ 中所有的棋子，现在在左端点&#x2F;右端点，吃掉其他的棋子还需要多少时间</p>
<p>转移的时候可以向左扩展或者向右扩展，把曼哈顿距离转移进去</p>
<p>由于在吃棋的时候可以斜着走，所以吃了 $k$ 个棋子的答案需要减去 $k-1$</p>
<p>考虑缩一下点，比如向左扩展的时候可以连续向左扩展就全部扩展进去，这样答案一定不会更劣</p>
<p>这样合法的状态数是 $\mathcal O(n)$ 的，用记忆化搜索和 <code>map</code> 就可以在 $\mathcal O(n\log n)$ 的时间内解决</p>
<h3 id="AGC048"><a href="#AGC048" class="headerlink" title="AGC048"></a>AGC048</h3><ul>
<li>A</li>
</ul>
<p>从左往右找到第一个非 <code>a</code> 的位置，不断向左移判断即可</p>
<p>时间复杂度 $\mathcal O(Tn)$</p>
<ul>
<li>B</li>
</ul>
<p>不妨先把所有的位置都填上小括号，考虑哪些位置能改成中括号</p>
<p>显然要求奇数位上的中括号数和偶数位上的中括号数相等</p>
<p>用两个堆维护一下即可，时间复杂度 $\mathcal O(n\log n)$</p>
<ul>
<li>C</li>
</ul>
<p>显然对于 $a_i&#x3D;b_i$ 的企鹅是不会移动的，所以考虑根据这些位置给序列分一下段</p>
<p>考虑其中的一段 $[l,r]$，其中 $a_l&#x3D;b_l,a_r&#x3D;b_r$，中间没有其他点有 $a_i&#x3D;b_i$</p>
<p>显然只能是一个前缀向左移，一个后缀向右移</p>
<p>考虑计算一个向左移的连续段（向右移的连续段同理）</p>
<p>考虑从后往前扫一遍，如果在当前位置有企鹅停下来就说明目前为止所有企鹅都要在这个位置停下来，否则不需要停下来，直接维护答案即可</p>
<p>时间复杂度 $\mathcal O(n)$</p>
<ul>
<li>D</li>
</ul>
<p><del>数据范围一眼区间 dp（×</del></p>
<p>显然只剩一堆石子时先手必胜，只剩两堆石子时多先手的石子大于后手的石子则先手必胜</p>
<p>考虑更多石子的情况，不妨假设剩下 $[l,r]$ 中的石子，先手取左边石子</p>
<p>若考虑 $[l+1,r]$ 中的石子，先手取右边石子必败，则原问题有先手必胜</p>
<p>否则先手不断在 $l$ 中取一个石子，后手不断在 $r$ 中取一个石子，直到 $[l+1,r]$ 中先手取右边必败或者 $[l,r-1]$ 中先手取左边必败</p>
<p>所以设 $f_{l,r,0&#x2F;1}$ 表示考虑 $[l,r]$ 中的石子，先手取左边&#x2F;右边，先手的石子至少有多少个才能保证必胜，若先手无论如何必败则 $f$ 值为 $-1$</p>
<p>显然如果求出 $f_{l,r,0}&gt;a_l$ 则 $f_{l,r,0}&#x3D;-1$；$f_{l,r,1}$ 同理</p>
<p>考虑 $f_{l,r,0}$ 的转移（$f_{l,r,1}$ 同理）</p>
<p>转移时要保证石子数能坚持到 $[l+1,r]$ 中先手取右边必败并且还要保证 $[l,r-1]$ 中先手取左边必胜</p>
<p>所以有 $f_{l,r,0}&#x3D;f_{l,r-1,0}+a_r-f_{l+1,r,1}+1$</p>
<p>时间复杂度 $\mathcal O(Tn^2)$</p>
<ul>
<li>E</li>
</ul>
<p>记 $c_i&#x3D;a_i+Tb_i$，则题目要求 $b_i&#x3D;\sum\limits_{j&lt;i}[c_j&lt;c_i]$</p>
<p>引理 $1$：若填好了一个合法前缀 $[1,i]$，则一定存在一个 $b_{i+1}$ 使得题目条件成立</p>
<p>证明：考虑反证，假设不存在 $b_{i+1}$ 使得题目条件成立</p>
<p>记 $f(x)$ 表示 $b_{i+1}&#x3D;x$ 时 $\sum\limits_{j&lt;i}[c_j&lt;c_i]$ 的值，显然有 $f(x)$ 关于 $x$ 单调不降</p>
<p>由于 $f(i)\le i$ 且不存在 $b_{i+1}$ 使得题目条件成立，可得 $f(i)\not &#x3D;i$，即 $f(i)&lt;i$</p>
<p>由 $f(i)&lt;i$ 可得 $f(i-1)\le f(i)&lt;i$ 即 $f(i-1)\le i-1$，同理可得 $f(i-1)&lt;i-1$</p>
<p>将这个操作一直进行下去，可得 $f(0)&lt;0$，矛盾</p>
<p>由引理 $1$ 显然可以得到一个推论：若填好了一个合法前缀 $[1,i]$，则一定存在一个以它为前缀的合法序列</p>
<p>引理 $2$：若 $b_i$ 是字典序最大的合法序列，则一定不存在 $i$ 使得 $a_1-T&lt;c_i\le a_1$</p>
<p>证明：考虑反证，假设存在一个 $i$ 使得 $a_1-T&lt;c_i\le a_1$</p>
<p>考虑把 $b_i$ 增加 $1$，此时 $1$ 会对 $i$ 额外增加 $1$ 的贡献，则 $[1,i]$ 是一个合法的前缀</p>
<p>由引理 $1$ 的推论可得把 $b_i$ 增加 $1$ 后仍然存在一个合法的序列，而这个序列相比于原序列字典序更大，矛盾</p>
<p>引理 $3$：若 $b_i$ 是字典序最大的合法序列，则删去 $b_1$ 后，将所有 $c_i&gt;a_1$ 的 $b_i$ 减去 $1$，剩下的 $b_i$ 是 $[2,n]$ 中字典序最大的合法序列</p>
<p>证明：由于删去 $b_1$ 之后所有 $c_i$ 的相对位置不变，且 $1$ 产生的贡献已经被减掉了，所以 $b$ 合法</p>
<p>而 $b_i$ 是字典序最大的合法序列可以由反证法证明，假设我们将 $b_i$ 增加了 $1$</p>
<p>由于原序列中 $b_i$ 是字典序最大的合法序列，所以将 $b_i$ 增加 $1$ 之后任何 $j&lt;i$ 都不能产生新的贡献；若要产生新的贡献则至少需要将一个 $j&lt;i$ 的 $b_j$ 减去 $1$，矛盾</p>
<p>考虑倒序执行引理 $3$ 的过程，每次在序列前加入一个数 $x$，并把所有 $c_i&gt;x-T$ 的 $b_i$ 增加  $1$，得到的 $b_i$ 即为字典序最大的合法序列</p>
<p>于是考虑枚举第 $i$ 个位置选哪个数，记 $f_{k,j}$ 为选了 $[k,i]$ 中的数，$b_i&#x3D;j$ 的方案数，转移显然</p>
<p>时间复杂度 $\mathcal O(n^5)$</p>
<ul>
<li>F</li>
</ul>
<p>将 $S$ 反过来，则一个数的贡献为一个形如 <code>101010...</code> 的串，称这种字符串为好的字符串</p>
<p>考虑不断贪心地从 $S$ 中取出最长的好串，记它们的长度为 $l_1,l_2,\dots,l_k$</p>
<p>假设原先在黑板上的数从大到小为 $x_1,x_2,\dots,x_m$，则这些数合法当且仅当下列条件被满足：</p>
<ol>
<li><p>$\sum x&#x3D;\sum l$</p>
</li>
<li><p>对于 $\forall 1\le i\le k$，有 $\sum\limits_{j\le i}\lfloor \frac{l_j}2\rfloor\ge \sum\limits_{j\le i}\lfloor\frac{x_j}2\rfloor$（限制了 $0$ 的个数）</p>
</li>
<li><p>对于 $\forall 1\le i\le k$，有 $\sum\limits_{j\le i}\lceil \frac{l_j}2\rceil\ge \sum\limits_{j\le i}\lceil\frac{x_j}2\rceil$（限制了 $1$ 的个数）</p>
</li>
</ol>
<p>必要性显然，下证充分性：</p>
<p>引理：对于两个好的字符串 $a,b$，其中 $|a|\le|b|$，以任意顺序合并，得到的串一定能拆成两个好串 $c,d$，其中 $|a|\le|c|\le|d|\le |b|$，且 $a,b$ 中的 $0,1$ 个数和 $c,d$ 中的 $0,1$ 个数相等</p>
<p>证明：从 $a,b$ 合并之后的串中取出一个最长的好串 $p$，剩余的字符一定组成另一个好串 $q$</p>
<p>则 $|c|\ge |q|$，所以可以把所有 $q$ 放到 $c$ 中，再取一些其他的点一定能构成 $c$（由 $|c|\le |p|$）</p>
<p>由于 $k\le m$，所以不妨在数列 $l$ 后面添加若干个 $0$，使得 $k&#x3D;m$，目标变为对于所有 $i$ 都有 $l_i&#x3D;x_i$</p>
<p>根据引理，有如下操作：</p>
<ol>
<li><p>若不存在 $l_i&lt;x_i$，说明操作已经完成</p>
</li>
<li><p>假设存在 $i$ 使得 $l_i&lt;x_i$，且存在 $j&lt;i$ 使得 $l_j\ge x_j+2$，则有 $l_i&lt;x_i\le x_j\le l_j-2$，根据引理，可以将 $l_i,l_j$ 调整为 $l_i+2$ 和 $l_j-2$</p>
</li>
<li><p>若不存在 $j&lt;i$ 使得 $l_j\ge x_j+2$，则一定存在 $j&lt;i$ 使得 $l_j&#x3D;x_j+1$ 且 $l_j\not\equiv l_i\pmod 2$，根据引理，可以将 $l_i,l_j$ 调整为 $l_i+1$ 和 $l_j-1$</p>
</li>
</ol>
<p>以上步骤可以在有限步内结束，即充分性得证</p>
<p>然后考虑 dp：设 $f_{i,j,k,l}$ 为考虑前 $i$ 个 $x$，$x_i&#x3D;j$，$\sum\limits_{j\le i}\lfloor\frac{x_j}2\rfloor&#x3D;k$，$\sum\limits_{j\le i}\lceil\frac{x_j}2\rceil&#x3D;l$ 的方案数</p>
<p>由于 $i$ 之前的 $x$ 都 $\ge j$，所以状态数只有 $\mathcal O(n^3\ln n)$ 个，而转移可以通过前缀和在 $\mathcal O(1)$ 内完成，所以总复杂度 $\mathcal O(n^3\ln n)$</p>
<h3 id="AGC049"><a href="#AGC049" class="headerlink" title="AGC049"></a>AGC049</h3><ul>
<li>A</li>
</ul>
<p>大概是个经典题（？</p>
<p>考虑每个点被删除的概率，显然每个点有机会被删除当且仅当删除它时所有的前驱都没被删</p>
<p>记 $u$ 的前驱集合为 $f(u)$，则它被删的概率为 $\frac 1{|f(u)|}$</p>
<p>总答案为即 $\sum \frac1{|f(u)|}$</p>
<ul>
<li>B</li>
</ul>
<p>题目中的操作可以看做交换 <code>01</code> 变成 <code>10</code> 和把 <code>11</code> 变成 <code>00</code></p>
<p>考虑从前往后扫一遍目标串的 $1$ 位置，再维护一个原串的 $1$ 位置集合，然后贪心的删相邻的两个 $1$，匹配集合中和当前位置最近的 $1$ 位置即可</p>
<p>时间复杂度 $\mathcal O(n)$</p>
<ul>
<li>C</li>
</ul>
<p>考虑把所有操作分为三类：</p>
<ol>
<li><p>$a_i&gt;b_i$，这类操作不会影响到 $0$ 号位置</p>
</li>
<li><p>$a_i\le b_i$，且存在一个 $a_j&gt;b_j$ 的 $j$ 满足 $a_j-b_j\le a_i&lt; a_j$，这类操作同样不会影响到 $0$ 号位置</p>
</li>
<li><p>其他情况，这类操作会影响到 $0$ 号位置</p>
</li>
</ol>
<p>显然最优情况为一个后缀的三类操作通过一次调整（在 $a_i+1$ 处加一）变为二类操作；把一个二类&#x2F;三类操作通过 $b_i-a_i+1$ 次调整变为一类操作，此时 $i$ 之前的所有三类操作都会变为二类操作从而合法</p>
<p>时间复杂度 $\mathcal O(n)$</p>
<ul>
<li>D</li>
</ul>
<p>钦定序列最小值在 $i$ 处取到（如果有多个最小值则取最前面的那个）</p>
<p>假设当前序列全 $0$，考虑如下操作：</p>
<ol>
<li><p>选 $j&lt;i$，将 $a_j$ 加 $1$，$a_{j-1}$ 加 $2$，$\dots$，$a_1$ 加 $j$</p>
</li>
<li><p>选 $j&gt;i$，将 $a_j$ 加 $1$，$a_{j+2}$ 加 $2$，$\dots$，$a_n$ 加 $n-j+1$</p>
</li>
<li><p>将所有 $a$ 都加 $1$</p>
</li>
</ol>
<p>其中操作一至少要选一次 $j-1$</p>
<p>则不难发现通过这个操作构造出来的序列一定满足题目条件，且所有最小值在 $i$ 处取到的序列都能通过这些操作构造出来</p>
<p>这样就可以把题目转化为有一些权值为 $n$，$\frac{k(k+1)}2$ 的物品做完全背包，求最终总重为 $m$ 的方案数</p>
<p>有意义的物品数为 $\mathcal O(\sqrt m)$ 个，所以一次背包转移为 $\mathcal O(\sqrt m)$</p>
<p>最小值从 $i$ 变到 $i+1$ 相当于从背包里删一个物品再加一个物品，所以总共需要从背包里删&#x2F;加物品的次数为 $\mathcal O(n)$ 次</p>
<p>总复杂度 $\mathcal O(n\sqrt m)$</p>
<ul>
<li>E</li>
</ul>
<p>先考虑如何对于一个序列 ${a}$ 求答案</p>
<p>记 $p_i$ 为执行完所有操作二之后的 $a$ 序列，则操作一贡献为 $\sum|p_i-a_i|$，操作二贡献为 $\sum c\max{p_{i+1}-p_i,0}$</p>
<p>考虑 dp，记 $f_{i,j}$ 为考虑前 $i$ 个数，$p_i&#x3D;j$ 的最小代价</p>
<p>则 $f_{i,j}&#x3D;\min{f_{i-1,k}+c\max{j-k,0}+|j-a_i|}$，为了方便，我们记 $f_{0,j}&#x3D;cj$，最后答案即为 $f_{n+1,0}$</p>
<p>我们把 $f_i$ 画成折线，考虑归纳证明 $f_i$ 是下凸的</p>
<p>记 $f_{i-1}$ 的最小值在 $k$ 处取到，则对于所有 $j\le k$ 都有 $f_{i,j}\leftarrow f_{i-1,k}$</p>
<p>记 $f_{i-1,w+1}-f_{i-1,w}$ 在 $w$ 处第一次 $\ge c$，则对于所有 $j\ge w$ 都有 $f_{i,j}\leftarrow f_{i-1,w}$</p>
<p>其他的 $j$ 都有 $f_{i,j}\leftarrow f_{i-1,j}$</p>
<p>所以可以得到 $f_{i,j}-|j-a_i|$ 是下凸的，又 $|j-a_i|$ 是下凸的，所以 $f_i$ 是下凸的</p>
<p>考虑维护折线的端点，不难发现每次转移之前所有斜率都在 $[-1,c+1]$ 之间，每次转移先把斜率为 $-1$ 的一端变成斜率为 $0$，把斜率为 $c+1$ 的一端变成斜率为 $c$，最后把 $\le a_i$ 的地方斜率 $-1$，$\ge a_i$ 的地方斜率 $+1$</p>
<p>所以可以用一个可重集合来维护折线端点，初始时集合中有 $c$ 个 $0$，每次在集合中加入两个 $a_i$，表明 $a_i$ 处斜率变化为 $2$；然后取出集合中的最小值 $p$，代表斜率 $-1$ 结束的地方，也就是折线的最小值所在的位置，把 $a_i-p$ 加入答案，代表这次转移加入的 $|j-a_i|$ 使得折线最小值增加了 $a_i-p$；最后从集合中删除最小值和最大值，表明把斜率为 $-1$ 的一端变成斜率为 $0$，把斜率为 $c+1$ 的一端斜率变为 $c$</p>
<p>这样就可以在 $\mathcal O(n\log n)$ 的时间内解决单个序列的问题</p>
<p>回到原问题，考虑如何计数</p>
<p>显然直接计数不好做，考虑对于每个数 $x$ 计算 $F(x)$ 表示 $x$ 作为最小值从集合中删除了多少次</p>
<p>最小值恰好为 $x$ 可以通过差分变成计算最小值小于 $x$，所以可以把 $&lt;x$ 的数看做 $0$，$\ge x$ 的数看做 $1$，统计 $0$ 被作为最小值删除了多少次</p>
<p>显然如果集合中 $c+2$ 个数均为 $1$ 才是不合法的情况，所以可以设 $g_{i,j}$ 表示前 $i$ 个数，集合中有 $j$ 个 $1$ 的方案数，转移显然，最后拿总删除次数减去 $1$ 被删去的次数即可</p>
<p>时间复杂度 $\mathcal O(n^2k(k+c))$</p>
<ul>
<li>F</li>
</ul>
<p>记 $L&#x3D;2\times 10^5$ 为值域，显然所有 $a_i$ 的取值都在 $[0,L]$ 之间</p>
<p>首先令所有 $p_i&#x3D;0$，然后通过操作调整 $p$ 使得 $p$ 作为答案序列合法且代价最小</p>
<p>若 $p_i&#x3D;k$，使 $p_i$ 变为 $k+1$ 的代价为 $c_i(-2(a_i-k)+1)$，我们用二元组 $(i,k)$ 代表进行此操作，显然进行完 $(i,k)$ 操作之后才能进行 $(i,k+1)$ 操作</p>
<p>记 $g(x)&#x3D;\sum|b_i-x|-\sum|p_i-x|$，则题目条件等价于对于任意 $x\in[0,L]$ 有 $g(x)\ge 0$</p>
<p>将 $p_i$ 从 $k$ 变为 $k+1$ 的效果为使所有 $x\in [0,k]$ 的 $g(x)$ 减去 $1$，所有 $x\in (k,L]$ 的 $g(x)$ 加上 $1$，那么显然 $k$ 越大对于 $g$ 的正贡献越小，负贡献越大；又 $k$ 越大 $(i,k)$ 操作的代价越大，所以 $(i,k+1)$ 比 $(i,k)$ 先操作一定不优，所以不用特别限制 $(i,k)$ 要在 $(i,k+1)$ 前面操作</p>
<p>那么问题就变成了有若干形如 $(i,k)$ 的操作，每个操作有一个代价，作用是使 $[0,k]$ 中的 $g(x)$ 减去 $1$，$(k,L]$ 中的 $g(x)$ 加上 $1$，所有要求在所有 $g(x)\ge 0$ 的情况下代价最小</p>
<p>不妨对于每个 $x\in[0,L]$ 考虑操作应该满足什么条件才能使 $g(x)\ge 0$</p>
<p>记 $g_0(x)&#x3D;\sum|b_i-x|-\sum|0-x|$，即初始状态下 $g(x)$ 的取值</p>
<p>记 $f_k$ 为形如 $(i,k)$ 的操作进行的次数，则 $g(x)&#x3D;g_0(x)+\sum\limits_{i&#x3D;0}^{x-1}f_i-\sum\limits_{i&#x3D;x}^Lf_i\ge0$</p>
<p>记 $sum&#x3D;\sum f_i$，则 $g_0(x)+sum-2\sum\limits_{i&#x3D;x}^Lf_i\ge 0\Leftrightarrow \sum\limits_{i&#x3D;x}^Lf_i\le\lfloor\frac{g_0(x)+sum}{2}\rfloor$</p>
<p>带入 $x&#x3D;0$，可得 $sum\le g_0(0)$，带入 $x&#x3D;L+1$ 可得 $sum\ge g_0(L+1)&#x3D;g_0(0)$</p>
<p>所以 $sum&#x3D;g_0(0)&#x3D;\sum b_i$，那么 $\sum\limits_{i&#x3D;x}^Lf_i$ 的上界就确定了，记其为 $lmt_x$</p>
<p>那么就可以得到一个朴素的做法：</p>
<p>维护一个堆，从后往前枚举 $x$，把所有形如 $(i,x)$ 的操作加入堆中，不断删除堆中代价最大的操作使得堆中元素个数 $\le lmt_x$</p>
<p>这样做的时间复杂度为 $\mathcal O(nL\log nL)$，需要优化</p>
<p>记 $c_i$ 值域为 $m&#x3D;5$</p>
<p>记当前堆中最大操作代价为 $mx$，堆大小为 $sz$</p>
<p>对于所有 $i\le mx$，记 $del_i$ 为代价为 $i$ 的操作被删除的次数</p>
<p>记 $C_{i,k}$ 为 $(i,k)$ 操作的代价，$f(k,v)&#x3D;\sum [C_{i,k}&#x3D;v]$</p>
<p>枚举到 $x$ 时，先加入所有代价 $\le mx$ 的 $(i,x)$ 操作，即把 $sz$ 加上 $\sum\limits_{i\le v}f(x,v)$，然后分类讨论：</p>
<ol>
<li><p>若 $sz&gt;lmt_x$，则考虑计算堆中代价为 $mx$ 的操作个数，即 $\sum\limits_{i\ge x}f(i,mx)-del_{mx}$，若其 $&gt; sz-lmt_x$，则删除 $sz-lmt_x$ 个 $mx$，否则把 $mx$ 全部删完，并把 $mx$ 减去 $1$</p>
</li>
<li><p>若 $sz&lt;lmt_x$，则把 $mx$ 加上 $1$，加入的操作个数为 $f(x,mx)$，并把 $del_{mx}$ 设置为 $\sum\limits_{i&gt;x}f(i,mx)$，若 $f(x,mx)&gt;lmt_x-sz$，则删除一些值为 $mx$ 的操作使得最后 $sz&#x3D;lmt_x$</p>
</li>
</ol>
<p>在预处理 $sum_{i,j}$ 表示 $c_k&#x3D;i$，$a_k\le j$ 的 $k$ 的个数之后，就可以在 $\mathcal O(m)$ 的时间内求出 $f(x,v)$ 关于 $v$ 的前缀和和关于 $x$ 的后缀和</p>
<p>记 $mx$ 的变化次数为 $T$，则总复杂度为 $\mathcal O(mT)$</p>
<p>下证 $T$ 为 $\mathcal O(mL)$ 级别</p>
<p>记 $mx_k$ 为 $x&#x3D;k$ 时的 $mx$，$\Delta_k&#x3D;lmt_k-lmt_{k+1}$</p>
<p>记 $f_k$ 为 $(i,k)$ 操作中代价第 $\Delta_k$ 小的，$g_{k}$ 为 $(i,k)$ 操作中代价第 $\Delta_{k+1}$ 小的</p>
<p>不难发现 $|mx_k-mx_{k+1}|\le |f_k-f_{k+1}|$ 对于任意 $k$ 成立</p>
<p>所以只需证 $\sum |f_k-f_{k+1}|$ 为 $\mathcal O(mL)$ 级别即可</p>
<p>由于 $\Delta_k$ 大约和 $\frac{g_0(k)-g_0(k+1)}2$ 相等，所以有 $\Delta_k\ge \Delta_{k+1}$，且 $0\le \Delta_k\le n$</p>
<p>考虑 $(i,k-1)$ 和 $(i,k)$ 两组操作，则有后面那组操作的代价为前面那组操作的代价加上 $2c_i$</p>
<p>不难发现 $f_k-2m\le g_{k-1}$，又 $\Delta_{k-1}\ge \Delta_k$，则 $g_{k-1}\le f_{k-1}$，则有 $f_{k}-f_{k-1}\le 2m$</p>
<p>又对于任意 $k$ 有 $|f_k|\le mL$ 成立，可推得 $\sum|f_{k}-f_{k-1}|$ 为 $\mathcal O(mL)$ 级别</p>
<p>所以总复杂度 $\mathcal O(m^2L)$</p>
<h3 id="AGC050"><a href="#AGC050" class="headerlink" title="AGC050"></a>AGC050</h3><ul>
<li>A</li>
</ul>
<p>考虑在模 $n$ 意义下连接 $i\to 2i,i\to 2i+1$</p>
<p>则一个数  $i$ 在 $10$ 步内可以走到 $2^{10}i+k$，其中 $k\in [0,2^{10})$，在模 $n$ 意义下覆盖了所有数</p>
<p>时间复杂度 $\mathcal O(n)$</p>
<ul>
<li>B</li>
</ul>
<p>考虑区间 dp，记 $f_{l,r,0&#x2F;1}$ 为只考虑区间 $[l,r]$ 一开始全不选&#x2F;选的最大值</p>
<p>对于 $f_{l,r,0}$，考虑 $r$ 变不变，若不变则 $f_{l,r,0}\leftarrow f_{l,r-1,0}$，否则 $f_{l,r,0}\leftarrow f_{l,k,0}+f_{k+1,r,1}$，其中 $[k+1,r]$ 的长度为 $3$ 的倍数；对于 $f_{l,r,1}$ 同理</p>
<p>最后如果 $[l,r]$ 长度为 $3$ 的倍数，则 $f_{l,r,0}&#x3D;f_{l,r,1}&#x3D;\max{f_{l,r,0},f_{l,r,1}}$</p>
<p>时间复杂度 $\mathcal O(n^3)$</p>
<ul>
<li>C</li>
</ul>
<p>从后往前考虑每一个操作序列</p>
<p>不难发现若第 $i$ 段连续的操作 <code>BSS..S</code> 中 <code>S</code> 的个数 $\ge 2^{i-2}$（若 $i&#x3D;1$ 则没有限制）则 <code>S</code> 必胜</p>
<p>所以记 $f_{i,j}$ 为考虑区间 $[i,n]$，当前段为第 $j$ 段，<code>S</code> 必胜的方案数</p>
<p>时间复杂度 $\mathcal O(n\log n)$</p>
<ul>
<li>D</li>
</ul>
<p>记 $g_{t,i,j,k}$ 为 $t$ 拿了 $i$ 次糖果，总共还剩 $j$ 个糖果，$[1,t)$ 中还剩 $k$ 个人没拿到糖果且 $t$ 没拿到糖果的概率</p>
<p>记 $f_{w,i,j,k}$ 为 $i$ 个人，每人之前都拿了 $w$ 次糖果，在这 $i$ 个人拿之前还有 $j$ 个糖果，拿之后还有 $k$ 个糖果的概率</p>
<p>先用预处理出来 $f$，然后用 $f$ 转移 $g$ 即可，转移显然</p>
<p>时间复杂度 $\mathcal O(n^5)$</p>
<ul>
<li>E</li>
</ul>
<p>记 $l_i&#x3D;g_i+r_i$，$L&#x3D;\operatorname{lcm}(l_1,l_2,l_3)$，则路灯经过 $L$ 单位时间会循环一次，我们只用考虑计算一次循环的答案，最后乘上 $\frac TL$ 即可</p>
<p>称六元组 $(m_1,x_1,m_2,x_2,m_3,x_3)$ 合法当且仅当存在时间 $t$ 满足 $t\equiv x_i\pmod {m_i}$</p>
<p>记 $f_p(x)$ 为质因子 $p$ 在 $x$ 中出现的次数</p>
<p>性质 1：若存在 $p|m_1\land p\not|m_2\land p\not|m_3$，则 $(m_1,x_1,m_2,x_2,m_3,x_3)$ 合法与 $(\frac{m_1}{p^k},x_1,m_2,x_2,m_3,x_3)$ 等价（其中 $k\le f_p(m_1)$）</p>
<p>证明：对于原六元组的合法时间 $t_0$，容易得到 $t_0\equiv x_1\pmod {m_1}\Rightarrow t_0\equiv x_1\pmod {\frac{m_1}{p^k}}$，即新六元组合法</p>
<p>对于新六元组的合法时间 $t_1$，容易得到 $t_1\equiv x_1\pmod {\frac{m_1}{p^k}}$，取 $t_1&#x3D;x_1+p^k\frac{m_1}{p^k}$ 即可满足 $t_1\equiv x_1\pmod{m_1}$，即原六元组合法</p>
<p>性质 2：若存在 $p|m_1\land p|m_2$ 且 $k_1\le k_2$（其中 $k_1&#x3D;f_p(m_1),k_2&#x3D;f_p(m_2)$），则 $(m_1,x_1,m_2,x_2,m_3,x_3)$ 合法与 $(\frac{m_1}{p^{k_1}},x_1,m_2,x_2,m_3,x_3)$ 合法且 $x_1\equiv x_2\pmod {p^{k_1}}$ 等价</p>
<p>证明：若原六元组合法，则显然要求 $x_1\equiv x_2\pmod {p^{k_1}}$</p>
<p>对于原六元组的合法时间 $t_0$，容易得到 $t_0\equiv x_1\pmod {m_1}\Rightarrow t_0\equiv x_1\pmod {\frac{m_1}{p^{k_1}}}$，即新六元组合法</p>
<p>对于新六元组的合法时间 $t_1$，容易得到 $t_1\equiv x_1\pmod {\frac{m_1}{p^{k_1}}}$，由于 $\gcd(p^{k_1},\frac{m_1}{p^{k_1}})&#x3D;1$，可得一定存在满足条件的 $t_1$ 使得 $t_1\equiv x_1\pmod{p^{k_1}}$，此时一定有 $t_1\equiv x_1\pmod {m_1}$，即原六元组合法</p>
<p>但是性质 2 中 $x_1\equiv x_2\pmod {p^{k_1}}$ 的限制太麻烦了，考虑把它去掉</p>
<p>性质 3：若存在 $p$ 使得 $k_1&gt;\max{k_2,k_3}$（其中 $k_i&#x3D;f_p(m_i)$），则 $(m_1,x_1,m_2,x_2,m_3,x_3)$ 合法与 $(\frac{m_1}{p^{k_1-\max{k_2,k_3}}},x_1,m_2,x_2,m_3,x_3)$ 合法等价</p>
<p>证明：由性质 2 可得 $(m_1,x_1,m_2,x_2,m_3,x_3)$ 合法与 $(m_1,x_1,\frac{m_2}{p^{k_2}},x_2,\frac{m_3}{p^{k_3}},x_3)$ 合法且 $x_1\equiv x_2\pmod {p^{k_2}}\land x_1\equiv x_3\pmod{p^{k_3}}$ 等价</p>
<p>由性质 1 可得 $(m_1,x_1,\frac{m_2}{p^{k_2}},x_2,\frac{m_3}{p^{k_3}},x_3)$ 合法与 $(\frac{m_1}{p^{k_1-\max{k_2,k_3}}},x_1,\frac{m_2}{p^{k_2}},x_2,\frac{m_3}{p^{k_3}},x_3)$ 合法等价</p>
<p>逆用一下性质 2 可得 $(\frac{m_1}{p^{k_1-\max{k_2,k_3}}},x_1,\frac{m_2}{p^{k_2}},x_2,\frac{m_3}{p^{k_3}},x_3)$ 合法且 $x_1\equiv x_2\pmod {p^{k_2}}\land x_1\equiv x_3\pmod{p^{k_3}}$ 与 $(\frac{m_1}{p^{k_1-\max{k_2,k_3}}},x_1,m_2,x_2,m_3,x_3)$ 合法等价</p>
<p>回到原题，考虑计算合法六元组 $(l_1,x_1,l_2,x_2,l_3,x_3)$ 的数量</p>
<p>先根据性质 3 调整一下 $l_1,l_2,l_3$，调整之后一定有 $l_1&#x3D;gab,l_2&#x3D;gac,l_3&#x3D;gbc$，不妨设 $l_1\le l_2\le l_3$，记 $n&#x3D;gabc$</p>
<p>由于一个合法六元组和一个在 $[0,L)$ 中的时间一一对应，则考虑枚举这个时间</p>
<p>容易发现答案等于这一个式子：$\sum\limits_{t\in [0,n)}\prod\limits_{i&#x3D;1}^3\sum\limits_{t\equiv j\pmod {l_i}\land j\in[0,g_i)}1$</p>
<p>化简一下可得： $\sum\limits_{t\in [0,n)}\prod\limits_{i&#x3D;1}^3(\lfloor\frac{g_i}{l_i}\rfloor+[t\bmod l_i&lt; g_i\bmod l_i])$</p>
<p>把后面的连乘展开成 $8$ 项相加，其中 $\lfloor \frac{g_i}{l_i}\rfloor$ 容易处理，主要是处理 $[t\bmod l_i&lt;g_i\bmod l_i]$</p>
<p>考虑对于 $l_2,l_3$ 在 $[0,n)$ 中枚举符合 $[t\bmod l_i&lt;g_i\bmod l_i]$ 的区间，容易发现有 $\mathcal O(a+b)$ 个区间；同样地，它们的并也有 $\mathcal O(a+b)$ 个区间</p>
<p>考虑暴力枚举这些区间，即可算出最终的答案</p>
<p>记值域为 $w$，则 $a\le b\le \sqrt{bc}\le\sqrt{l_3}\le \sqrt w$，所以总复杂度 $\mathcal O(\sqrt w)$</p>
<ul>
<li>F</li>
</ul>
<p>下文中「答案」指计数的答案，「结果」指操作结束后剩下的数</p>
<p>由于答案对 $2$ 取模，所以考虑如何变换操作序列不影响结果</p>
<p>不妨设 $n$ 为奇数（否则先枚举第一次操作哪一条边）</p>
<p>此时操作序列长为 $n-1$，为偶数，考虑把操作 $2i-1$ 和操作 $2i$ 分一组</p>
<p>不难发现若这两个操作不存在公共点则显然交换这两个操作不影响结果</p>
<p>考虑这两个操作操作了形如 <code>u-v-w</code> 的链，则不难发现若 $c_u&#x3D;c_w$ 则交换这两个操作仍然不影响结果</p>
<p>否则无论 $c_v$ 取什么值，交换这两个操作一定会使结果取反 </p>
<p>考虑一棵操作了若干次的数，称权值可以为 $0$ 也可以为 $1$ 的点为特殊点，其他点为非特殊点</p>
<p>操作 $2i-1$ 和 $2i$ 可以看做把一条 <code>u-v-w</code> 的链合并为一个特殊点，题意可以转换为求合并点的方案数，考虑合并时对于 $u,v,w$ 的限制</p>
<p>若 $v$ 为特殊点，则显然这个操作对答案没有贡献，因为 $c_v&#x3D;0$ 和 $c_v&#x3D;1$ 产生的结果正好可以在模 $2$ 意义下抵消；同样地，若 $u$ 和 $v$ 均为特殊点，则这个操作对答案也不会产生贡献</p>
<p>所以不难发现特殊点的个数单调不降，而最后只剩一个点，所以所有的合并操作的链都有公共端点</p>
<p>现在对于合并操作的操作序列可以描述为：选择一个点 $c_u&#x3D;1$ 作为根，每次选择的链必须形如 <code>u-v-w</code>，另外第一次操作时 $c_w&#x3D;0$</p>
<p>考虑在以 $u$ 为根时把每条边看做从父亲到儿子的有向边，并且拓扑排序，记拓扑序列为 ${a}$，则要求 $c_{a_3}&#x3D;0$ 且 $a_{2i}$ 为 $a_{2i+1}$ 的父亲</p>
<p>实际上这两个要求都不需要考虑，因为若 $c_{a_3}&#x3D;1$，则一定会在 $u&#x3D;a_3$ 时再统计一遍，相当于在模 $2$ 意义下抵消掉；若 $a_{2i}$ 不为 $a_{2i+1}$ 的父亲，则交换这两项一定还是个合法的拓扑序列，也会在模 $2$ 意义下抵消掉</p>
<p>所以统计以 $u$ 为根的树的拓扑序个数即可，为 $\frac{n!}{\prod sz_i}$</p>
<p>时间复杂度 $\mathcal O(n^3)$</p>
<h3 id="AGC051"><a href="#AGC051" class="headerlink" title="AGC051"></a>AGC051</h3><ul>
<li>A</li>
</ul>
<p>考虑从外向里填图形</p>
<p>显然十二边形的一条边中只能全填正三角形&#x2F;正方形，一个角上只能是一个正三角形和一个正方形</p>
<p>而一条边填正方形时边长不变，填正三角形时边长减一</p>
<p>于是一条边要填 $d$ 次正方形和 $d$ 次正三角形，答案即为 $\binom{2d-1}{d-1}$</p>
<p>时间复杂度 $\mathcal O(d)$</p>
<ul>
<li>B</li>
</ul>
<p>考虑这样的三个向量：$\overrightarrow{a}&#x3D;(1,0),\overrightarrow{b}&#x3D;(0,10),\overrightarrow{c}&#x3D;(100,100)$</p>
<p>构造一个点集：${(x,y)|(x,y)&#x3D;i\overrightarrow{a}+j\overrightarrow{b}+k\overrightarrow{c},i,j,k\in[0,10)}$</p>
<p>此时从 ABC 三个方向看只能看到 $100$ 个点，从 D 方向看能看到 $1000$ 个点，符合题意</p>
<ul>
<li>C</li>
</ul>
<p>考虑每次操作中不变的量有哪些</p>
<p>记 $p_y&#x3D;\oplus a_{x,y},q_{x,i}&#x3D;\oplus_{y\equiv i\pmod 3} a_{x,y}$，不难发现操作对 $p_y$ 没有影响，而一次操作会使一个 $q_x$ 全部取反</p>
<p>考虑什么样的矩阵 $b$ 能由 $a$ 通过若干次操作得到</p>
<p>显然有一个必要条件：$p_{a,y}&#x3D;p_{b,y}\land q_{a,x,0}\oplus q_{b,x,0}&#x3D;q_{a,x,1}\oplus q_{b,x,1}&#x3D;q_{a,x,2}\oplus q_{b,x,2}$，下证这个条件充分</p>
<p>由于操作可逆，考虑证明能否把 $a$ 和 $b$ 同时通过若干次操作变到一个相同的中间状态</p>
<p>考虑每次找出一个仍为 $1$ 且 $x\ge 2,y\ge 3$ 的点中 $x$ 最大的点（如果有多个满足条件的点则选其中 $y$ 最大的点），然后操作 $(x-1,y-2)$</p>
<p>现在只需证操作后的 $a$ 矩阵和 $b$ 矩阵相等</p>
<ol>
<li><p>若 $x\ge 2,y\ge 3$，此时 $a_{x,y}&#x3D;b_{x,y}&#x3D;0$，否则还可以继续操作</p>
</li>
<li><p>若 $x&#x3D;2,y&lt;3$，此时由 $a_{2,i}&#x3D;b_{2,i}&#x3D;0(i\ge 3)$ 可得 $q_{a,2,0}&#x3D;q_{b,2,0}\Rightarrow q_{a,2,i}&#x3D;q_{b,2,i}(0\le i&lt;3)$ 且 $a_{2,i}&#x3D;q_{a,2,i},b_{2,i}&#x3D;q_{b,2,i}(i&#x3D;1,2)$，可以推出 $a_{2,1}&#x3D;b_{2,1},a_{2,2}&#x3D;b_{2,2}$</p>
</li>
<li><p>若 $x&#x3D;1$，此时因为 $a$ 矩阵和 $b$ 矩阵其他行的值都相等，所以可以通过 $p_y$ 相等推出 $a_{1,y}&#x3D;b_{1,y}$</p>
</li>
</ol>
<p>回到原问题，先考虑确定 $q$ 的值时答案是多少</p>
<p>此时要求对于任意 $i\in[0,3)$ 有 $\sum\limits_{y\equiv i\pmod 3}p_y\equiv \sum q_{x,i}\pmod 2$</p>
<p>显然答案有一个下界 $\sum\limits_{i&#x3D;0}^2\max{\sum\limits_{y\equiv i\pmod 3}p_y,\sum q_{x,i}}$，接下来尝试构造来达到这个下界</p>
<p>对于一个 $(x,y)$，若 $p_y&#x3D;q_{x,i}&#x3D;1$，则在这个点放一个 $1$ 即可满足这两个条件；对于剩下没有满足的 $p_y$ 和 $q_{x,i}$，在 $(\inf,y)$ 和 $(x,\inf)$ 处放一个 $1$，由于剩下没满足的行&#x2F;列为偶数个，所以不会影响 $\inf$ 行&#x2F;列的 $p$ 和 $q$</p>
<p>考虑维护三元组 $(\sum\limits_{y\equiv 0\pmod 3}p_y-\sum q_{x,0},\sum\limits_{y\equiv 1\pmod 3}p_y-\sum q_{x,1},\sum\limits_{y\equiv 2\pmod 3}p_y-\sum q_{x,2})$</p>
<p>最开始把每个 $q_x$ 都调整为只有一个位置是 $1$（三个都是 $0$ 和三个都是 $1$ 可以不管）</p>
<p>每次操作即把三元组一个位置减去 $1$，另外两个位置加上 $1$</p>
<p>显然每次操作都要让三元组中最大的那个减去 $1$，而操作过程中答案的值一定是单谷的，所以操作之后不能变得更优时退出循环即可，最后如果奇偶性不对就再操作一次</p>
<p>时间复杂度 $\mathcal O(n)$</p>
<ul>
<li>D</li>
</ul>
<p>先把一个路径写成一个序列，记 <code>S-T</code> 为 <code>A</code>，<code>T-U</code> 为 <code>B</code>，<code>U-V</code> 为 <code>C</code>，<code>V-S</code> 为 <code>D</code></p>
<p>考虑一条 <code>S</code> 出发终点为 <code>S</code> 且中途不经过 <code>S</code> 的路径</p>
<p>显然这条路径只有三种情况：<code>A...A</code>，<code>A...D</code>，<code>D...D</code></p>
<p>不妨考虑 <code>A...A</code> 且中间有 $2x+2$ 个 <code>B</code> 和 $2y$ 个 <code>C</code> 的情况，此时一定有两个 <code>B</code> 在 <code>A</code> 旁边，所有的 <code>AB</code>，<code>BA</code> 和 <code>BB</code> 把序列分成 $x+1$ 段，这 $x+1$ 段中要放入 $y$ 组 <code>CC</code>，方案数为 $\binom{x+y}{x}$</p>
<p>同样地，<code>A...D</code> 且中间有 $2x$ 个 <code>B</code> 和 $2y$ 个 <code>C</code>，<code>D...D</code> 且中间有 $2x$ 个 <code>B</code> 和 $2y+2$ 个 <code>C</code> 的方案数也均为 $\binom{x+y}x$</p>
<p>这个过程提示我们把路径序列相邻两个分为一组，考虑去掉 <code>AA</code>，<code>BB</code>，<code>CC</code> 和 <code>DD</code> 组，剩下只有 <code>AB</code>，<code>BA</code>，<code>CD</code> 和 <code>DC</code>，而 <code>AB</code> 和 <code>BA</code> 是等价的，<code>CD</code> 和 <code>DC</code> 也是等价的（奇数组一定是 <code>AB</code> 或 <code>DC</code>；偶数组一定是 <code>BA</code> 或 <code>CD</code>）</p>
<p>于是考虑枚举 <code>AB</code> 的组数 $n$，<code>CD</code> 的组数 $m$，这样只有 <code>AB</code>，<code>BA</code>，<code>CD</code> 和 <code>DC</code> 组组成的序列个数为 $\binom{n+m}n$</p>
<p>接下来考虑向其中插入 <code>AA</code> 和 <code>DD</code> 组，而插入之前的序列中相邻两组作为一个整体不能分开，所以方案数为 $\binom{\frac{n+m}{2}+\frac{a-n}2}{\frac{a-n}2}\binom{\frac{n+m}2+\frac{a-n}2+\frac{b-m}2}{\frac{b-m}2}$</p>
<p>最后向其中插入 <code>BB</code> 和 <code>CC</code> 组，而这些组只能在相邻的 <code>AB</code>，<code>BA</code>，<code>CD</code>，<code>DC</code> 组之间，所以方案数为 $\binom{\frac{n+m}2-1+\frac{b-n}2}{\frac{b-n}2}\binom{\frac{n+m}2-1+\frac{b-n}2+\frac{c-m}2}{\frac{c-m}2}$</p>
<p>最后化简以后的式子是一个卷积的形式，可以用 NTT 优化，时间复杂度 $\mathcal O(n\log n)$</p>
<ul>
<li>E</li>
</ul>
<p>把所有点看做向量 $\overrightarrow{p_i}$ ，那么一个合法的点 $\overrightarrow{P}$ 可以表示成如下的形式：</p>
<blockquote>
<p>$\overrightarrow{P}&#x3D;\sum w_i\overrightarrow{p_i}$，其中 $\sum w_i&#x3D;1,w_i\ge 0$，且 $w_i$ 为分母为 $2$ 的幂的有理数</p>
</blockquote>
<p>不难发现合法的点 $P$ 必然在 $p_i$ 组成的凸包内&#x2F;上，而凸包内&#x2F;上的 $P$ 一定存在一组 $w_i\ge 0$ 的解，所以可以忽略这个条件（可以使用调整法证明）</p>
<p>凸包上的点好处理，接下来考虑凸包内的点</p>
<p>先考虑整数的情况，即要求 $\sum w_i&#x3D;1$ 且 $w_i\in\mathbb Z$</p>
<p>此时考虑找出两个向量 $\overrightarrow{A},\overrightarrow{B}$，使得所有合法的 $\overrightarrow{P}$ 都可以表示为 $n\overrightarrow{A}+m\overrightarrow{B}$</p>
<p>不妨先考虑只有三个向量 $\overrightarrow{p_1},\overrightarrow{p_2},\overrightarrow{p_3}$ 的情况，此时一定可以找到 $|\overrightarrow{p_i}\pm \overrightarrow{p_j}|&lt;|\overrightarrow{p_i}|$ 的情况，把 $\overrightarrow{p_i}$ 变为 $\overrightarrow{p_i}\pm \overrightarrow{p_j}$，覆盖的 $\overrightarrow{P}$ 集合不变，而 $|\overrightarrow{p_i}|$ 变小，所以一定可以在有限步内把三个向量消成两个向量</p>
<p>加速这个过程，我们可以找 $|\overrightarrow{p_i}+k\overrightarrow{p_j}|&lt;|\overrightarrow{p_i}|$ 且 $|\overrightarrow{p_i}+k\overrightarrow{p_j}|$ 最小的向量进行替换，这样这个过程最多会进行 $\mathcal O(\log L)$ 次（$L$ 为值域）（不太会证，可以理解（</p>
<p>此时我们得到了 $\overrightarrow{A}$ 和 $\overrightarrow{B}$，此时把所有 $\overrightarrow{p_i}$ 分解为 $s_i\overrightarrow{A}+t_i\overrightarrow{B}$ 的形式，并把 $p_i$ 的坐标看做 $(s_i,t_i)$</p>
<p>不难发现这时的 $p_i$ 组成的凸包内的所有点都可以满足 $\sum w_i&#x3D;1$ 且 $w_i\in \mathbb Z$</p>
<p>而原问题中要求 $w_i$ 分母为 $2$ 的幂，考虑不断把 $\overrightarrow{A}$ 和 $\overrightarrow{B}$ 除上 $2$，直到不能再除为止，此时的 $(s_i,t_i)$ 凸包内的所有点就都可以满足 $\sum w_i&#x3D;1$ 且 $w_i$ 分母为 $2$ 的幂了</p>
<p>统计凸包内点的个数可以用皮克定理</p>
<p>时间复杂度 $\mathcal O(n\log L)$，实现的时候找 $k$ 尽量用 $\mathcal O(1)$ 的写法</p>
<ul>
<li>F</li>
</ul>
<p>（用一些官方题解的图）</p>
<p>考虑建系，以沙漏 $A$ 中上半部分含沙量为 $x$ 轴，沙漏 $B$ 中上半部分含沙量为 $y$ 轴</p>
<p>那么原问题可以看做从顶点 $A$ 出发沿着八个方向的任意一个方向走，碰到边框之后可以改变方向</p>
<p><img src="https://img.atcoder.jp/agc051/71818d155faf01fd3d1684a7bb88c17e.png"></p>
<p>不难发现四个顶点是等价的，所以我们可以把去往顶点的操作看成去往 $A$ 点</p>
<p>从 $A$ 出发有三种走法，分别是走到 $B$ 走到 $D$ 和走到 $E$，显然走到 $B$ 和 $D$ 可以看做停留在 $A$ 点并把时间加上 $1$ 或者 $\sqrt 2$，所以只需要考虑走到 $E$ 的情况</p>
<p>走到 $E$ 之后有五种走法，其中沿虚线向左走可以不用考虑（走到的点和 $E$ 等价，可以看做停在原地把时间加上 $1$），而走到 $A$ 又与走到 $B$ 等价，所以实际上只需要考虑走到 $F$，走到 $B$ 和走到 $C$</p>
<p>所以不难发现每次都可以看做从 $A$ 开始沿着 $A\to E\to F\to G\to H\to\dots$ 走，直到走到一个点之后走向一个顶点</p>
<p>不妨把走到这些点最短所需要的时间画在一根数轴上：</p>
<p><img src="https://img.atcoder.jp/agc051/abbe8b1ab54a58fc6005fcb8c73d4261.png"></p>
<p>那么一次从 $A$ 开始走的路径可以看做在数轴上任意走，走到一个点之后再用 $0$ 的时间跳回 $A$</p>
<p>而在数轴上任意走到一个端点可以看做是从 $A$ 开始直接走到最远点再直接走到终点，中间加上若干段走了偶数次的小段</p>
<p><img src="https://img.atcoder.jp/agc051/2d2147ada5ac09f277fd0688a67f3772.png"></p>
<p>不妨设最远点在 $q$，终点在 $p$，则最终时间即为 $T&#x3D;2x_q-x_p+2\sum c_i(x_{i+1}-x_i)+s+t\sqrt 2$，其中 $c_i,s,t$ 均为系数</p>
<p>先考虑确定 $p,q$，怎么判断一个时间是否可行，现在的问题即为中间的 $\sum c_i(x_{i+1}-x_i)$ 能取哪些值</p>
<p>考虑再建立一个坐标系，点 $(x,y)$ 表示 $x+y\sqrt 2$，画一条线 $x+y\sqrt 2&#x3D;0$</p>
<p><img src="https://img.atcoder.jp/agc051/b8267b175e5261a237d23c233c86ee6d.png"></p>
<p>若此时最远点为 $q$，则不难发现 $x&#x3D;x_q,y\sqrt2&#x3D;x_q,x+y\sqrt2&#x3D;0$ 三条直线围成的三角形中的整点一定可以被数轴上若干条线段表示出来</p>
<p>在这个三角形的二四象限中找到两个最靠近 $x+y\sqrt 2$ 点（即图中圈出的两个点），从原点分别向这两个点连一条射线，则射线上方的所有点都可以被表示出来</p>
<p><img src="https://img.atcoder.jp/agc051/f3c08bc39531e4cd1258b577ee5d9ebd.png"></p>
<p>此时若确定了 $p,q$，那么 $s,t$ 显然越小越好，所以只需要 $s,t\in[0,1]$ 即可（用来调奇偶性），接下来只需要判断 $\frac{T-2z_q+z_p-s-t\sqrt 2}2$ 是否在两条射线上方即可</p>
<p>考虑到在两条射线确定的情况下 $q$ 越小越好，$p$ 越大越好，而不同的射线只有 $\log w$ 条（考虑用 stern-brocot 树无限逼近 $\sqrt 2$），其中 $w$ 为值域</p>
<p>那么就考虑确定这两条射线的位置，$q$ 取满足射线是这两条时的最小值，$p$ 取最靠近 $p$ 的 $k\sqrt 2$ 点和 $k$ 点，然后判断这个点是否在射线上方即可</p>
<p>时间复杂度 $\mathcal O(Q\log w)$ </p>
<h3 id="AGC052"><a href="#AGC052" class="headerlink" title="AGC052"></a>AGC052</h3><ul>
<li>A</li>
</ul>
<p>不难发现 $n$ 个 $0$，$n$ 个 $1$，最后再加一个 $0$ 一定符合条件</p>
<ul>
<li>B</li>
</ul>
<p>NOIp2022 T3 的套路搬上树了（</p>
<p>考虑新建一个根节点向任意一个点连边，边权为 $0$</p>
<p>每次操作的时候这条边的边权会改变，但是这条边不被操作</p>
<p>记 $d_u$ 为 $u$ 节点到根节点的路径上所有边权的异或和，不难发现操作一条边 $(u,v)$ 的效果为交换 $d_u$ 和 $d_v$</p>
<p>那么原问题就变成了给定两个数组 $a,b$，问存不存一个数 $w$ 使得 ${a_i}$ 是 ${b_i\operatorname{xor}w}$ 的排列</p>
<p>由于 $n$ 为奇数，所以可以把所有 $a$ 和 $b$ 异或起来确定 $w$，之后排个序判断即可</p>
<p>时间复杂度 $\mathcal O(n\log n)$</p>
<ul>
<li>C</li>
</ul>
<p>考虑一个序列 $a$ 什么时候合法</p>
<p>显然序列的和不能是 $p$ 的倍数，接下来考虑和不是 $p$ 的倍数的情况</p>
<p>不妨设序列的众数为 $1$（如果众数是 $x$ 则把序列整体乘上 $x^{-1}$，把众数变成 $1$）</p>
<p>记序列 $b$ 为序列 $a$ 除去 $1$ 所得的序列，则序列 $a$ 合法当且仅当 $1$ 的个数 $\le p-1+\sum p-b_i$</p>
<p>证明：先证必要性，假设 $1$ 的个数 $\ge p+1+\sum p-b_i$，则序列和至少为 $p(k+1)+1$，其中 $k$ 为 $b$ 的长度</p>
<p>考虑到每次序列经过 $p$ 的倍数时都需要一个 $&gt;1$ 的数，此时至少需要经过 $k+1$ 次 $p$ 的倍数，而 $&gt;1$ 的数只有 $k$ 个，矛盾</p>
<p>下证充分性，考虑按照如下方法给序列重新排序：</p>
<blockquote>
<p>记此时序列中剩下的数的众数为 $x$，此时已经排好的序列和为 $sum$，若 $sum+x$ 不为 $p$ 的倍数，则把 $x$ 加入序列，否则在剩下的数中任取一个不为 $x$ 的数 $y$，把 $y,x$ 依次加入序列</p>
</blockquote>
<p>那么不难发现一个合法的序列等价于可以通过此方法重排，考虑什么情况下重排会失败</p>
<p>显然重排失败只会在剩余序列中只剩下一种数且数量 $&gt;1$ 时发生，而这种数一定是原序列的众数，也就是 $1$</p>
<p>此时的序列形态一定是 $p-1$ 个 $1$，$b_1$，$p-b_1$ 个 $1$，$\dots$，$b_k$，$p-b_k$ 个 $1$，剩余序列中还有至少两个 $1$，而此时 $1$ 的个数超过了 $p-1+\sum p-b_i$，矛盾</p>
<p>回到原题，考虑对不合法的序列计数</p>
<p>首先是和为 $p$ 的倍数的情况，记长度为 $i$，和为 $p$ 的倍数的序列有 $g_i$ 个，则显然 $g_i&#x3D;(p-1)^{i-1}-g_{i-1}$</p>
<p>接下来是和不为 $p$ 的倍数且 $1$ 的个数 $\ge p+\sum p-b_i$ 的情况</p>
<p>记 $f_{i,j}$ 为 $b$ 中选了 $i$ 个数，$\sum p-b_k&#x3D;j$ 的方案数，可以用前缀和 $\mathcal O(1)$ 转移</p>
<p>那么不合法序列对应的 $(i,j)$ 应满足 $n-i\ge p+j$ 且 $n-i\not\equiv j\pmod p$</p>
<p>而众数不只是 $1$，所以这部分方案数要乘上 $p-1$</p>
<p>时间复杂度 $\mathcal O(n^2)$</p>
<ul>
<li>D</li>
</ul>
<p>记原序列的 LIS 长度为 $L$，$f_i$ 为以 $i$ 结尾的 LIS 长度</p>
<p>若 $L&#x3D;2k$，则原序列一定可以分成两个长度为 $k$ 的 LIS</p>
<p>考虑如下构造：对于一个位置 $i$，若 $f_i\le k$，则放入第一个序列，否则放入第二个序列</p>
<p>此时两个序列都至少存在一个长为 $k$ 的上升子序列，又两个序列中 $f_i$ 只有 $k$ 种，所以 LIS 为 $k$，即构造合法</p>
<p>若 $L&#x3D;2k+1$，则分成的两个序列的 LIS 一定为 $k+1$</p>
<p>结论：原序列能分成两个 LIS 长度为 $k+1$ 的序列当且仅当除了原序列 LIS 以外还存在一个数 $a_j$ 使得存在一个经过 $a_j$ 的上升子序列长度至少为 $k+1$</p>
<p>证明：必要性显然，接下来通过构造证明充分性</p>
<p>先把经过 $a_j$，长为 $k+1$ 的上升子序列放入第一个序列，其他的数 $a_i$ 若 $f_i$ 不等于这个子序列中任何一个 $f$ 或者 $f_i&#x3D;f_j$ 则放入第二个序列，否则放入第一个序列</p>
<p>此时两个序列都至少存在一个长为 $k+1$ 的上升子序列，又两个序列中 $f_i$ 只有 $k+1$ 种，所以 LIS 为 $k$，即构造合法</p>
<p>时间复杂度 $\mathcal O(n\log n)$</p>
<ul>
<li>E</li>
</ul>
<p>考虑把字符串中 <code>A</code> 看做 $0$，<code>B</code> 看做 $1$，<code>C</code> 看做 $2$，之后构造一个符合下列条件的序列 $a_i$：</p>
<ol>
<li><p>$a_i\equiv s_i\pmod 3$</p>
</li>
<li><p>$|a_i-a_{i+1}|&#x3D;1$</p>
</li>
</ol>
<p>显然若 $a_1$ 确定了，整个序列就确定了</p>
<p>考虑一个合法的操作对 $a$ 有什么影响，显然若 $a_{i-1},a_{i+1}$ 均为 $a_i+1$ 则 $a_i$ 变为 $a_i+2$，若 $a_{i-1},a_{i+1}$ 均为 $a_i-1$ 则 $a_i$ 变为 $a_i-2$</p>
<p>记 $s$ 对应的序列为 $a$，$t$ 对应的序列为 $b$，则答案有下界 $\sum\frac{|a_i-b_i|}2$（显然若 $a_1\not\equiv b_1\pmod 2$ 时无解）</p>
<p>下证答案可以取到这个下界，即证至少能找到一个 $a_i&gt;b_i$ 使得 $a_i&gt;a_{i-1}\land a_i&gt;a_{i+1}$（$a_i&lt;b_i$ 同理）</p>
<p>考虑取 $a_i&gt;b_i$ 的 $a_i$ 中最大的那个，若 $a_i&lt;a_{i+1}$ 则有 $a_{i+1}&#x3D;a_i+1&gt;b_i+1\ge b_{i+1}$，与 $a_i$ 最大矛盾</p>
<p>所以合理确定 $a_1,b_1$ 使得 $a_1\equiv b_1\pmod 2$ 且 $\sum\frac{|a_i-b_i|}2$ 最小即可</p>
<p>时间复杂度 $\mathcal O(n\log n)$</p>
<ul>
<li>F</li>
</ul>
<p>显然一次操作相当于翻转一个邻域里有奇数个 $1$ 的点</p>
<p>操作显然可逆，所以考虑计算可以通过操作变成全 $1$ 的数量</p>
<p>性质 1：操作不会影响 $1$ 连通块个数的奇偶性</p>
<p>证明显然，所以合法的状态中 $1$ 连通块个数一定是奇数</p>
<p>同样的合法状态中至少有一个点可以被操作</p>
<p>这两个条件显然是必要的，考虑它们什么时候充分</p>
<p>性质 2：当树上存在一个点度数 $\ge 3$ 且以这个点为根时至少有两个子树有至少两个点时，一个状态合法当且仅当状态中 $1$ 连通块数量为奇数且至少有一个点可以被操作</p>
<p>证明：若 $1$ 连通块数量为 $1$，则显然这个状态合法</p>
<p>考虑用一个点来代表一个 $1$ 连通块（可以通过操作连通块中最外面一层的点来缩成一个点）</p>
<p>此时显然有任意两个 $1$ 不相邻，我们的目标状态即为把所有 $1$ 合并为一个 $1$</p>
<p>考虑新建两个操作：</p>
<ol>
<li><p>若一个点 $u$ 为 $1$，与它相邻的点 $v$ 为 $0$，且与 $v$ 相邻的点中只有 $u$ 一个为 $1$，则可以将 $v$ 设置为 $1$，$u$ 设置为 $0$，称为「交换」</p>
</li>
<li><p>若一个点 $u$ 为 $0$，与它相邻的点中有奇数个 $1$，可以将这些 $1$ 设置为 $0$，将 $u$ 设置为 $1$，称为「合并」</p>
</li>
</ol>
<p>引理 1：若以 $u$ 为根的子树中有可进行的操作，且 $u$ 的父亲为 $0$，则一定可以通过若干次操作改变 $u$ 的状态</p>
<p>证明：考虑归纳证明</p>
<ol>
<li><p>若 $u$ 为 $0$，如果它的儿子中有奇数个 $1$，则可以通过一次合并操作改变 $u$ 的状态；否则记可以操作的点在 $v$ 的子树中，则根据归纳假设可得 $v$ 可以通过若干次操作被改变状态，改变 $v$ 之后通过一次合并操作即可改变 $u$ 的状态</p>
</li>
<li><p>若 $u$ 为 $1$，如果存在一个儿子的儿子中有偶数个 $1$，则可以通过一次合并操作改变 $u$ 的状态；否则记可以操作的点在 $v$ 儿子的 $w$ 子树中，根据归纳假设可得 $w$ 可以通过若干次操作被改变状态，改变 $w$ 之后通过一次合并操作即可改变 $u$ 的状态</p>
</li>
</ol>
<p>引理 2：若以 $u$ 为根的子树中无可进行的操作，且 $u$ 为 $0$，$u$ 子树中不全为 $0$，则如果可以给 $u$ 的父亲变为 $1$，则一定可以通过若干次操作使得 $u$ 子树内可以进行合并操作</p>
<p>证明：考虑归纳证明</p>
<ol>
<li><p>若 $u$ 的所有儿子均为 $0$，则可以通过一次交换操作把 $u$ 的父亲的 $1$ 移到 $u$ 上并递归进子树中，根据归纳假设此时一定成立</p>
</li>
<li><p>若 $u$ 的所有儿子中有偶数个 $1$，则可以在 $u$ 处进行合并操作</p>
</li>
<li><p>若 $u$ 的所有儿子中有奇数个 $1$，则与以 $u$ 为根的子树中无可进行的操作矛盾</p>
</li>
</ol>
<p>回到原来的性质中，考虑以一个度数 $\ge 3$，至少有两个大小 $\ge 2$ 的子树的点 $u$ 为根</p>
<p>考虑构造一种操作方式使得能使 $1$ 的个数不断减少</p>
<ol>
<li><p>若 $u$ 为 $1$ 则通过引理 1 把 $u$ 修改为 $0$</p>
</li>
<li><p>若 $u$ 的儿子中有奇数个 $1$ 且 $1$ 的个数 $\ge 3$，则可以通过一次合并操作减少 $1$ 的数量，操作后若 $1$ 的个数不为 $1$ 则显然还能继续操作</p>
</li>
<li><p>若 $u$ 的儿子中有偶数个 $1$ 则考虑根据引理 1 改变其中一个儿子的状态</p>
</li>
<li><p>若 $u$ 的儿子中只有一个 $1$，考虑 $u$ 的其他儿子</p>
<ol>
<li><p>若 $u$ 的其他儿子中有至少两个可以操作的子树，则可以根据引理 1 改变两个儿子的状态</p>
</li>
<li><p>若 $u$ 的其他儿子中有一个不全为 $0$ 且不可以操作的子树，则可以把为 $1$ 的儿子和 $u$ 交换，此时这个子树符合引理 2</p>
</li>
<li><p>否则 $u$ 的其他儿子中只有一个可以操作的子树，且其他子树全部为 $0$，由于 $u$ 的度数 $\ge 3$，所以可以把为 $1$ 的儿子交换到一个全 $0$ 的子树中去，此时如果满足前两种情况则按照前两种情况做，否则由于 $u$ 至少有两个大小 $\ge 2$ 的子树，所以一定可以把为 $1$ 的儿子换到一个大小 $\ge 2$ 的全 $0$ 子树中，之后操作那个可以操作的子树，使得 $u$ 获得一个新的为 $1$ 的儿子，由于之前为 $1$ 的儿子在大小 $\ge 2$ 的子树中，所以新儿子可以通过交换操作换到另一个全 $0$ 子树中，若此时还不符合前两种情况，则此时一定只有这两个 $1$，与条件矛盾</p>
</li>
</ol>
</li>
</ol>
<p>这样我们就证完了这个性质</p>
<p>于是对于一个符合这个性质的树，记 $f_{u,0&#x2F;1,0&#x2F;1,0&#x2F;1,0&#x2F;1}$ 为以 $u$ 为根的子树中，$u$ 为 $0&#x2F;1$，$u$ 的儿子的异或和为 $0&#x2F;1$，$1$ 连通块个数的奇偶性和是否存在一个点可以操作</p>
<p>接下来只要考虑不符合性质的树怎么计数，不难发现不符合性质的树的形态一定是一条链两边接了若干条边（链+两个菊花）</p>
<p>记两边的菊花各有 $l$ 和 $r$ 条边，则链上点的个数即为 $n-l-r$，记为 $len$</p>
<ol>
<li><p>若链的两个端点均为 $1$，则链上所有点一定为 $1$，菊花上的点任意，方案数为 $2^{l+r}$</p>
</li>
<li><p>若链的两个端点中恰一个为 $1$，则链上一定是一段连续的 $1$ 和一段连续的 $0$，菊花上的点要保证为 $0$ 的端点一定不能被操作，所以方案数为 $2(len-1)2^{l+r-1}&#x3D;(len-1)2^{l+r}$</p>
</li>
<li><p>若链的两个端点均为 $0$</p>
<ol>
<li><p>若链上全为 $0$，则菊花上的点要保证两个端点恰有一个点能被操作，方案数为 $2^{l+r-1}$</p>
</li>
<li><p>若链上点不全为 $0$，则一定是中间连续的一段为 $1$，菊花上的点要保证两个端点都不能被操作，方案数为 $\binom{len-1}22^{l+r-2}$</p>
</li>
</ol>
</li>
</ol>
<p>总复杂度 $\mathcal O(n)$，dp 有一个 $2^8$ 的常数</p>
<h3 id="AGC053"><a href="#AGC053" class="headerlink" title="AGC053"></a>AGC053</h3><ul>
<li>A</li>
</ul>
<p>不难发现最多分成 $k&#x3D;\min{|a_i-a_{i-1}|}$ 组，每组直接取 $\lfloor\frac {a_i}k\rfloor$ 或 $\lceil\frac{a_i}k\rceil$ 即可</p>
<ul>
<li>B</li>
</ul>
<p>转化一下题意，把原序列分成前一半和后一半，不难发现每轮操作相当于先手任选一个数然后后手在另一半中取最靠中间的那个</p>
<p>不妨假设一开始先手的分数为 $\sum a_i$，每一轮把分数减掉后手选的那个</p>
<p>显然第 $i$ 轮后手拿的数只能是前一半的后 $i$ 个和后一半的前 $i$ 个，所以用个堆维护一下即可</p>
<p>时间复杂度 $\mathcal O(n\log n)$</p>
<ul>
<li>C</li>
</ul>
<p>考虑对于确定的两个序列 $a$ 和 $b$ 最少会删几次</p>
<p>不妨设 $2n$ 在序列 $a$ 中，显然 $b$ 会被全部删完，至少要 $n$ 次操作，考虑 $a$ 最少删多少个</p>
<p>对于 $b_i$，记 $j$ 为满足 $a_j&gt;b_i$ 的最小的 $j$，显然 $a$ 至少要删 $\max\limits_{i}{\max{0,j-i}}$ 个</p>
<p>接下来考虑计算 $a$ 删除个数 $x$ 的期望值</p>
<p>显然 $E(x)&#x3D;n-\sum_{0\le d&lt;n} P(x\le d)$，所以我们只需要对于每个 $d$ 计算 $a$ 最多删除 $d$ 个的概率</p>
<p>对于每个 $b_i$，显然它不应该是 $a_1,a_2,\dots,a_{i+d}$ 中最大的那个，所以它的贡献为 $\frac{i+\min{i+d,n}-1}{i+\min{i+d,n}}$，那么 $P(x\le d)$ 就是所有 $b_i$ 的贡献的乘积</p>
<p>而这个式子可以预处理双阶乘之后 $\mathcal O(1)$ 求出</p>
<p>总复杂度 $\mathcal O(n)$</p>
<ul>
<li>D</li>
</ul>
<p>显然对于第 $i$ 个人，如果确定了前 $i$ 道题做哪些那么他做题的顺序就确定了（前 $i$ 道题和后 $n-i$ 道题一定都按时间从大到小做）</p>
<p>考虑维护 $t_{i,j}$ 表示第 $i$ 个人做完前 $j$ 道题需要多长时间，初始每个人的所有题都按照时间从大到小做；$T_j$ 表示目前所有人做完前 $j$ 道题最少需要多长时间</p>
<p>考虑倒序确定第 $i$ 个人前 $i$ 题做哪些，假设选出了 $x$ 道 $1$ 分钟题，$y$ 道 $2$ 分钟题，$z$ 道 $3$ 分钟题，显然需要满足 $x+2y+3z\le T_i$</p>
<p>由于我们希望对前 $i-1$ 个人的限制小一些，所以我们希望 $x+2y+3z$ 尽可能大；若 $x+2y+3z$ 一样大，则我们希望 $x$ 尽可能大，这样我们就可以唯一确定一组 $(x,y,z)$ 了，之后我们用 $(x,y,z)$ 更新前面的 $T$ 数组</p>
<p>我们不难发现这个贪心唯一会出的问题是 $(x,y,z)$ 可能会使 $i$ 之后的人不满足条件，但在值域为 ${1,2,3}$ 时这个问题并不会出现</p>
<p>先考虑对于 $k&gt;i$ 有 $t_{k,k-1}+2\ge t_{k,k}$ 的情况，此时对于 $k&gt;i$ 都有 $t_{k,k}\le t_{i,i}+2(k-i)$，则 $i$ 后面填的 $2$ 和 $3$ 一定合法，而填的 $1$ 由 $t$ 的初始值保证其合法</p>
<p>否则 $i$ 的前 $i$ 题一定都是 $3$，同样由 $t$ 的初始值保证合法性</p>
<p>这样我们就得到了一个 $\mathcal O(n^2)$ 的构造</p>
<p>由于第 $i$ 个人的前 $i$ 道题是按时间从大到小做的，所以把 $t_i$ 画出来一定是一个斜率递减的折线，所以只需要维护最多两个折线拐点</p>
<p>时间复杂度 $\mathcal O(n)$</p>
<ul>
<li>E</li>
</ul>
<p>不妨假设 $a_i&lt;b_i$</p>
<p>结论：一个排列 $p$ 合法当且仅当存在 $k\in[0,n]$ 满足对于任意 $j&lt;k$ 有 $a_{p_{j+1}}&lt;b_{p_j}$ 且对于任意 $j&gt;k+1$ 有 $a_{p_{j-1}}&lt;b_{p_j}$</p>
<p>证明：先证充分性，称一个盒子先放 $a_i$ 再放 $b_i$ 为「正放」，否则为「倒放」，那么 $p_1,p_2,\dots,p_k$ 正放，$p_{k+1},p_{k+2},\dots,p_n$ 倒放即为一个合法的排列</p>
<p>下证必要性，显然 $a_i$ 不可能为峰，那么我们希望 $n$ 个 $b_i$ 有 $n-1$ 个可以成为峰</p>
<p>若最终的排列中存在多于两组 $b_i$ 相邻，则峰最多只有 $n-2$ 个，矛盾</p>
<p>若最终的排列中不存在 $b_i$ 相邻，则要求不在头尾的 $b_i$ 均为峰，那么一定需要满足上述条件</p>
<p>若最终的排列中只有一组 $b_i$ 相邻，则要求相邻的两个 $b_i$ 中恰有一个为峰，其他的 $b_i$ 均为峰，那么也一定会满足上述条件</p>
<p>回到原题，考虑给每个合法的排列 $p$ 一一对应一个 $k$，不妨设它是最小的那一个，则此时 $a_{p_{k+1}}&gt;b_{p_k}\Rightarrow b_{p_{k+1}}&gt;b_{p_k}$</p>
<p>不难发现此时 $k\not&#x3D;n$（把 $k&#x3D;n$ 时最后一个正放改为倒放仍满足条件且 $k$ 变为 $n-1$）</p>
<p>不妨先给每组 $(a_i,b_i)$ 按 $b_i$ 从小到大排序，记 $cnt_i$ 为满足 $j&gt;i\land a_j&lt;b_i$ 的 $j$ 的个数</p>
<p>若 $k&#x3D;0$ 则考虑倒序把这些二元组添加到排列中，显然添加 $i$ 时有 $cnt_i+1$ 种合法位置，则这种情况的贡献为 $\prod (cnt_i+1)$</p>
<p>否则考虑枚举 $p_k&#x3D;i,p_{k+1}&#x3D;j$，由于 $b_i&lt;b_j$ 可得 $i&lt;j$，此时把 $p_1,\dots,p_k$ 倒过来，相当于需要两个分别以 $i$ 和 $j$ 开头的 $k&#x3D;0$ 的排列，同样考虑倒序添加二元组，添加 $x$ 时，若 $x&gt;j$ 则有 $cnt_x+2$ 种合法位置（两个序列的开头都可以选），若 $i&lt;x&lt;j$ 则有 $cnt_x+1$ 种合法位置，若 $x&lt;i$ 则有 $cnt_x$ 种合法位置</p>
<p>计算 $cnt$ 和 $k\not&#x3D;0$ 的答案时都需要维护 $a$ 和 $b$ 的偏序关系，用一个树状数组即可</p>
<p>时间复杂度 $\mathcal O(n\log n)$</p>
<ul>
<li>F</li>
</ul>
<p>咕（</p>
<h3 id="AGC054"><a href="#AGC054" class="headerlink" title="AGC054"></a>AGC054</h3><ul>
<li>A</li>
</ul>
<p>显然若 $s_1\not&#x3D;s_n$ 则答案为 $1$，否则若存在两个连续的字符不和 $s_1$ 相等则答案为 $2$，否则答案为 $-1$</p>
<ul>
<li>B</li>
</ul>
<p>考虑钦定每个人拿哪些橘子，假设先手拿了 $i$ 个，后手拿了 $j$ 个，则所有 $i!j!$ 种排列都可以和拿橘子的方式一一对应</p>
<p>于是记 $f_{i,j,k}$ 为前 $i$ 个橘子，先手拿了 $j$ 个，总重量为 $k$ 的方案数，背包转移即可</p>
<p>时间复杂度 $\mathcal O(n^3w)$，$w$ 为值域</p>
<ul>
<li>C</li>
</ul>
<p>不难发现每次操作都可以使一个还不满足条件的 $i$ 前面比它大的数的数量减 $1$</p>
<p>所以对于每个在操作之后仍存在的逆序对一定在原排列中存在</p>
<p>另外对于一个操作之后排列中的满足前面比它大的数的数量 $&lt;k$ 的 $i$ 一定有它相对它后面的数位置不变</p>
<p>于是对于一个操作之后排列中的 $i$，若它前面有恰好 $k$ 个比它大的数则贡献为 $\frac{1}{\sum\limits_{j&gt;i}[p_j&lt;p_i]}$，否则贡献为 $\frac1{n-i+1}$</p>
<p>时间复杂度 $\mathcal O(n)$</p>
<ul>
<li>D</li>
</ul>
<p>显然 <code>o</code> 对括号匹配不会有影响，<code>x</code> 不会影响括号匹配但要求一定要在至少一对括号内部</p>
<p>考虑先把 <code>ox</code> 去掉，单独考虑括号，显然我们可以贪心地选括号，每次遇到一个无法匹配的右括号就找一个最近的左括号移过来</p>
<p>回到原题，考虑把 <code>ox</code> 加进来，不难发现移动 <code>x</code> 一定不会比移动括号更优，所以只考虑移动括号，而加入 <code>ox</code> 后之前的括号序列仍然是最优的</p>
<p>记 $f_{i,j}$ 为加入了括号序列的第 $i$ 位，<code>ox</code> 序列的第 $j$ 位的最小代价</p>
<p>转移的时候还需要统计一下当前位之后有多少位置已经移动到这个位置之前，可以预处理出来</p>
<p>时间复杂度 $\mathcal O(n^2)$</p>
<ul>
<li>E</li>
</ul>
<p>不妨假设 $p_1&lt;p_n$</p>
<p>结论：一个排列 $p$ 合法当且仅当存在一个位置 $k$ 使得 $p_k\le p_1$ 且 $p_{k+1}\ge p_n$</p>
<p>证明：先证充分性，考虑分别删除 $[1,k]$ 和 $[k+1,n]$ 中的元素直到不能删除位置，不难发现剩余的元素一定是由两个单调递减的序列构成的，于是可以以 $p_{k+1}$ 为一端不断把 $(1,k]$ 中的元素删完，再以 $p_1$ 为端点把 $[k+1,n)$ 中的元素删完</p>
<p>下证必要性，考虑归纳，$n&#x3D;2$ 时显然成立</p>
<p>$n&gt;2$ 时，考虑反证，假设第一步删除了位置 $i$，由归纳假设可得删除之后的序列存在 $k$ 使得 $p_k\le p_1$ 且 $p_{k+1}\ge p_n$，此时无论 $k$ 取何值，加入 $p_i$ 之后一定仍然满足这个性质，即矛盾</p>
<p>回到原题，考虑计算不合法排列 $p$ 的数量，枚举 $p_1&#x3D;x$，$p_2&#x3D;y$</p>
<p>则相当于要求每个 $[1,x]$ 中的数后面不能接 $[y,n]$ 中的数，那么方案数为 $(y-x-1)!\frac{(y-3)!}{(y-x-2)!}\frac{(n-x-2)!}{(y-x-2)!}&#x3D;(y-x-1)\frac{(y-3)!(n-x-2)!}{(y-x-2)!}$</p>
<p>记 $k&#x3D;y-x-2$，则答案为：</p>
<p>$$<br>\begin{aligned}<br>&amp;(n-x-2)!\sum_{k&#x3D;0}^{n-x-2}(k+1)\frac{(k+x-1)!}{k!}\cr<br>&#x3D;&amp;(n-x-2)!\sum_{k&#x3D;0}^{n-x-2}(\frac{(k+x-1)!}{(k-1)!}+\frac{(k+x-1)!}{k!})<br>\cr<br>&#x3D;&amp;(n-x-2)!(x!\sum_{k&#x3D;0}^{n-x-2}\binom{k+x-1}{k-1}+(x-1)!\sum_{k&#x3D;0}^{n-x-2}\binom{k+x-1}{k})\cr<br>&#x3D;&amp;(n-x-2)!(x!\binom{n-2}{x+1}+(x-1)!\binom{n-2}{x})<br>\end{aligned}<br>$$</p>
<p>即可 $\mathcal O(n)-\mathcal O(1)$ 计算</p>
<p>$p_1&gt;p_n$ 的时候同样有 $(x-3)!((n-x+1)!\binom{n-2}{n-x+2}+(n-x)!\binom{n-2}{n-x+1})$</p>
<p>时间复杂度 $\mathcal O(n+T)$</p>
<ul>
<li>F</li>
</ul>
<p>记 $a_i$ 为 $A_i$ 最终删除了多少，$b_i$ 为 $B_i$ 最终删除了多少，不妨设 $a_0&#x3D;b_0&#x3D;a_{n+1}&#x3D;b_n&#x3D;0$</p>
<p>结论：数列 $a,b$ 合法当且仅当对于任意 $i$ 有 $2| a_i+b_i+b_{i-1}$ 且 $\max{a_i,b_i,b_{i-1}}\le \frac{a_i+b_i+b_{i-1}}{2}$</p>
<p>证明：先证必要性，显然一次操作 $[l,r]$ 会把 $a_l,b_l$ 减去 $1$，$a_r,b_{r-1}$ 减去 $1$，$b_i,b_{i-1}(i\in(l,r))$ 减去 $1$，即一次操作会对 $[l,r]$ 中所有位置的 $a_i,b_i,b_{i-1}$ 中的两个减去 $1$，显然需要满足上述条件</p>
<p>下证充分性，考虑构造出一组合法的操作，每次选出一对相邻的满足 $a_i&#x3D;b_i+b_{i-1}$ 的位置操作，显然操作之后仍然合法，由于序列两端一定满足条件，所以一定可以选出这样的一对位置</p>
<p>回到原题，考虑先调整一下 $A_i$ 和 $B_i$</p>
<p>若 $B_i&gt;A_i+B_{i-1}$ 则可以令 $B_i&#x3D;A_{i}+B_{i-1}$，显然这不会影响答案，对 $B_{i-1}$ 同理</p>
<p>这一步可以用最短路在 $\mathcal O(n\log n)$ 的时间内解决</p>
<p>若 $A_i\ge B_i+B_{i-1}$，则可以把原问题分成 $[1,i]$ 和 $[i,n]$ 两个子问题，前一个子问题中令 $A_i&#x3D;B_{i-1}$，后一个子问题中令 $A_i&#x3D;B_i$，这也不会影响答案</p>
<p>此时只需要考虑 $|B_{i}-B_{i-1}|\le A_i&lt;B_i+B_{i-1}$ 的情况，我们想要最大化 $\sum a_i$</p>
<p>记 $f_i$ 为 $a_1,\dots,a_i$ 全部取 $A_1,\dots,A_i$ 时 $b_i$ 的取值范围，假设我们确定了 $b_{i-1}$，则此时 $f_{i}&#x3D;{x|x\in[|A_i-b_{i-1}|,\min{A_i+b_{i-1},B_i}],x\equiv A_i+b_{i-1}\pmod 2}$</p>
<p>不难发现 $f_i$ 一定是一个区间限制和一个奇偶性限制的形式，且区间右端点为 $B_i$，那么很容易可以通过 $f_{i-1}$ 推到 $f_i$</p>
<p>由于在序列右端点有 $B_i&#x3D;0,A_i&#x3D;B_{i-1}$，所以 $f_n$ 的区间限制为 $[0,0]$，此时若 $2|\sum A_i$ 则有 $f_n$ 的奇偶性限制也为 $0$，即 $a_1,\dots,a_n$ 取 $A_1,\dots,A_n$ 是合法的；否则 $a_1,\dots,a_n$ 取 $A_1,\dots,A_{n-1},A_n-1$ 也是合法的</p>
<p>综上，$2|\sum A_i$ 时 $\sum a_i$ 最大取到 $\sum A_i$，方案数为 $1$；$2\not|\sum A_i$ 时 $\sum a_i$ 最大取到 $(\sum A_i)-1$，我们只需要求出此时有多少个位置 $i$ 取 $A_i-1$ 时合法</p>
<p>记 $g_i$ 为 $a_i,\dots,a_n$ 全部取 $A_i,\dots,A_n$ 时 $b_{i-1}$ 的取值范围，我们可以用和 $f$ 一样的方式从 $g_{i+1}$ 推到 $g_i$</p>
<p>此时对于一个位置 $i$，我们可以通过同样的转移方法合并 $f_{i-1}$ 和 $g_{i+1}$ 得到 $a_1,\dots,a_{i-1},a_{i+1},\dots,a_{n}$ 全部取 $A_1,\dots,A_{i-1},A_{i+1},\dots,A_n$ 时 $a_i$ 的取值范围，现在只需要判断 $A_i-1$ 是否在这个取值范围内即可</p>
<p>时间复杂度 $\mathcal O(n\log n)$</p>
<h3 id="AGC055"><a href="#AGC055" class="headerlink" title="AGC055"></a>AGC055</h3><ul>
<li>A</li>
</ul>
<p>注意到 $6&#x3D;3!$，所以考虑把它分成 <code>ABC</code> 的所有排列各一个</p>
<p>考虑把序列分成三个长度为 $n$ 的连续段，让 <code>ABC</code> 的排列中第一个字母在第一段中取，第二个字母在第二段中取，第三个字母在第三段中取</p>
<p>把六个排列的个数设出来解一个六元方程即可</p>
<p>时间复杂度 $\mathcal O(n)$</p>
<ul>
<li>B</li>
</ul>
<p>考虑记 <code>A</code> 为 $0$，<code>B</code> 为 $1$，<code>C</code> 为 $2$，记 $a_i&#x3D;(s_i-i)\bmod 3$</p>
<p>不难发现此时一个操作等价于把三个连续一样的数字一起变为另一个数字</p>
<p>进一步，如果我们有形如 <code>xxxy</code> 的连续段，我们可以通过两次操作将其变为 <code>yxxx</code> 的形式</p>
<p>那么这个操作就相当于把任意三个连续一样的数字从序列中删除之后在任意一个地方插入三个一样的任意数字</p>
<p>对于序列 $a$，记 $f(a)$ 为不断贪心地删除其中三个一样的数字直到不能删位置所得到的序列</p>
<p>结论：对于序列 $a$，在求 $f(a)$ 的过程中删除的顺序不影响最终的结果</p>
<p>证明：假设一次操作中有至少两个子段可以删除，若这两个子段有交，则任意删除一个不会影响下一步的序列；否则任意删除一个子段之后另一个子段一定还可以继续删除，也不会影响最终的序列</p>
<p>于是 $a$ 和 $f(a)$ 一一对应，不难发现若 $a$ 和 $b$ 能互相转化当且仅当 $f(a)&#x3D;f(b)$，于是直接用个栈模拟贪心的过程即可</p>
<p>时间复杂度 $\mathcal O(n)$</p>
<ul>
<li>C</li>
</ul>
<p>（大概不是官方题解的思路？）</p>
<p>不难发现 $a$ 中至多有两种数，一种是 $p$ 的 LIS 长度，另一种是 $p$ 的 LIS 长度减一</p>
<p>考虑枚举 $p$ 的 LIS 长度 $k$，则 $a $ 中 $k$ 至少有 $n-k$ 个，而序列中 $k-1$ 的意义为它是 $p$ 的 LIS 一定包含的点</p>
<p>考虑把其中一些 $k-1$ 变为 $k$ 需要有什么条件，这些 $k$ 的意义为 $p$ 中一定有至少一个点可以代替它成为 $p$ 的 LIS，即这个 $k$ 两侧至少还有一个 $k$</p>
<p>这样我们可以把 $p$ 中的点分成三种：</p>
<ol>
<li><p>一定在 LIS 中，此时会给 LIS 贡献 $1$，$a$ 的值为 $k-1$</p>
</li>
<li><p>一定不在 LIS 中，此时不会对 LIS 产生贡献，$a$ 的值为 $k$</p>
</li>
<li><p>它所在的一段一定有一个在 LIS 中，此时这一段会给 LIS 贡献 $1$，$a$ 的值为 $k$</p>
</li>
</ol>
<p>但此时 $a$ 和 $p$ 还没有一一对应，对于 $a$，考虑让 $3$ 类子段长度固定为 $2$，且贪心地放在 $a$ 的值为 $k$ 的子段的最前面；对于 $p$，考虑让 $2$ 类点从 $n$ 开始从大到小填，$1,3$ 类点从 $1$ 开始从小到大填，同时 $3$ 类子段逆序填，这样 $a$ 和 $p$ 就一一对应了</p>
<p>记 $f_{i,j,0&#x2F;1}$ 为考虑前 $i$ 个位置，对 LIS 贡献为 $j$，不存在&#x2F;存在长度超过 $2$ 的 $2$ 类点子段的方案数，转移显然</p>
<p>时间复杂度 $\mathcal O(n^2)$</p>
<ul>
<li>D</li>
</ul>
<p>记序列 $f_{a,i}&#x3D;\sum_{j\le i}[s_j&#x3D;b]-[s_j&#x3D;a]$，类似定义 $f_b$ 和 $f_c$</p>
<p>记 $g_a&#x3D;\max f_{a,i}$，类似定义 $g_b$ 和 $g_c$</p>
<p>结论：$s$ 合法当且仅当 $g_a+g_b+g_c\le n$</p>
<p>证明：先证必要性，考虑 $(a,b)$ 顺序对在序列中至多出现 $n-g_a$ 次，而 <code>abc</code> 的轮换中 $(a,b),(b,c),(c,a)$ 顺序对一共要出现 $2n$ 次，即要求 $\sum n-g_a\ge 2n\Leftrightarrow g_a+g_b+g_c\le n$</p>
<p>下证充分性，考虑构造：取序列中第 $i$ 个 <code>a</code>，第 $i+g_a$ 个 <code>b</code>，第 $i+g_a+g_b$ 个 <code>c</code> 组成子序列（运算均对 $n$ 取模）</p>
<p>分类讨论一下：</p>
<ol>
<li><p>$i+g_a+g_b\le n$ 时不难发现这个子序列一定为 <code>abc</code></p>
</li>
<li><p>$i+g_a\le n$ 且 $i+g_a+g_b&gt;n$ 时不难发现 <code>a</code> 一定在 <code>b</code> 之前，由 $i+g_a+g_b-n&lt;i-g_c$ 得到 <code>c</code> 一定在 <code>a</code> 之前，即这个子序列为 <code>cab</code> </p>
</li>
<li><p>$i+g_a&gt;n$ 时同样可以发现这个子序列为 <code>bca</code></p>
</li>
</ol>
<p>于是我们只需要求满足 $g_a+g_b+g_c\le n$ 的序列有多少个</p>
<p>记 $f_{t,i,j,ma,mb,mc}$ 为考虑前 $t$ 个位置，有 $i$ 个 <code>a</code>，$j$ 个 <code>b</code>，$g_a,g_b,g_c$ 分别为 $ma,mb,mc$ 的方案数</p>
<p>时间复杂度 $\mathcal O(n^6)$</p>
<ul>
<li>E</li>
</ul>
<p>若 $S_i&#x3D;S_{i+1}$，则这次操作没有意义，所以不妨规定不能进行这种操作</p>
<p>构造一个排列 $p$，初始时 $p_i&#x3D;i$，每次操作 $i$ 的时候交换 $p_i$ 和 $p_{i+1}$</p>
<p>结论：$S_i&#x3D;[\min_{j\ge i}p_j,\max_{j\le i}p_j]$</p>
<p>证明：考虑归纳，显然初始排列正确，假设对于排列 $p$ 成立，当前操作交换 $p_i$ 和 $p_{i+1}$</p>
<p>考虑反证，若交换后不成立，则相当于 $p_{i+1}&#x3D;\min_{j\ge p_i}p_j$ 或 $p_{i}&#x3D;\max_{j\le i+1}p_j$，此时一定有 $p_{i}&gt;p_{i+1}$，可得 $S_i&#x3D;S_{i+1}$，得到矛盾</p>
<p>于是可以把题目转化为求一个逆序对数最小的 $p$ 使得 $S_i&#x3D;[l_i,r_i]$，或者判定无解</p>
<p>显然对于 $i&#x3D;1$ 或者 $i&gt;1\land r_i\not&#x3D;r_{i-1}$ 一定有 $p_i&#x3D;r_i$，对于 $i&#x3D;n$ 或者 $i&lt;n\land l_i\not&#x3D;l_{i+1}$ 一定有 $p_i&#x3D;l_i$</p>
<p>若此时不出现矛盾就贪心地从小到大填，然后求出逆序对即可</p>
<p>时间复杂度 $\mathcal O(n\log n)$</p>
<ul>
<li>F</li>
</ul>
<p>转化一下题意，对于一个 $b$，考虑从后往前不断分进 $a$ 序列中，维护 $c_i$ 表示第 $i$ 个 $a$ 序列还剩几个位置，初始 $c_i&#x3D;k$</p>
<p>那么题意相当于每次将一个 $c_j\ge b_i$ 减去 $1$，我们显然可以贪心地去找 $c_j$ 最小的那个去减</p>
<p>记 $d_i&#x3D;\sum[c_j&lt;i]$，那么一次操作相当于把 $d_{b_i}$ 加上 $1$ 之后重新排序</p>
<p>如果没有 $b_{pos}&#x3D;val$ 的限制，那么重新排序也没有意义，可以直接用多重组合数算出答案</p>
<p>考虑 $b_{pos}$ 时可以考虑枚举操作 $b_{pos}$ 之前的 $d$ 序列，则答案为 $\sum\limits_{0\le d_1\le d_2\le\dots\le d_k\le n,\sum d&#x3D;nk-pos}\frac{(nk-pos)!}{d_1!d_2!\cdots d3!}\frac{(pos-1)!}{(n-d_1)!(n-d_2)!\cdots(n-d_{val}+1)!\cdots(n-d_n)!}$</p>
<p>直接 dp 即可，单次时间复杂度 $\mathcal O(n^2k^3)$，总复杂度 $\mathcal O(n^2k^4)$</p>
<h3 id="AGC056"><a href="#AGC056" class="headerlink" title="AGC056"></a>AGC056</h3><ul>
<li>A</li>
</ul>
<p>首先对于 $3|n$ 有一个显然的构造：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">###......</span><br><span class="line">...###...</span><br><span class="line">......###</span><br><span class="line">###......</span><br><span class="line">...###...</span><br><span class="line">......###</span><br><span class="line">###......</span><br><span class="line">...###...</span><br><span class="line">......###</span><br></pre></td></tr></table></figure>

<p>对于 $n&#x3D;3k+1$，我们考虑在此基础上增加一行一列，然后进行一点微调：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">###.......</span><br><span class="line">...###....</span><br><span class="line">......###.</span><br><span class="line">###.......</span><br><span class="line">...###....</span><br><span class="line">......#.##</span><br><span class="line">###.......</span><br><span class="line">...###....</span><br><span class="line">......##.#</span><br><span class="line">.......###</span><br></pre></td></tr></table></figure>

<p>对于 $n&#x3D;3k-1$，我们考虑在此基础上删除一行一列，然后进行一点微调：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">###.....</span><br><span class="line">...##.#.</span><br><span class="line">.....###</span><br><span class="line">###.....</span><br><span class="line">...##..#</span><br><span class="line">.....###</span><br><span class="line">###.....</span><br><span class="line">...###..</span><br></pre></td></tr></table></figure>

<ul>
<li>B</li>
</ul>
<p>$p$ 和 $x$ 并不一一对应，考虑对 $p$ 只计数满足 $x$ 限制且字典序最大的那个</p>
<p>考虑区间 dp，对于一个区间 $[l,r]$，考虑枚举最大值的位置 $k$</p>
<p>右边区间对 $k$ 没有限制，考虑左边区间对 $k$ 的限制，也即字典序最大对 $p$ 的限制</p>
<p>记左边区间最大值在位置 $j$，被 $[l,r]$ 包含的限制中若不存在一个限制同时跨过 $j$ 和 $k$，则显然交换 $j,k$ 的值限制仍然成立且字典序更大，不符合</p>
<p>记 $f_{l,r,k}$ 为 $[l,r]$ 中最大值的位置 $\ge k$ 的方案数，$mn_{l,r,k}$ 为被 $[l,r]$ 包含且跨过 $k$ 的限制向左最远延伸到哪里</p>
<p>显然有转移 $f_{l,r,k}&#x3D;f_{l,r,k+1}+f_{l,k-1,mn_{l,r,k}}f_{k+1,r,k+1}$</p>
<p>时间复杂度 $\mathcal O(n^3)$</p>
<ul>
<li>C</li>
</ul>
<p>记 $sum_i&#x3D;\sum_{j\le i}[s_j&#x3D;1]-[s_j&#x3D;0]$，考虑对 $sum$ 进行差分约束</p>
<p>对于一个限制 $[l,r]$ 相当于 $|sum_r-sum_{l-1}|\le 0$，连 $l-1\to r$ 和 $r\to l-1$ 权值为 $0$ 的边即可</p>
<p>此外还有 $|sum_{i+1}-sum_i|&#x3D;1$ 的限制，发现由于 $sum$ 的奇偶性确定，所以转化为 $|sum_{i+1}-sum_i|\le 1$ 的限制并不影响答案，链 $i\to i+1$ 和 $i+1\to i$ 权值为 $1$ 的边即可</p>
<p>直接跑最短路跑出来的是字典序最大的解，要求字典序最小的解直接取反即可</p>
<p>时间复杂度 $\mathcal O(n+m)$</p>
<ul>
<li>D</li>
</ul>
<p>转换一下题意，记 $s_A$ 为 <code>Alice</code> 拿的数之和，$s_B$ 为 <code>Bob</code> 拿的数之和，$sum&#x3D;\sum a_i$，把 $L\le s\le R$ 同时乘上 $2$ 之后减去 $sum$，可得 $2L-sum\le s_A-s_B\le 2R-sum$</p>
<p>记 $x&#x3D;sum-L-R$，则不等式可以转化为 $|x+s_A-s_B|\le R-L$</p>
<p>那么题意可以转化为一开始有一个数 $x$，先手可以选一个数让 $x$ 加上它，后手可以选一个数让 $x$ 减去它，最后分数为 $|x|$，先手希望分数尽可能小，后手希望分数尽可能大</p>
<p>对于序列 $a$ 记 $f(a)&#x3D;\sum a_{2k}-a_{2k-1}$，不妨给 $a$ 从小到大排序</p>
<p>结论：对于先手，先手任选一个 $p&#x3D;a_i$，把 $p,p+x,a_1,a_2,\dots,a_n$ 从小到大排序后得到序列 $b$，最后得分即为 $\min f(b)$；对于后手，把先手选完之后剩下 $n-1$ 个数和 $x$ 从小到大排序得到序列 $b$，最后得分即为 $f(b)$</p>
<p>证明：考虑归纳，$n&#x3D;2$ 时显然成立</p>
<p>假设 $n&#x3D;k$ 时对后手成立，考虑证明 $n&#x3D;k$ 时对先手成立</p>
<p>此时先手相当于可以把后手 $b$ 序列（初始 $b_i&#x3D;a_i$ ）的其中一个  $a_i$ 变为 $x+a_i$，相当于选择 $p&#x3D;a_i$，得证</p>
<p>假设 $n&#x3D;k$ 时对先手成立，下证 $n&#x3D;k+2$ 时对后手成立</p>
<p>此时假设后手选了 $a_i$，接下来先手取 $p&#x3D;a_i$ 即可取到 $f(b)$ 的得分，即 $f(b)$ 为分数的上界，接下来通过构造证明 $f(b)$ 可以被取到：记 $x$ 所在的位置为 $b_s$，若 $s$ 为奇数，则后手取 $b_{s-1}$（$b_0&#x3D;b_n$），接下来先手最优只能取 $p&#x3D;b_{s-1}$ 使得得分为 $f(b)$；同样 $s$ 为偶数时取 $b_{s+1}$（$b_{n+1}&#x3D;b_1$）可使得分为 $f(b)$</p>
<p>根据数学归纳法可得原命题成立</p>
<p>于是枚举 $p$ 然后暴力算得分即可，时间复杂度 $\mathcal O(n^2)$</p>
<ul>
<li>E</li>
</ul>
<p>考虑计算 $k&#x3D;n-1$ 的答案</p>
<p>考虑枚举 $b_i$ 表示在 $i$ 位置放了几次奶酪，$x$ 表示有几个奶酪经过了 $-0.1$</p>
<p>则对于第 $i$ 只老鼠有 $c_i&#x3D;x+\sum_{j\le i}b_j-i$ 个奶酪经过了它</p>
<p>对于第 $i$（$i&lt;n-1$）只老鼠，要求 $c_i$ 个奶酪中要吃掉一个，概率为 $1-\frac 1{2^{c_i}}$</p>
<p>对于第 $n-1$ 只老鼠，要求所有奶酪都不能吃，概率为 $\frac 1{2^{c_i}}$</p>
<p>发现这些概率和放置奶酪的顺序无关，在最后乘上一个多重组合数即可</p>
<p>那么对于确定的 $b_i$ 和 $x$，答案为 $(n-1)!\frac1{2^x}\prod(1-\frac 1{2^{\sum_{j\le i}b_j-i}}\frac1{2^x})\prod \frac{a_i^{b_i}}{b_i!}$</p>
<p>不难发现这是一个关于 $\frac 1{2^x}$ 的多项式，用 dp 求出这个多项式之后对于每一项等比数列求和即可</p>
<p>但是这个 $x$ 的意义并不明确，它会使一些没有起点也不被任何一个老鼠吃到的独立环被算进答案，而每个独立的贡献为 $\frac 12$（不能被最后一个老鼠吃掉），即算出来的答案比正确的答案多了 $(1+\frac 12+\frac1{2^2}+\cdots)&#x3D;2$ 倍，最后除掉 $2$ 即可</p>
<p>单次复杂度 $\mathcal O(n^4)$，总复杂度 $\mathcal O(n^5)$</p>
<ul>
<li>F</li>
</ul>
<p>以下「图」均为 $n$ 个点 $m$ 条边的图</p>
<p>我们不妨假设 dfs 序为 $1,2,\dots,n$</p>
<p>称存在 dfs 序为 $1,2,\dots,n$ 的图为「合法的」 ，对于任意 $i\in[2,n]$ 存在一个 $j&lt;i$ 使得 $j$ 和 $i$ 有边的图为「好的」</p>
<p>性质 1：对于一个好的图 $G(V,E)$，一定存在一个合法的图 $G’(V,E’)$ 使得 $G$ 中的点度数和 $G’ $ 中的点度数相等</p>
<p>证明：对于 $1\le a&lt;b&lt;c&lt;d\le n$，$(a,c),(b,d)\in E$，我们可以删除这两条边，并加入 $(a,d),(b,c)$，这显然不会改变度数并且不会破坏好的图的性质</p>
<p>我们一直进行这个操作直到不能操作为止，此时的图显然合法，即得证</p>
<p>所以我们只要对好的图进行计数即可，记 $d_i$ 为一个好的图 $G$ 的度数</p>
<p>性质 2：对于一个序列 $d$，存在一个好的图 $G$ 的度数序列为 $d$ 当且仅当</p>
<ol>
<li><p>$\sum d_i&#x3D;2m$</p>
</li>
<li><p>对于任意 $i\in [2,n]$ 有 $d_i\le m-i+2$ 且 $d_1\le m$</p>
</li>
<li><p>对于任意 $i\in [1,n]$ 有 $\sum_{j\le i}d_i\ge 2i-1$</p>
</li>
</ol>
<p>证明：先证必要性，条件 1 显然，条件 2 中 $[2,i)$ 中每个点至少向前连 $1$ 条边，即 $d_i\le m-i+2$，条件 3 中 $[1,i]$ 内部至少要连 $i-1$ 条边，$i+1$ 至少向前连 $1$ 条边，即 $\sum_{j\le i}d_i\ge 2(i-1)+1&#x3D;2i-1$</p>
<p>下证充分性，从小到大考虑每个点 $i$，贪心地选一个 $j&lt;i$ 且 $d_j$ 最大的点，并将 $d_i$ 和 $d_j$ 都减去 $1$，此时只需要每个 $d_i\in[0,m-n+1]$ 即可</p>
<p>而条件 3 保证了操作后 $d_i\ge 0$，接下来只需要正 $d_i\le m-n+1$ 即可</p>
<p>若 $d_i&gt;m-n+1$ 且 $i&gt;1$，则所有 $[i,n]$ 中的操作都会导致 $d_i$ 减去 $1$，即原来的 $d_i$ 满足 $d_i&gt;m-n+1+n-i+1&#x3D;m-i+2$，与条件 2 矛盾；若 $i&#x3D;1$ 同样可推出与条件 2 矛盾</p>
<p>考虑构造序列 $c$ 满足 $c_0&#x3D;d_1$，$c_i&#x3D;d_{i+1}-1$</p>
<p>则上面三个条件可以等价地转化为</p>
<ol>
<li><p>$\sum c_i&#x3D;2m-n+1$</p>
</li>
<li><p>对于任意 $i\in[0,n)$ 有 $c_i\le m-i$</p>
</li>
<li><p>对于任意 $i\in[0,n)$ 有 $\sum _{j\le i}c_j\ge i$</p>
</li>
</ol>
<p>性质 3：满足条件 1 和条件 3 的序列 $c$ 至多会有一个位置 $i$ 不满足条件 2</p>
<p>证明：考虑反证，假设序列中有 $i&lt;j$ 都不满足条件 2，则 $i\le \sum_{k\le i}c_k\le \sum c_k-b_i-b_j&#x3D;2m-n+1-(m-i+1)-(m-j+1)&#x3D;i+j-n-1$，即 $j\ge n+1$，矛盾</p>
<p>于是我们先考虑计算满足条件 1 和条件 3 的序列 $c$ 的个数</p>
<p>类似卡特兰数的推导，可以看做从 $(0,0)$ 只向上或向右走到 $(n-1,2m-n+1)$ 且不碰到 $y&#x3D;x-1$ 的方案数，为 $\binom{2m}{n-1}-\binom{2m}{n-2}$</p>
<p>接下来考虑枚举不满足条件 2 的位置 $i$，不难发现 $i$ 之后一定满足条件 3</p>
<p>把 $c_i$ 减去 $m-i+1$，则相当于要求 $\sum c_i&#x3D;m-n+i$，画成图即为求 $(0,0)$ 只向上或向右走到 $(n-1,m-n+i)$，且在 $x&lt;i$ 之前不能碰到 $y&#x3D;x-1$ 的方案数</p>
<p>若 $i&#x3D;0$，则方案数为 $\binom{m-1}{n-1}$</p>
<p>枚举第一次走到 $(k,i)$ 的 $k$，则方案数为 $(\binom{k+i-1}{k}-\binom{k+i-1}{k-1})\binom{m-k-1}{m-n}$</p>
<p>考虑交换 $k$ 和 $i$ 的枚举顺序，则我们希望快速求 $\sum_{i\ge k}\binom{k+i-1}{k}-\binom{k+i-1}{k-1}$</p>
<p>有恒等式 $\sum_{l\le i\le r}\binom{i}{k}&#x3D;\binom{r+1}{k+1}-\binom{l}{k+1}$，上式即可 $\mathcal O(1)$ 求了</p>
<p>时间复杂度 $\mathcal O(n)$</p>
<h3 id="AGC057"><a href="#AGC057" class="headerlink" title="AGC057"></a>AGC057</h3><ul>
<li>A</li>
</ul>
<p>显然最优可以从大到小选，记 $L$ 有 $x$ 位，$R$ 有 $y$ 位</p>
<p>显然 $y$ 位的可以都选，然后考虑 $x&lt;y$ 时可以选哪些</p>
<p>这时候如果 $R$ 的第一位不是 $1$，那么什么数都不能选了，否则可以根据 $R$ 的前 $y-1$ 位，后 $y-1$ 位和 $L$ 决定出还可以选哪些</p>
<p>时间复杂度 $\mathcal O(T\log_{10}w)$</p>
<ul>
<li>B</li>
</ul>
<p>显然每次修改序列中的最小值，对于每个值维护当前值和可能的值的区间，修改的时候可以根据可能值的区间和全局的最大值确定当前值</p>
<p>不断去重复修改的过程，发现最多修改 $\log w$ 轮（一轮指每个数都修改了一次）</p>
<p>时间复杂度 $\mathcal O(n\log n\log w)$</p>
<ul>
<li>C</li>
</ul>
<p>考虑从低位往高位建立 01trie</p>
<p>不难发现 $\operatorname{xor}$ 一个数相当于选几层的 $0,1$ 儿子互换，$+1$ 相当于从根沿着 $1$ 儿子向下走，走过的路径上所有点的 $0,1$ 儿子互换</p>
<p>那么我们可以用一次 $\operatorname{xor}$ 和一次 $+1$ 来实现任选一条根到叶子的路径上所有点 $0,1$ 儿子互换</p>
<p>不妨让单独的 $\operatorname{xor}$ 不能修改最后一层，于是直接拿一次 $\operatorname{xor}$ 和一次 $+1$ 调整好最后一层然后再用一次 $\operatorname{xor} $ 调整其他层即可</p>
<p>时间复杂度 $\mathcal O(2^nn)$</p>
<ul>
<li>D</li>
</ul>
<p>显然对于任意 $x$，都有 $(x,S-x)$ 中最多只能有一个选入了序列中，所以 $n$ 有上界 $\lfloor \frac{S-1}2\rfloor$</p>
<p>而集合 $[S-\lfloor\frac{S-1}2\rfloor+1,S]$ 满足条件，所以 $n&#x3D;\lfloor \frac{S-1}2\rfloor$</p>
<p>接下来考虑构造一组字典序最小的解</p>
<p>我们记集合 $T$ 为序列中 $\le \lfloor \frac{S-1}2\rfloor$ 的数组成的集合</p>
<p>发现集合 $T$ 有如下性质：任取 $x_1,x_2\in T$（$x_1,x_2$ 可以相等），若 $x_1+x_2\le\lfloor\frac{S-1}2\rfloor$ 则 $x_1+x_2\in T$，证明显然</p>
<p>记 $d$ 为 $T$ 中最小的数，则可以把所有 $T$ 中的数按照 $\bmod d$ 的值分类</p>
<p>记 $f_i$ 为 $T$ 中 $\bmod d$ 为 $i$ 的数中最小的那个是多少，显然 $\bmod d $ 为 $i$ 的数中 $\ge f_i$ 的都在 $T$ 中</p>
<p>每次类似 dijkstra，选出一个最小的 $f$ 值然后转移其他 $f$ 值</p>
<p>取一个最小的 $d$，这样选出来的序列就是字典序最小的序列了</p>
<p>不难发现 $d$ 为满足 $d\not|S $ 的最小的数，为 $\mathcal O(\log S)$ 级别</p>
<p>时间复杂度 $\mathcal O(T\log^3 S)$</p>
<ul>
<li>E</li>
</ul>
<p>考虑把矩阵中 $\le k$ 的记作 $0$，$&gt;k$ 的记作 $1$</p>
<p>则行-列排序相当于把每行 $0$ 的个数从大到小排序，列-行排序相当于把每行 $1$ 的个数从小到大排序</p>
<p>则一个矩阵 $A$ 合法当且仅当存在一对排列 $(p,q)$ 使得 $B_{i,j}\le k\Leftrightarrow A_{p_i,q_j}\le k$</p>
<p>考虑对这些排列计数，由于存在若干行 $0$ 的个数相等的情况，所以排列并不和矩阵一一对应，但可以通过除掉若干阶乘来去重</p>
<p>假设我们现在知道了对于 $k-1$ 的排列 $(p^{k-1},q^{k-1})$，考虑计数 $(p^k,q^k)$</p>
<p>不难发现其实 $(p^k,q^k)$ 的数量和 $(p^{k-1},q^{k-1})$ 无关，所以我们只要对于每个 $k$ 数出在 $(p^{k-1},q^{k-1})$ 为单位排列时的数量然后乘起来即可</p>
<p>考虑 $(p^{k-1},q^{k-1})$ 给 $(p^k,q^k)$ 的限制，显然有 $B_{i,j}\le k-1\Rightarrow A_{p_i,q_j}\le k\Rightarrow B_{p_i,q_j}\le k$</p>
<p>记 $a_{i}$ 为第 $i$ 行满足 $B_{i,j}\le k-1$ 的个数，$b_j$ 为第 $j$ 列满足 $B_{i,j}\le k$ 的个数，则这个限制可以写作 $j\le a_i\Rightarrow p_i\le b_{q_j}$</p>
<p>又根据 $b_j$ 单调不增，可得 $p_i\le b_{\max\limits_{j\le a_i}q_j}$</p>
<p>记 $x_i&#x3D;\max\limits_{j\le a_i}q_j$，考虑确定 $x_i$ 时 $(p,q)$ 的数量</p>
<p>先考虑 $x_i$ 对 $p$ 的限制，根据 $a_i$ 单调不增可得 $x_i$ 单调不增，又 $b_j$ 单调不增可得 $b_{x_i}$ 单调不降，即 $b_{x_i}$ 对 $p_i$ 的限制越来越松，则 $b_{x_i}$ 对 $p_i$ 的贡献为 $b_{x_i}-i+1$</p>
<p>接下来考虑 $x_i$ 对 $q_i$ 的限制</p>
<p>若 $x_i&#x3D;x_{i-1}$，则说明 $[a_i+1,a_{i-1}]$ 中的所有 $q_j$ 都有 $q_j&lt;x_i$ 且在 $a_i$ 之前有一个 $q_j&#x3D;x_i$，则 $x_i$ 对 $q$ 的贡献为 $\prod\limits_{j&#x3D;a_i+1}^{a_{i-1}} x_i-1-(j-2)&#x3D;\frac{(x_i-a_i)!}{(x_i-a_{i-1})!}$</p>
<p>若 $x_i&lt;x_{i-1}$，则说明 $[a_i+1,a_{i-1}]$ 中有一个 $q_j&#x3D;x_{i-1}$，其他所有 $q_j$ 都有 $q_j&lt;x_{i-1}$ 且在 $a_i$ 之前有一个 $q_j&#x3D;x_i$，则 $x_i$ 对 $q$ 的贡献为 $\sum\limits_{k&#x3D;a_i+1}^{a_{i-1}}(\prod\limits_{j&#x3D;a_{i}+1}^{k-1}x_{i-1}-1-(j-1))(\prod\limits_{j&#x3D;k+1}^{a_{i-1}}x_{i-1}-1-(j-2))&#x3D;(a_{i-1}-a_i)\frac{(x_{i-1}-a_i-1)!}{(x_{i-1}-a_{i-1})!}$</p>
<p>发现贡献只和相邻两项的 $x$ 有关，所以直接 dp 即可</p>
<p>可以用前缀和优化到 $\mathcal O(n^2w)$，其中 $w$ 为值域</p>
<ul>
<li>F</li>
</ul>
<p>考虑维护中间点的位置和二元组 $(l,r)$ 表示左边点离中间点的距离和右边点离中间点的距离</p>
<p>记数列 $a_i$ 为每次操作时中间点位置变化量的绝对值，不妨设 $\gcd(l,r)&#x3D;1$</p>
<p><img src="https://img.atcoder.jp/agc057/61b3000087dd8839269d74914b8cec53.png"></p>
<p>图中前四列的数列应该向右移一位，第四列的数列应为 $(7,3,3,1)$</p>
<p>考虑 $(1,1)$ 之前的过程</p>
<p>不难发现每一次操作让中间点位置变化了 $\pm a_i$，而二元组 $(l,r)$ 仅取决于最后一次操作取了正值还是负值</p>
<p>所以可以把原问题转化为对于每一个 $i\in[1,n]$，在序列 $a_{1\dots i}$ 中选若干个数，不同的二元组选出数的和和最后一个数选不选的个数</p>
<p>这等价于在 $a_{1\dots i-1}$ 中选出不同的和的数量乘上 $2$</p>
<p>由于这是一个辗转相除的过程，所以考虑把序列压缩一下，变为 $(d_i,e_i)$，表示序列中有连续 $d_i$ 个 $e_i$，不难发现 $e_i&#x3D;d_{i+1}e_{i+1}+e_{i+2}$</p>
<p>考虑这样一种选数的方法：对于第 $i$ 段，若之前没有全选完而第 $i$ 段全选完了，则 $i+1$ 段不能选，这样显然是不重不漏的</p>
<p>记 $f_{i,0&#x2F;1}$ 为第 $i$ 段之前没选完，第 $i$ 段没选完&#x2F;选完的方案数，转移显然</p>
<p>注意总方案数为 $f_{i,0}+f_{i,1}+1$，因为还有第 $i$ 段之前选完且第 $i $ 段选完的方案数</p>
<p>$(1,1)$ 这个位置比较特殊，我们只需要数 $a_{1\dots i}$ 中选出不同的和的方案数即可，不需要乘上 $2$</p>
<p>最后还有 $(0,1)$ 和 $(1,0)$ 两个位置，它们的总方案数一样为 $f_{i,0}+f_{i,1}+1$，而注意 $(0,1)$ 还可以再操作一次到另一个 $(1,0)$，$(1,0)$ 也可以再操作一次到另一个 $(0,1)$，所以答案要再加上 $2$</p>
<h3 id="AGC058"><a href="#AGC058" class="headerlink" title="AGC058"></a>AGC058</h3><ul>
<li>A</li>
</ul>
<p>考虑根据数值从小到大对于偶数位置进行调整，若其为峰则不用管，否则把它两边一个比它大的换过来</p>
<p>不难发现每次操作之后不满足条件的数一定会至少增加 $2$，即可满足条件</p>
<p>时间复杂度 $\mathcal O(n)$</p>
<ul>
<li>B</li>
</ul>
<p>记 $[l_i,r_i]$ 为数值 $i$ 能覆盖到的范围，$f_{i,j}$ 为第 $i$ 个数被数值 $j$ 覆盖的方案数</p>
<p>转移的时候考虑 $j$ 在 $i$ 前面还是在 $i$ 后面，如果在前面则要求前一个的数值 $\ge j$，在后面则要求前面的值被前面覆盖或者被 $&lt;j$</p>
<p>用前缀和优化即可，时间复杂度 $\mathcal O(n^2)$</p>
<ul>
<li>C</li>
</ul>
<p>显然如果有相邻的 $1,2$ 可以把 $1$ 删掉不影响答案，如果有相邻的 $3,4$ 可以把 $4$ 删掉不影响答案，如果有相邻的两个数相同可以把其中一个删掉不影响答案</p>
<p>称一个序列「标准」当且仅当它不能进行以上操作</p>
<p>由于最后要形成的是一棵树，所以我们一定可以找到一个叶子使得它的父亲与它相邻</p>
<p>由于标准序列中 $1,2$ 不相邻，$3,4$ 不相邻，则这个叶子和父亲一定不可能是 $1$ 或 $4$，所以只要考虑相邻的 $2,3$ 即可</p>
<p>不妨设叶子为 $2$，和它的父亲节点为 $3$，考虑和 $2$ 相邻的另一个数是多少</p>
<p>若这个数为 $3$，则把 $2$ 删掉之后可以把 $3$ 一起删掉，这样操作之后序列仍然是标准的；若这个树为 $4$，同样把 $2$ 删掉之后可以把 $4$ 一起删掉</p>
<p>此时我们每次的操作即为删除一对相邻的 $2,3$，相邻的 $2,4$ 和相邻的 $1,3$</p>
<p>显然一个序列合法当且仅当其中 $2$ 的个数 $\ge 4$ 的个数且 $3$ 的个数 $\ge 1$ 的个数</p>
<p>于是把给定的序列变为标准序列，之后统计其中每个数出现的次数即可</p>
<p>时间复杂度 $\mathcal O(n)$</p>
<ul>
<li>D</li>
</ul>
<p>考虑容斥</p>
<p>每次选择一些位置放不合法的字符串，不难发现它们会把序列分成一些连续段，不妨设这些连续段的长度为 $L_1,\dots,L_k$</p>
<p>接下来我们考虑对每个 $L$ 算出它的容斥系数，即为 $c_L$，显然 $c_1&#x3D;1,c_2&#x3D;0$</p>
<p>对于 $L\ge 3$ 的 $c_L$，它其实为 $-(\sum\limits_{\sum l_i&#x3D;L}\prod c_{l_i})$，不妨枚举最后一个 $l$ 的长度，不难发现其实只有 $l&#x3D;L-1$ 和 $l&#x3D;L-2$ 时会产生贡献，其他时候 $c_{L-l}$ 都会和把 $L-l$ 继续分拆产生的系数抵消</p>
<p>所以有 $c_L&#x3D;-(c_{L-1}+c_{L-2})$，归纳可得 $c$ 的通项：</p>
<p>$$<br>c_L&#x3D;\begin{cases}<br>1&amp;(L\equiv 1\pmod 3)\cr0&amp;(L\equiv 2\pmod 3)\cr-1&amp;(L\equiv 0\pmod 3)<br>\end{cases}<br>$$</p>
<p>所以只要考虑 $3k$ 和 $3k+1$ 长度的子段对序列的贡献即可，不难发现 $3k$ 长度的子段相当于把剩下的 <code>ABC</code> 个数全部减 $k$，并且有三种排列方式；$3k+1$ 长度的子段相当于把剩下的 <code>ABC</code> 个数全部减 $k$，并把其中一个额外减去 $1$，只有一种排列方式</p>
<p>记 $f_{i,j}$ 为序列前 $i$ 项，执行了 $j$ 次全部减去 $1$ 的操作的方案数，有转移：$f_{i,j}&#x3D;\sum\limits_{k&#x3D;1}^i([k\equiv 1\pmod 3]f_{i-k,j-\frac{k-1}3}-3[k\equiv 0\pmod 3]f_{i-k,j-\frac k3})$</p>
<p>记 $n&#x3D;a+b+c$，那么答案即为 $\sum \frac{(n-3i)!}{(a-i)!(b-i)!(c-i)!}f_{n,i}$</p>
<p>考虑 $f$ 的二元生成函数 $F(x,y)$，则 $F(x,y)&#x3D;\sum_i(x+\sum_{k\ge 1}x^{3k+1}y^k-3x^{3k}y^k)^i&#x3D;\frac{1-x^3y}{1-x+2x^3y}$</p>
<p>记 $G(x,y)&#x3D;\frac 1{1-x+2x^3y}$，则 $[x^ny^m]F(x,y)&#x3D;[x^ny^m]G(x,y)-[x^{n-3}y^{m-1}]G(x,y)$，所以我们只需要考虑计算 $G$ 即可</p>
<p>显然 $G(x,y)&#x3D;\sum_i(x-2x^3y)^i$，那么 $[x^ny^m]G(x,y)&#x3D;\binom{n-2m}{m}(-2)^m$</p>
<p>于是我们即可在 $\mathcal O(1)$ 时间内求出 $[x^ny^m]F(x,y)$ 的值</p>
<p>总复杂度 $\mathcal O(n)$</p>
<ul>
<li>E</li>
</ul>
<p>为了方便，以下下标及值域均为 $[0,n)$</p>
<p>先考虑对于一个 $x$ 如何求 $f(x)$，每一次我们都希望尽可能地把 $x$ 中最小的那个提到前面，于是有以下算法：</p>
<ol>
<li><p>记 $inv$ 为 $x$ 的逆序对数，$s&#x3D;\frac {inv}2$，答案序列初始为空</p>
</li>
<li><p>进行以下操作 $n$ 次（称其为操作 1）：找到 $\min{x_0,\dots,x_{\lfloor s\rfloor}}$，记其下标为 $i$，给 $s$ 减去 $i$，把 $x_i$ 加入答案序列，并将其从 $x$ 中删除</p>
</li>
</ol>
<p>最终得到的答案序列即为 $f(x)$ 的结果</p>
<p>记 $k$ 为第一次出现 $A_{k}&gt;A_{k+1}$ 的地方，若不存在则 $A$ 显然一定合法</p>
<p>不难发现经过 $k$ 次操作 1 之后的 $x$ 序列和 $s$ 一定满足以下条件：</p>
<ol>
<li><p>$x_0&#x3D;A_k$，$x_{\lfloor s\rfloor+1}&#x3D;A_{k+1}$</p>
</li>
<li><p>$x_0&#x3D;\min{x_0,\dots,x_{\lfloor s\rfloor}}$</p>
</li>
<li><p>将 $A_k,A_{k+1}$ 从 $x$ 序列中去掉后剩下的 $x$ 序列一定是 $A_{k+2},A_{k+3},\dots,A_{n}$</p>
</li>
</ol>
<p>那么经过 $f$ 变化之后变成 $A$ 的序列 $B$ 一定可以通过以下操作得到：</p>
<ol>
<li><p>初始令 $B&#x3D;A$</p>
</li>
<li><p>从大到小遍历 $k+1,k-1,k-2,\dots,1$，每次可以把 $B_i$ 向后移 $j$ 个位置，其中 $j$ 要满足 $\forall x\in[1,j]$ 有 $B_i&lt;B_{i+x}$，若此时 $i&#x3D;k+1$ 则还要满足 $\forall x\in[1,j]$，$A_k&lt;B_{i+x}$</p>
</li>
</ol>
<p>记每个 $B_i$ 向后移的距离为 $c_i$，现在的目标即为确定 $c_i$</p>
<p>不妨考虑 $\Delta&#x3D;s-p$，其中 $s,p$ 为 $k+1$ 次操作 1 之后的 $s$ 和 $A_k$ 所在 $x$ 序列中的位置，我们希望 $\Delta&#x3D;0\lor \Delta&#x3D;\frac 12$</p>
<p>考虑 $c_i$ 增加 $1$ 对 $\Delta$ 的影响：</p>
<ol>
<li><p>若 $i\not&#x3D;k+1$，则 $c_i$ 增加 $1$ 会导致原来序列中的逆序对个数增加 $1$，在第 $i$ 次操作 1 中 $s$ 多减少 $1$，总共会导致 $\Delta$ 减少 $\frac 12$</p>
</li>
<li><p>若 $i&#x3D;k+1$，则 $c_i$ 增加 $1$ 会导致原来序列中的逆序对个数增加 $1$，同时 $p$ 增加 $1$，总共会导致 $\Delta$ 减少 $\frac 12$</p>
</li>
</ol>
<p>综上，每个 $c_i$ 增加 $1$ 都会导致 $\Delta$ 减少 $\frac 12$</p>
<p>当 $\sum c_i$ 为 $0$ 时显然 $\Delta&#x3D;\frac{inv}2$，我们只需要检验 $\sum c_i&#x3D;inv-1$ 和 $\sum c_i&#x3D;inv$ 时是否存在一组合法的 $c$ 即可</p>
<p>确定 $\sum c_i$ 之后，可以确定原来序列中的逆序对个数，考虑对于 $A_1,A_2,\dots,A_{k-1},A_{k+1}$ 中的每个数从小到大贪心地确定 $c_i$ 的大小（即 $c_i$ 取到能保证合法的最大值），不难发现这一定是最优的</p>
<p>在确定 $c_i$ 的同时判断是否满足最开始的算法中的条件即可</p>
<p>时间复杂度 $\mathcal O(n\log n)$，瓶颈在求逆序对数量</p>
<ul>
<li>F</li>
</ul>
<p>神仙题（</p>
<p>题面直接把要求的式子给出来了，显然要考虑这个式子有什么组合含义</p>
<p>考虑在每条边上新加一个点，称其为「特殊点」，在每个特殊点下添加 $p-1$ 个叶子节点，记此时共有 $m$ 个节点，$m&#x3D;(n-1)p+n$</p>
<p>给每个节点分配一个 $[1,m]$ 中的权值，并且所有点权值互不相同（即构成一个 $[1,m]$ 中的排列）</p>
<p>考虑计算此时每个特殊点点权都比周围的点点权大的概率，对于树 $t$，记其为 $P(t)$</p>
<p>考虑枚举最大点权所在的位置，可以得到转移 $P(t)&#x3D;\frac{\sum_{e\in t}P(t_x(e))P(t_y(e))}m$</p>
<p>又在 $\bmod p$ 意义下 $m$ 与 $n$ 相等，可得 $f(t)\equiv P(t)\pmod p$，所以我们只需要计算 $P(t)$ 即可</p>
<p>考虑容斥，钦定一个点为根，保留每个特殊点点权大于儿子点权的限制，对特殊点点权大于父亲点权的限制进行容斥</p>
<p>此时树被分成了若干连通块，每个连通块内相当于求一个排列为一个合法的拓扑序的概率，它等于每个子树大小的倒数乘积</p>
<p>于是 dp 时维护子树大小即可，记 $f_{u,k}$ 为 $u$ 子树内选了 $k$ 个点的方案数，类似树上背包进行转移</p>
<p>发现对于每一条边都会新建出来 $p$ 个节点，在 $\bmod p$ 意义下对子树大小没有影响，所以可以直接在原树上进行 dp</p>
<p>时间复杂度 $\mathcal O(n^2)$</p>
<h3 id="AGC059"><a href="#AGC059" class="headerlink" title="AGC059"></a>AGC059</h3><ul>
<li>A</li>
</ul>
<p>考虑一个字符串 $s$ 该怎么做</p>
<p>首先把 $s$ 放在一个环上，即 $s_{n+1}&#x3D;s_1$，记 $c&#x3D;\sum[s_i\not&#x3D; s_{i+1}]$</p>
<p>显然每次操作最多让 $c$ 减少 $2$，所以答案至少为 $\lceil \frac c2\rceil$</p>
<p>若 $c\ge 4$，则根据抽屉原理，一定可以找到一对相邻两个字符不同的位置 $i,j$，使得无序对 $(s_i,s_{i+1})$ 和 $(s_j,s_{j+1})$ 相同，在这个区间中交换 $s_i,s_{i+1}$ 两个字符即可将 $c$ 减少 $2$</p>
<p>若 $c\le 3$，显然成立</p>
<p>所以用前缀和为区间 $c$ 值即可，时间复杂度 $\mathcal O(n)$</p>
<ul>
<li>B</li>
</ul>
<p>考虑每次取出现次数最多的数，然后隔一个数向其中不断插入出现次数最少的数</p>
<p>若当前出现次数最多的数放不下所有的数，就把已经它和已经放进去的数组成的序列当成一个新的数，然后继续这个过程即可</p>
<p>时间复杂度 $\mathcal O(n\log n)$</p>
<ul>
<li>C</li>
</ul>
<p>建立一个 $n$ 个点的竞赛图 $G$，对于 $i&lt;j$，若 $p_i&lt;p_j$ 则连 $i\to j$，记为 $0$ 类边；否则连 $i\leftarrow j$，记为 $1$ 类边</p>
<p>显然一个无环的竞赛图一一对应一个排列</p>
<p>记 $t_{i,j}$ 为 $(i,j)$ 询问的时间，对于 $i&lt;j&lt;k$，对询问它们的时间分类讨论：</p>
<ol>
<li><p>若 $t_{i,k}$ 最大，则要求 $(i,j),(j,k)$ 的边种类不同</p>
</li>
<li><p>若 $t_{i,j}$ 最大，则要求 $(j,k),(i,k)$ 的边种类相同</p>
</li>
<li><p>若 $t_{j,k}$ 最大，则要求 $(i,j),(i,k)$ 的边种类相同</p>
</li>
</ol>
<p>这可以用一个带边权的并查集维护</p>
<p>若合并的过程中没有出现矛盾，则答案即为 $2^c$，其中 $c$ 为连通块个数</p>
<p>时间复杂度 $\mathcal O(n\alpha(n))$</p>
<ul>
<li>D</li>
</ul>
<p>显然 $|b_i-b_{i+1}|\le 1$，可以先把不符合条件的判掉</p>
<p>记 $ql_i$ 为 $i$ 是否在左边 $k$ 个中出现过；同样定义 $qr_i$</p>
<p>此时我们希望让 $i&lt;j,qr_i&#x3D;ql_j&#x3D;1$ 匹配，使得所有 $ql_i&#x3D;1$ 和 $qr_i&#x3D;1$ 的位置都被匹配</p>
<p>显然这直接贪心找第一个没匹配的 $i$ 和 $j$ 匹配即可，接下来的问题即为如何确定 $ql_i$ 和 $qr_i$</p>
<ol>
<li><p>若 $b_i&#x3D;b_{i+1}+1$，则 $ql_{i+k}&#x3D;1,qr_i&#x3D;0$</p>
</li>
<li><p>若 $b_i+1&#x3D;b_{i+1}$，则 $ql_{i+k}&#x3D;0,qr_i&#x3D;1$</p>
</li>
<li><p>若 $b_i&#x3D;b_{i+1}&#x3D;k$，则 $ql_{i+k}&#x3D;qr_i&#x3D;0$</p>
</li>
<li><p>若 $b_i&#x3D;b_{i+1}&lt;k$，则此时只要求 $ql_{i+k}&#x3D;qr_i$</p>
</li>
</ol>
<p>结论：若 $b_{i}&#x3D;b_{i+1}&lt;k$，则令 $ql_{i+k}&#x3D;qr_i&#x3D;1$ 一定可行</p>
<p>证明：$b_i&#x3D;b_{i+1}&lt;k$ 可以推出 $a_{i+1},\dots,a_{i+k-1}$ 中一定有两个相同的数，记为 $a_p,a_q(p&lt;q)$，则我们一定可以让 $(i,p),(q,i+k)$ 两两配对达成同样的效果</p>
<p>确定 $ql,qr$ 之后直接贪心匹配即可</p>
<p>时间复杂度 $\mathcal O(n)$</p>
<ul>
<li>E</li>
</ul>
<p>记颜色矩阵为 $col$，构造一个满足以下条件的矩阵 $a$：</p>
<ol>
<li><p>$a_{i,j}\equiv col_{i,j}\pmod 3$</p>
</li>
<li><p>相邻两个 $a$ 值相差 $1$</p>
</li>
</ol>
<p>若 $a_{1,1}$ 确定，则不难发现一个合法的三染色矩阵 $col$ 与 $a$ 一一对应</p>
<p>显然我们可以确定周围一圈的 $a$ 值，显然 $|a_{1,1}-a_{2,1}|\not&#x3D;1$ 时无解</p>
<p>对于每行每列，显然要求 $|a_{i,1}-a_{i,n}|\le n-1\land |a_{1,i}-a_{n,i}|\le n-1$，这是一个必要条件，接下来通过构造证明它的充分性</p>
<p>构造 $a_{i,j}&#x3D;\min{a_{i,1}+(j-1),a_{i,n}+(n-j),a_{1,j}+(i-1),a_{n,j}+(n-i)}$，不难发现它是一个合法的 $a$ 矩阵</p>
<p>时间复杂度 $\mathcal O(n)$</p>
<ul>
<li>F</li>
</ul>
<p>首先考虑没有 $pos$ 和 $val$ 限制下该如何计算答案</p>
<p>结论：$LIS+LDS&#x3D;n+1$ 的排列一共有 $\binom{2n-2}{n-1}$ 个</p>
<p>证明：考虑对一个排列构造一个标准杨表，那么这个排列的 $LIS+LDS$ 即为第一行长度加上第一列长度，即这个杨表一定只有第一行和第一列</p>
<p>根据 Robinson-Schensted correspondence，两个形态相同的杨表和排列一一对应</p>
<p>于是满足 $LIS+LDS&#x3D;n+1$ 的排列一共有 $\sum (\frac {n!}{n(i-1)!(n-i)!})^2&#x3D;\binom{2n-2}{n-1}$ 个</p>
<p>这提示我们去找一个同样有 $\binom{2n-2}{n-1}$ 种方案的选择方式和 $LIS+LDS&#x3D;n+1$ 的序列一一对应</p>
<p>考虑把排列画到一个 $n\times n$ 的网格图上，规定左上-右下方向为递减，左下-右上方向为递增</p>
<p>考虑构成这个网格图的 $n-1$ 条横分割线和 $n-1$ 条竖分割线，在其中选择 $k$ 条横分割线和 $k$ 条竖分割线染黑，这样一共有 $\binom{2n-2}{n-1}$ 种选择方式，接下来考虑如何把它和 $LIS+LDS&#x3D;n+1$ 的排列一一对应</p>
<p>记 $(i,j)$ 为第 $i$ 行第 $j$ 列的<strong>格点</strong>，$[i,j]$ 为第 $i$ 条横分割线和第 $j$ 条竖分割线的<strong>交点</strong></p>
<p>把从上往下每条黑线和<strong>从左往右</strong>每条黑线匹配，并把它们的交点染黑；把从上往下每条白线和<strong>从右往左</strong>每条白线匹配，并把它们的交点染白，那么这张图上一共有 $k$ 个黑点和 $n-k$ 个白点</p>
<p>接下来如下为格点染色：</p>
<ol>
<li><p>对于黑点 $[i,j]$，若其左上部分没有白点，则将 $(i,j)$ 染黑；若其右下部分没有白点，则将 $(i+1,j+1)$ 染黑</p>
</li>
<li><p>对于白点 $[i,j]$，若其右上部分没有黑点，则将 $(i,j+1)$ 染白；若其左下部分没有黑点，则将 $(i+1,j)$ 染白</p>
</li>
</ol>
<p>对于这样的格点染色方式，有如下性质：</p>
<p>性质 $1$：所有黑格&#x2F;黑点单调递减，所有白格&#x2F;白点单调递增</p>
<p>性质 $2$：若黑点 $[i,j]$ 左上方格被染黑，则 $[i,j]$ 左上方所有的黑点左上方格都被染黑；右下方向同理；对白点同理</p>
<p>性质 $3$：对于黑点 $[i,j]$，$(i,j)$ 与 $(i+1,j+1)$ 中至少有一个被染黑；对白点同理</p>
<p>证明：考虑反证，若黑点 $[i,j]$ 左上方格和右下方格都没被染黑，则说明 $[i,j]$ 左上方和右下方都有白点，与性质 $1$ 矛盾</p>
<p>性质 $4$：不存在一个点既被染黑又被染白（否则一条线上有两个被染色的点）</p>
<p>性质 $5$：不存在一行&#x2F;一列上有两个格点被染成了不同颜色</p>
<p>证明：考虑反证，假设 $(i,j_1)$ 被染成了黑色，$(i,j_2)$ 被染成了白色，不妨设 $j_1&lt;j_2$</p>
<p>那么一定有 $[i-1,j_1-1]$ 为黑点，$[i,j_2-1]$ 为白点或 $[i,j_1]$ 为黑点，$[i-1,j_2]$ 为白点</p>
<p>无论哪种情况都与格点的染色方式矛盾</p>
<p>性质 $6$：不存在一行&#x2F;一列上有两个格点被染成了相同颜色</p>
<p>证明：考虑反证，假设 $(i,j_1),(i,j_2),j_1&lt;j_2$ 同时被染黑，则显然 $[i-1,j_1-1],[i,j_2]$ 均为黑点</p>
<p>由于 $j_1-1$ 和 $j_2$ 为两条相邻的黑竖线，所以它们当中必然有一条白竖线，也就必然有白点</p>
<p>而无论白点在哪里都与格点的染色方式矛盾</p>
<p>于是在把格点染色过后，不存在一行&#x2F;一列上有两个被染色的格点，并且至少有 $n-1$ 个格点被染色了</p>
<p>如果有 $n$ 个格点被染色，则这 $n$ 个格点组成一个排列，并且至少有一个黑点的左上格和右下格均被染黑或一个白点的左下格和右上格均被染白</p>
<p>不妨设有一个黑点 $[i,j]$ 的左上格和右下格均被染黑，那么由性质 $1$ 可得这个排列的 $LDS&#x3D;k+1$，而由于白点均在 $[i,j]$ 右上方或左下方，所以 $(i,j)$ 一定可以加入 $LIS$ 中，即 $LIS&#x3D;n-k$，满足条件</p>
<p>如果有 $n-1$ 个格点被染色，记还没有格点被染色的行为 $i$，列为 $j$，并将 $(i,j)$ 染成灰色，此时 $n$ 个染色的格点构成排列</p>
<p>性质 $7$：被 $(i,j)$ 左上方的黑点染黑的格点只有左上格；左下方白点，右下方黑点，右上方白点同理</p>
<p>证明：考虑反证，假设在 $(i,j)$ 左上方的黑点 $[p,q]$ 右下格被它染黑，则第 $i-1$ 条横线不能是黑线（否则根据性质 $2$ 可得第 $i$ 行有格点被染黑）</p>
<p>所以第 $i-1$ 条横线必然是白线，且这条白线上的白点一定在 $[p,q]$ 左下方，而根据性质 $3$，由于这个白点右上方有黑点，所以它的左下格一定被染白，而左下格在第 $i$ 行上，矛盾</p>
<p>性质 $8$：$(i,j)$ 左上方只有黑点，右上方只有白点，左下方只有白点，右下方只有黑点</p>
<p>证明：考虑反证，假设在 $(i,j)$ 左上方有白点 $[p,q]$，不妨它的左下格被它染白了</p>
<p>对于第 $i-1$ 条横线，若其为白线，则根据性质 $1$，白点一定在 $[p,q]$ 左下方，根据性质 $2$，这个白点的左下格一定被染白，而这个染白的格点在第 $i$ 行，矛盾；否则由于 $[p,q]$ 左下方被它染白，说明这条线上的黑点一定在 $[p,q]$ 右下方，由于这个黑点左上方有白点，所以由性质 $3$，它的右下格被染黑，而这个格点在第 $i$ 行，矛盾</p>
<p>此时这个排列的 $LDS&#x3D;k+1$，$LIS&#x3D;n-k$，同样满足条件</p>
<p>这样我们就证明了线染色到合法排列的映射，接下来通过构造证明合法排列到线染色的映射</p>
<p>对于一个合法排列 $p$，若它的 $LIS$ 和 $LDS$ 都确定，则令它们的交为灰色格点</p>
<p>灰色格点左上方显然单调递减，所以令这些格点右下角的交点为黑色交点，其他方向同理，显然这样的线染色方式合法</p>
<p>若 $LIS$ 和 $LDS$ 不确定，则它们可能的交一定为一段值连续的递增&#x2F;递减序列，不妨设是递减序列，记长度为 $l$，那么我们将这个递减序列的前 $l-1$ 个格子的右下角定位黑色交点</p>
<p>由于值连续，所以存在一个 $l\times l$ 且以这段序列为对角线的正方形，把整个正方形看成前面的灰色格点，和前面一样构造即可</p>
<p>这样我们证明了每个合法排列都可以映射到一组线染色，又线染色方案数和合法排列数相同，可以推出线染色和合法排列一一对应</p>
<p>回到原问题，原题即要求一个格点 $(x,y)$ 一定要被染色</p>
<p>若 $(x,y)$ 被染黑，不妨设它被黑点 $[x-1,y-1]$ 染黑，考虑枚举第 $x-1$ 条横线上方的黑线数量 $i$（包含第 $x-1$ 条横线）</p>
<p>由于 $[x-1,y-1]$ 右下方不能有白点，所以要求白横线数量 $n-k-1 \le (x-i-1)+(y-i-1)$ 即 $k\ge n+2i-x-y+1$，也即除了 $i$ 条黑线以外还有至少 $n+i-x-y+1$ 条黑线</p>
<p>同样计算 $(x,y)$ 被 $[x,y]$ 染黑的方案数，再减去同时被 $[x-1,y-1]$ 和 $[x,y]$ 染黑的方案数</p>
<p>对于 $(x,y)$ 被染白和 $(x,y)$ 被染灰的方案数可以同样计算，但这样需要很多容斥，非常麻烦</p>
<p>不难发现 $(x,y)$ 同时被 $[x,y]$ 和 $[x-1,y-1]$ 染黑的要求是除了上方的 $i$ 条黑线以外还有恰好 $n+i-x-y+1$ 条黑线，$(x,y)$ 染灰的要求也是这样</p>
<p>所以我们不妨在之前单独算被 $[x-1,y-1]$ 染黑的情况时把恰好 $n+i-x-y+1$ 条黑线的情况去掉，放到后面一起统计，这样就不需要容斥了</p>
<p>时间复杂度 $\mathcal O(n)$</p>
<h3 id="AGC060"><a href="#AGC060" class="headerlink" title="AGC060"></a>AGC060</h3><ul>
<li>A</li>
</ul>
<p>对于每个长度为 $3$ 的子串，显然要求这个子串中不存在两个相同的字符</p>
<p>对于每个长度 $&gt;3$ 的子串的要求显然比对长度为 $3$ 的子串弱，所以只需要考虑对长度为 $3$ 的子串的要求即可</p>
<p>记 $f_{i,j,k}$ 表示考虑前 $i$ 个字符，第 $i$ 个字符为 $j$，第 $i-1$ 个字符为 $k$ 的方案数</p>
<p>时间复杂度 $\mathcal O(n|\Sigma|^3)$</p>
<ul>
<li>B</li>
</ul>
<p>考虑在原串中提取出尽可能多的不交的 <code>DR</code> 或 <code>RD</code> 子串，记数量为 $c$</p>
<p>则 $c\le k$ 显然为合法的必要条件，接下来通过构造证明其充分</p>
<p>对于分出来的一个 <code>DR</code> 或 <code>RD</code> 子串，分配一个新的二进制位，并把路径外的拐角处填入这个二进制位，并沿对角线延伸；若出现 <code>DRD</code> 或 <code>RDR</code> 的形态，则在后面一个拐角处也填入这个二进制位，并沿对角线延伸</p>
<p>例子（路径为 <code>DRDRRRDRRR</code>）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#1.2...4</span><br><span class="line">##2...4.</span><br><span class="line">1####4..</span><br><span class="line">...4####</span><br></pre></td></tr></table></figure>

<p>时间复杂度 $\mathcal O(Tn)$</p>
<ul>
<li>C</li>
</ul>
<p>把这个问题放到满二叉树上考虑</p>
<p>将所有节点按照它的权值大小排序相当于对这个满二叉树做了一次拓扑排序</p>
<p>所以 $p_u&lt;p_v$ 的要求可以被转化为有多少拓扑序满足 $u$ 的拓扑序比 $v$ 的拓扑序小</p>
<p>不难发现 $u$ 点为深度为 $a+1$ 的点中最左边的点，$v$ 点为深度为 $b+1$ 的点中最右边的点，而满二叉树的拓扑序第一个一定是它的根，之后 $u$ 和 $v$ 就被分到独立的子树中了</p>
<p>记 $f_{i,j}$ 为 $u$ 对应的是深度为 $i$ 的满二叉树，$v$ 对应的是深度为 $j$ 的满二叉树，$u$ 在拓扑序中在 $v$ 的前面的概率，显然有边界 $f_{n-a-1,j}&#x3D;[j\ge n-b]$</p>
<p>直接算概率不好算，考虑先算方案数，记 $g_{i,j}$ 为 $u$ 对应的是深度为 $i$ 的满二叉树，$v$ 对应的是深度为 $j$ 的满二叉树，$u$ 在拓扑序中在 $v$ 的前面的方案数；$h_i$ 为深度为 $i$ 的满二叉树对应的拓扑序个数，显然 $h_i&#x3D;{h_{i-1}}^2\binom{2^{i}-2}{2^{i-1}-1}$</p>
<p>对于 $g$，考虑选择一个根之后会产生一个不相关的子树，把这个不相关子树去掉，之后用组合数乘进来即可：$g_{i,j}&#x3D;g_{i-1,j}h_{i-1}\binom{2^i+2^j-3}{2^{i-1}-1}+g_{i,j-1}h_{j-1}\binom{2^i+2^j-3}{2^{j-1}-1}$</p>
<p>接下来就可以计算 $f$ 了：</p>
<p>$$<br>\begin{aligned}<br>f_{i,j}&amp;&#x3D;\frac{g_{i,j}}{h_ih_j\binom{2^i+2^j-2}{2^i-1}}\cr<br>&amp;&#x3D;\frac{g_{i-1,j}h_{i-1}\binom{2^i+2^j-3}{2^{i-1}-1}+g_{i,j-1}h_{j-1}\binom{2^i+2^j-3}{2^{j-1}-1}}{h_ih_j\binom{2^i+2^j-2}{2^i-1}}\cr<br>&amp;&#x3D;\frac{f_{i-1,j}{h_{i-1}}^2h_j\binom{2^{i-1}+2^j-2}{2^{i-1}-1}\binom{2^i+2^j-3}{2^{i-1}-1}+f_{i,j-1}h_i{h_{j-1}}^2\binom{2^i+2^{j-1}-2}{2^i-1}\binom{2^i+2^j-3}{2^{j-1}-1}}{h_ih_j\binom{2^i+2^j-2}{2^i-1}}\cr<br>&amp;&#x3D;f_{i-1,j}\frac{\binom{2^{i-1}+2^j-2}{2^{i-1}-1}\binom{2^i+2^j-3}{2^{i-1}-1}}{\binom{2^i-2}{2^{i-1}-1}\binom{2^i+2^j-2}{2^i-1}}+<br>f_{i,j-1}\frac{\binom{2^i+2^{j-1}-2}{2^i-1}\binom{2^i+2^j-3}{2^{j-1}-1}}{\binom{2^j-2}{2^{j-1}-1}\binom{2^i+2^j-2}{2^i-1}}<br>\end{aligned}<br>$$</p>
<p>记 $P(i-1,j)&#x3D;\frac{\binom{2^{i-1}+2^j-2}{2^{i-1}-1}\binom{2^i+2^j-3}{2^{i-1}-1}}{\binom{2^i-2}{2^{i-1}-1}\binom{2^i+2^j-2}{2^i-1}}$，则有：</p>
<p>$$<br>\begin{aligned}<br>P(i-1,j)&amp;&#x3D;\frac{\binom{2^{i-1}+2^j-2}{2^{i-1}-1}\binom{2^i+2^j-3}{2^{i-1}-1}}{\binom{2^i-2}{2^{i-1}-1}\binom{2^i+2^j-2}{2^i-1}}\cr<br>&amp;&#x3D;\frac{(2^{i-1}+2^j-2)!(2^i+2^j-3)!(2^{i-1}-1)!^2(2^i-1)!(2^j-1)!}<br>{(2^i-2)!(2^i+2^j-2)!(2^{i-1}-1)!(2^j-1)!(2^{i-1}-1)!(2^{i-1}+2^j-2)!}\cr<br>&amp;&#x3D;\frac{2^i-1}{2^i+2^j-2}<br>\end{aligned}<br>$$</p>
<p>那么 $f_{i,j}&#x3D;P(i-1,j)f_{i-1,j}+P(i,j-1)f_{i,j-1}$ 可以在 $\mathcal O(\log p)$ 的时间内完成转移</p>
<p>时间复杂度 $\mathcal O(n^2\log p)$</p>
<ul>
<li>D</li>
</ul>
<p><del>D 放多项式题，不好评价（</del></p>
<p>考虑把所有的 <code>&gt;</code> 容斥为 <code>&lt;</code> 或无限制，记 $f(S)$ 为一个序列中无限制的集合为 $S(S\subseteq[1,n-1])$，序列的方案数</p>
<p>记 $S$ 把序列分成的连续单调递增段长度为 $l_1,l_2,\dots l_k$，则 $f(S)&#x3D;\binom{n}{l_1,l_2,\dots,l_k}$</p>
<p>那么答案可以表示为：</p>
<p>$$<br>\begin{aligned}<br>&amp;\sum_{S\subseteq[1,n-1]}(\sum_{T\subseteq S}(-1)^{|S|-|T|}f(T))^2\cr<br>&#x3D;&amp;\sum_{T_1,T_2\subseteq[1,n-1]}(-1)^{|T_1|+|T_2|}2^{n-1-|T_1\cup T_2|}f(T_1)f(T_2)\cr<br>&#x3D;&amp;2^{n-1}\sum_{S\subseteq[1,n-1]}2^{|S|}\sum_{T_1\cap T_2&#x3D;S}\frac{f(T_1)}{(-2)^{|T_1|}}\frac{f(T_2)}{(-2)^{|T_2|}}\cr<br>&#x3D;&amp;2^{n+1}\sum_{S\subseteq[1,n-1]}\sum_{S\subseteq T1,T2}\frac{f(T_1)}{(-2)^{|T_1|+1}}\frac{f(T_2)}{(-2)^{|T_2|+1}}<br>\end{aligned}<br>$$</p>
<p>考虑这个式子的组合意义，第一个求和相当于把序列分成若干段，第二个求和相当于在 $S$ 的基础上再把每小段序列细分成若干段，每段的贡献为 $-\frac 12$，分段均在多重组合数意义下完成</p>
<p>考虑用 EGF 计算，先考虑第二个求和，记把长度为 $i$ 序列分成若干段的 EGF 为 $H$，则 $H(x)&#x3D;\frac{1}{1-(-\frac 12\sum_{i\ge1}\frac{x^i}{i!})}$</p>
<p>第二个求和需要对两个独立等长的小段同时分段，记此时的 EGF 为 $G$，则 $[\frac {x^i}{(i!)^2}]G(x)&#x3D;([\frac {x^i}{i!}]H(x))^2$</p>
<p>第一个求和需要把长度为 $n$ 分成若干段，记此时的 EGF 为 $F$，则 $F(x)&#x3D;\frac{1}{1-G(x)}$</p>
<p>答案即为 $2^{n+1}[\frac{x^n}{(n!)^2}]F(x)$</p>
<p>时间复杂度 $\mathcal O(n\log n)$</p>
<ul>
<li>E</li>
</ul>
<p>由于交换 $x$ 中的两个数会使 $y$ 中的两个数发生交换，所以一次交换对 $f(x)+f(y)$ 的影响只可能为 $-2,0,2$ 中的一个，于是 $k$ 的奇偶性不对的一定无解</p>
<p>结论 $1$：$f(x)+f(y)$ 最大值为 $f(p)+n$</p>
<p>证明：当 $x_i&#x3D;i$ 时 $f(x)+f(y)$ 取到最大值，下证 $f(x)+f(y)\le f(p)+n$</p>
<p>考虑反证，若 $f(x)+f(y)&gt;f(p)+n$，我们考虑找到一个 $i\not&#x3D;x_i$（若找不到则矛盾），记 $x_j&#x3D;i$，交换 $x_i,x_j$，此时 $f(x)$ 一定会变大 $1$，进行有限多次交换之后一定会使 $\forall i,x_i&#x3D;i$，矛盾</p>
<p>结论 $2$：$f(x)+f(y)$ 最小值为 $2$ 或 $3$</p>
<p>证明：显然 $f(x)+f(y)\ge 2$，接下来通过构造证明 $f(x)+f(y)$ 能取到 $2$ 或 $3$</p>
<p>建出两个 $n$ 个点的图 $G,H$，初始边集为空集</p>
<p>对于 $i\in[1,n-2]$，依次找到一个 $j$ 使得 $j$ 还没被选且 $i,j$ 在 $G$ 中不连通且 $i,p_j$ 在 $H$ 中不连通，这样的 $j$ 一定能找到，因为还没被选的点中在 $G$ 中和 $i$ 连通的点最多只有一个，$H$ 中同理，而还没被选的点至少还有 $3$ 个</p>
<p>对于 $i&#x3D;n-1$，找到一个 $j$ 使得 $j$ 还没被选且 $i,j$ 在 $G$ 中不连通（此处至多产生一个环）</p>
<p>对于 $i&#x3D;n$，$x_i$ 被唯一确定（此处至多产生两个环）</p>
<p>此时环数 $\le 3$</p>
<p>记构造出来满足最小值的排列为 $g$，满足最大值的排列 $\epsilon$，构造任意一个长度为 $\mathcal O(n)$ 的序列 $g&#x3D;a_0\to a_1\to\dots\to a_t&#x3D;\epsilon$，使得相邻两个 $a$ 可以通过一次对任意两个元素的交换得到</p>
<p>于是我们可以二分求出满足 $x&#x3D;a_i$ 时有 $f(x)+f(y)&#x3D;k$ 的一个 $i$</p>
<p>时间复杂度 $\mathcal O(n\log n)$</p>
<ul>
<li>F</li>
</ul>
<p>显然使用 matrix-tree 定理</p>
<p>记总点数为 $m$，度数矩阵为 $D$，邻接矩阵为 $E$（$D$ 和 $E$ 均已去掉一行一列），那么我们要求的即为 $|D-E|$</p>
<p>引理（矩阵行列式引理）：若 $A$ 为可逆矩阵，则 $|A+uv^T|&#x3D;|A||I-v^TA^{-1}u|$</p>
<p>此处我们希望构造 $E&#x3D;uv^T$，其中 $u,v$ 的列数为 $\mathcal O(n)$</p>
<p>考虑到两个区间有交等价于同时在两个区间中包含的点数减去边数为 $1$，没有交则为 $0$</p>
<p>所以考虑构造两个 $m\times(2n-1)$ 的矩阵：</p>
<ol>
<li><p>$u_{j,2i-1}&#x3D;v_{j,2i-1}&#x3D;[i\in[l_j,r_j]]$</p>
</li>
<li><p>$u_{j,2i}&#x3D;-[i\in[l_j,r_j)]$</p>
</li>
<li><p>$v_{j,2i}&#x3D;[i\in[l_j,r_j)]$</p>
</li>
</ol>
<p>那么 $|D-E|&#x3D;|D-uv^T|&#x3D;|D||I-v^TD^{-1}u|$</p>
<p>这样高斯消元只需要处理一个 $(2n-1)\times(2n-1)$ 的矩阵即可</p>
<p>时间复杂度 $\mathcal O(n^3)$</p>
<h3 id="AGC061"><a href="#AGC061" class="headerlink" title="AGC061"></a>AGC061</h3><ul>
<li>A</li>
</ul>
<p>记 $f_{l,r}(A)$ 为对 $A$ 序列 $[l,r]$ 区间进行 $\operatorname{shuffle}$ 操作之后的序列</p>
<p>结论：若区间 $[l,r]$ 长为偶数，则 $f_{l,r}(A)$ 只会交换若干对 $A_{l+2k},A_{l+2k+1}$</p>
<p>证明：考虑归纳，显然 $l+1&#x3D;r$ 时成立；考虑 $r-l+1&#x3D;2k$ 时，把 $f_{l,r}$ 拆成 $f_{l+2,r}\circ f_{l+1,r-1}\circ f_{l+1,r-1}\circ f_{l,r-2}$ 四步操作，由归纳假设，$f_{l+1,r-1}$ 只会交换相邻的两个 $A$，且交换操作相互独立，于是连续两次 $f_{l+1,r-1}$ 操作可以抵消掉，剩下的 $f_{l+2,r}\circ f_{l,r-2}$ 由归纳假设显然成立</p>
<p>记 $g_{i,j}$ 表示 $f_{1,2i}$ 操作中 $A_{2j-1},A_{2j}$ 有没有被交换，则 $g_{i,j}&#x3D;g_{i-1,j}\operatorname{xor}g_{i-1,j-1}$，即 $g_{i,j}&#x3D;\binom{i-1}{j-1}\bmod 2$</p>
<p>于是所有 $n$ 为偶数的情况就被处理出来了，$n$ 为奇数时只要把 $f_{1,n}$ 拆成 $f_{2,n}\circ f_{1,n-1}$ 即可</p>
<p>时间复杂度 $\mathcal O(T\log n)$</p>
<ul>
<li>B</li>
</ul>
<p>对于 $n$ 为奇数的情况，我们很容易把原图划分成 $\lceil\frac n2\rceil$ 条长度为 $2n$ 的路径，把颜色分成 $\lceil\frac n2\rceil$ 组，每组长度和为 $2n$ 即可</p>
<p>对于 $n$ 为偶数的情况，首先不妨把颜色 $n$ 放在所有 $(i,i),(i,i+1)$ 的位置，此时矩阵被分成了上下两部分</p>
<p>对于上半部分，放置所有的偶数，第一行每隔一个位置从大到小放一个偶数，此时矩阵的上半部分除了第一行的 $2k+1(k&gt;1)$ 列之外全部被填满了</p>
<p>对于下半部分，放置除 $1$ 以外所有的奇数，并把每种颜色多出来的一个数塞到上半部分对应的空位中</p>
<p>最后剩下 $1$ 没填，剩下的位置时左下角和右上角，于是把 $n-1$ 的第一个位置换到右上角，这样剩下的两个空位就都在第一列了，填上 $1$ 即可</p>
<p>以 $n&#x3D;6$ 为例，构造过程如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">66xxxxx    66x4x2x    663452x    6634525</span><br><span class="line">x66xxxx    x664422    5664422    1664422</span><br><span class="line">xx66xxx -&gt; xx66442 -&gt; 5566442 -&gt; 5566442</span><br><span class="line">xxx66xx    xxx6644    3556644    3556644</span><br><span class="line">xxxx66x    xxxx664    3355664    3355664</span><br><span class="line">xxxxx66    xxxxx66    x335566    1335566</span><br></pre></td></tr></table></figure>

<p>时间复杂度 $\mathcal O(Tn^2)$</p>
<ul>
<li>C</li>
</ul>
<p>按照套路，考虑给每个登记序列一一对应一种登记方式</p>
<p>不妨让每个人都尽量在区间左端点处登记，也即只有在区间内有人登记时才可以选右端点</p>
<p>考虑一个暴力 dp：记 $f_{i,j}$ 表示当前处理到第 $i$ 个人，最后一个登记的人是在时刻 $j$，且对后续登记没有限制的方案数；$g_{i,j}$ 表示当前处理到第 $i$ 个人，要求后续登记中至少有一个人在 $j$ 时刻前登记的方案数</p>
<p>先考虑 $f$ 的转移，记当前区间为 $[l_i,r_i]$，则显然对于所有 $j&lt;l_i$ 有 $f_{i,j}&#x3D;0$；考虑当前选择区间左端点还是右端点，若选择左端点，则对于 $j&lt; l_i$ 有 $f_{i,l_i}\leftarrow f_{i-1,j}$，对于 $j&gt;l_i$ 有 $f_{i,j}\leftarrow f_{i-1,j}$；若选择右端点，由于要对后面的选择没有要求，于是只对 $j&lt; l_i$ 有 $f_{i,r_i}\leftarrow f_{i-1,j}$</p>
<p>再考虑 $g$ 的转移，首先同样对于所有 $j&lt; l_i$ 有 $g_{i,j}&#x3D;0$；由于此时我们选择的显然是右端点，则对于 $j&gt;l_i$ 有 $g_{i,j}\leftarrow g_{i-1,j}$，并且可以从 $f$ 转移过来，即对于 $j&lt; l_i$，有 $g_{i,r_i}\leftarrow f_{i-1,j}$</p>
<p>最后还有 $g$ 向 $f$ 的转移，此时显然选择的是左端点，上一个选择的一定是右端点，于是对于 $j&gt;l_i$ 有 $f_{i,r_{i-1}}\leftarrow g_{i-1,j}$</p>
<p>上述过程涉及到单点加，区间设 $0$，区间求和，可以用线段树维护</p>
<p>时间复杂度 $\mathcal O(n\log n)$</p>
<ul>
<li>D</li>
</ul>
<p>首先二分答案 $mid$，则题目转化为判断 $|x_iy_j-a_{i,j}|\le mid\Leftrightarrow a_{i,j}-mid\le x_iy_j\le a_{i,j}+mid$ 是否有解</p>
<p>不妨假设 $x_n\le y_m$，否则可以对称处理</p>
<p>初始令 $x_i&#x3D;i$，$y_i&#x3D;\infty-m+i$，接下来不断做以下步骤：</p>
<ul>
<li>对于 $i&#x3D;1\to n$，令 $x_i\leftarrow \max{x_i,x_{i-1}+1,\lceil\frac{a_{i,j}-mid}{y_j}\rceil}$</li>
<li>对于 $j&#x3D;m\to 1$，令 $y_j\leftarrow \min{y_j,y_{j+1}-1,\lfloor \frac{a_{i,j}+mid}{x_i}\rfloor}$</li>
</ul>
<p>若过程中出现 $x_n&gt;y_m$ 或者 $y_1\le 0$ 则无解；若 $x_i$ 在一轮修改中均不变则找到了一组解</p>
<p>考虑算法的正确性，若存在一组解 $x’,y’$，则不难通过归纳证明每一轮修改后都有 ${x_i}’\ge x_i,{y_i}’\le y_i$，即若算法报告无解则一定无解；而一轮修改中 $x_i$ 均不变说明此时 $x,y$ 都已经合法，即若算法构造出来了一组解那么这组解是一组合法解，于是算法正确性得证</p>
<p>考虑算法的复杂度，假设 $n,m$ 同阶，则一轮修改的复杂度为 $\mathcal O(n^2)$，我们只需要考虑修改的轮数即可</p>
<p>考虑到每轮结束后若算法仍没结束，则有 $x_n\le y_m$ 且 $x_ny_m\le a_{n,m}+mid$，可得 $x_i\le x_n\le \sqrt{a_{n,m}+mid}$，记值域为 $w$，则 $\sum x_i$ 最大为 $\mathcal O(n\sqrt w)$ 级别，而每轮修改至少会让 $\sum x_i$ 增加 $1$，则修改轮数为 $\mathcal O(n\sqrt w)$</p>
<p>算上二分答案，总复杂度为 $\mathcal O(n^3\sqrt w\log w)$</p>
<ul>
<li>E</li>
</ul>
<p>关注进位的过程，每次加 $1$ 若产生进位，那么产生的数一定是以形如 $100\dots 0$ 的串为后缀的数</p>
<p>那么考虑第 $0$ 到第 $k-1$ 位，考虑对第 $k$ 位进位的影响，过程中可能的起点为 $s$ 或者 $00\dots 0$，可能的终点为 $t$ 或者 $00\dots0$</p>
<p>考虑对这个过程进行 dp，记 $f_{k,0&#x2F;1,0&#x2F;1,s}$ 表示仅考虑第 $0$ 位到第 $k-1$ 位，起点为 $s$ 或者后 $k$ 位全 $0$，终点为 $t$ 或者后 $k$ 位全 $0$ 且在最后一次操作后向第 $k$ 位进位，$s$ 集合中的数被异或了奇数次的最小代价</p>
<p>考虑 $k$ 向 $k+1$ 转移的过程，分为两类：</p>
<ul>
<li>若第 $k-1$ 位不向第 $k$ 位进位，那若目前的 $s$ 能与起点和终点在第 $k$ 位匹配，则有转移 $f_{k+1,i,j,s}\leftarrow f_{k,i,j,s}$</li>
<li>若第 $k-1$ 位向第 $k$ 位进位，则我们需要找一条 $(i,1,s_0),(1,1,s_1),\dots,(1,j,s_t)$ 的路径来完成 $f_{k+1,i,j,s_0\operatorname{xor}s_1\operatorname{xor}\dots\operatorname{xor}s_t}$ 的转移，可以使用 dijkstra 算法在 $\mathcal O(4^n)$ 的时间内完成转移</li>
</ul>
<p>初始令 $f_{0,i,0,s}&#x3D;\sum_{i\in s}C_i,f_{0,i,1,s}&#x3D;A+\sum_{i\in s} C_i$</p>
<p>记 $B&#x3D;40$，则时间复杂度 $\mathcal O(4^nB)$</p>
<ul>
<li>F</li>
</ul>
<p>考虑把 01 串看作一个操作序列，初始时有一个点位于 $(0,0)$，遇到 $0$ 则向上移动一格，遇到 $1$ 则向右移动一格，所有横坐标的操作均在模 $n$ 意义下进行，所有纵坐标的操作均在模 $m$ 意义下进行</p>
<p>于是我们可以把题意转化为对 $n\times m$ 的循环网格中经过 $(0,0)$ 的简单环进行计数</p>
<p>由于是循环网格上的环，所以我们可以把它们拆成若干不相交路径</p>
<p>考虑钦定一些网格边界上的点，令它们为路径上的起点，那么我们又可以把题意转化为在 $n\times m$ 的网格左下边界上给定一些起点，右上边界上给定一些终点，求不相交路径数</p>
<p>这显然可以用 LGV 引理在 $\mathcal O(n^3)$ 的时间内完成</p>
<p>但枚举起点和终点需要 $\mathcal O(2^{n+m})$ 的时间，需要优化</p>
<p>考虑对于一行的最左边点和最右边点之间和一列的最上边点和最下边点之间加上一条额外边，每条从下边界开始的路径增加一个 $x$ 的系数，每条从左边界开始的路径增加一个 $y$ 的系数，再进行 LGV，得到一个多项式 $F(x,y)$，那么 $[x^iy^j]F$ 即为在下边界上选 $i$ 个起点，在左边界上选 $j$ 个起点的方案数了</p>
<p>由于必须要经过 $(0,0)$，那么可以考虑删掉一条 $(0,0)\to (0,m-1)$ 或 $(0,0)\to(n-1,0)$ 的额外边，即钦定 $(0,0)$ 必须为一个起点</p>
<p>由于要形成恰好一个简单环，则我们需要额外要求 $\gcd(i,j)&#x3D;1$，否则会形成不止一个简单环</p>
<p>直接对多项式求行列式不好求，所以带入 $\mathcal O(nm)$ 个点值算出答案之后插值即可</p>
<p>时间复杂度 $\mathcal O(n^5)$</p>

      

      
    </div>
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<i class="icon-price-tags icon"></i>
		<ul class="article-tag-list">
			 
        		<li class="article-tag-list-item">
        			<a href="javascript:void(0)" class="js-tag article-tag-list-link color5">做题笔记</a>
        		</li>
      		
		</ul>
	</div>

      

      

      
        
<div class="share-btn share-icons tooltip-left">
  <div class="tooltip tooltip-east">
    <span class="tooltip-item">
      <a href="javascript:;" class="share-sns share-outer">
        <i class="icon icon-share"></i>
      </a>
    </span>
    <span class="tooltip-content">
      <div class="share-wrap">
        <div class="share-icons">
          <a class="weibo share-sns" href="javascript:;" data-type="weibo">
            <i class="icon icon-weibo"></i>
          </a>
          <a class="weixin share-sns wxFab" href="javascript:;" data-type="weixin">
            <i class="icon icon-weixin"></i>
          </a>
          <a class="qq share-sns" href="javascript:;" data-type="qq">
            <i class="icon icon-qq"></i>
          </a>
          <a class="douban share-sns" href="javascript:;" data-type="douban">
            <i class="icon icon-douban"></i>
          </a>
          <a class="qzone share-sns" href="javascript:;" data-type="qzone">
            <i class="icon icon-qzone"></i>
          </a>
          <a class="facebook share-sns" href="javascript:;" data-type="facebook">
            <i class="icon icon-facebook"></i>
          </a>
          <a class="twitter share-sns" href="javascript:;" data-type="twitter">
            <i class="icon icon-twitter"></i>
          </a>
          <a class="google share-sns" href="javascript:;" data-type="google">
            <i class="icon icon-google"></i>
          </a>
        </div>
      </div>
    </span>
  </div>
</div>

<div class="page-modal wx-share js-wx-box">
    <a class="close js-modal-close" href="javascript:;"><i class="icon icon-close"></i></a>
    <p>扫一扫，分享到微信</p>
    <div class="wx-qrcode">
      <img src="//pan.baidu.com/share/qrcode?url=http://example.com/2024/10/11/%E3%80%90%E5%81%9A%E9%A2%98%E7%AC%94%E8%AE%B0%E3%80%91%20Atcoder%20Grand%20Contest/" alt="微信分享二维码">
    </div>
</div>

<div class="mask js-mask"></div>
      
      <div class="clearfix"></div>
    </div>
  </div>
</article>

  
<nav id="article-nav">
  
  
    <a href="/2023/07/27/%E3%80%90%E6%B8%B8%E8%AE%B0%E3%80%91%20NOI2023/" id="article-nav-older" class="article-nav-link-wrap">
      <div class="article-nav-title">【游记】 NOI2023 退役记</div>
      <i class="icon-circle-right"></i>
    </a>
  
</nav>


<aside class="wrap-side-operation">
    <div class="mod-side-operation">
        
        <div class="jump-container" id="js-jump-container" style="display:none;">
            <a href="javascript:void(0)" class="mod-side-operation__jump-to-top">
                <i class="icon-font icon-back"></i>
            </a>
            <div id="js-jump-plan-container" class="jump-plan-container" style="top: -11px;">
                <i class="icon-font icon-plane jump-plane"></i>
            </div>
        </div>
        
        
    </div>
</aside>



  
  
  

  

  

  
  <div id="gitment-ctn"></div> 
<link rel="stylesheet" href="//imsun.github.io/gitment/style/default.css">
<script src="//imsun.github.io/gitment/dist/gitment.browser.js"></script>
<script>
var gitment = new Gitment({
  id: "http://example.com/2024/10/11/%E3%80%90%E5%81%9A%E9%A2%98%E7%AC%94%E8%AE%B0%E3%80%91%20Atcoder%20Grand%20Contest/",
  owner: 'UltiMadow',
  repo: 'comments',
  oauth: {
    client_id: 'Ov23liIBTODLjCC0SoiD',
    client_secret: '8c225ecb1b4e86fce70c6592b62ce6a32b8ce225',
  },
})
gitment.render('gitment-ctn')
</script>
  


          </div>
        </div>
      </div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
    	<div class="footer-left">
    		&copy; 2024 UMqwq
    	</div>
      	<div class="footer-right">
      		<a href="http://hexo.io/" target="_blank">Hexo</a>  Theme <a href="https://github.com/litten/hexo-theme-yilia" target="_blank">Yilia</a> by Litten
      	</div>
    </div>
  </div>
</footer>
    </div>
    <script>
	var yiliaConfig = {
		mathjax: true,
		isHome: false,
		isPost: true,
		isArchive: false,
		isTag: false,
		isCategory: false,
		open_in_new: false,
		toc_hide_index: true,
		root: "/",
		innerArchive: true,
		showTags: false
	}
</script>

<script>!function(t){function n(e){if(r[e])return r[e].exports;var i=r[e]={exports:{},id:e,loaded:!1};return t[e].call(i.exports,i,i.exports,n),i.loaded=!0,i.exports}var r={};n.m=t,n.c=r,n.p="./",n(0)}([function(t,n,r){r(195),t.exports=r(191)},function(t,n,r){var e=r(3),i=r(52),o=r(27),u=r(28),c=r(53),f="prototype",a=function(t,n,r){var s,l,h,v,p=t&a.F,d=t&a.G,y=t&a.S,g=t&a.P,b=t&a.B,m=d?e:y?e[n]||(e[n]={}):(e[n]||{})[f],x=d?i:i[n]||(i[n]={}),w=x[f]||(x[f]={});d&&(r=n);for(s in r)l=!p&&m&&void 0!==m[s],h=(l?m:r)[s],v=b&&l?c(h,e):g&&"function"==typeof h?c(Function.call,h):h,m&&u(m,s,h,t&a.U),x[s]!=h&&o(x,s,v),g&&w[s]!=h&&(w[s]=h)};e.core=i,a.F=1,a.G=2,a.S=4,a.P=8,a.B=16,a.W=32,a.U=64,a.R=128,t.exports=a},function(t,n,r){var e=r(6);t.exports=function(t){if(!e(t))throw TypeError(t+" is not an object!");return t}},function(t,n){var r=t.exports="undefined"!=typeof window&&window.Math==Math?window:"undefined"!=typeof self&&self.Math==Math?self:Function("return this")();"number"==typeof __g&&(__g=r)},function(t,n){t.exports=function(t){try{return!!t()}catch(t){return!0}}},function(t,n){var r=t.exports="undefined"!=typeof window&&window.Math==Math?window:"undefined"!=typeof self&&self.Math==Math?self:Function("return this")();"number"==typeof __g&&(__g=r)},function(t,n){t.exports=function(t){return"object"==typeof t?null!==t:"function"==typeof t}},function(t,n,r){var e=r(126)("wks"),i=r(76),o=r(3).Symbol,u="function"==typeof o;(t.exports=function(t){return e[t]||(e[t]=u&&o[t]||(u?o:i)("Symbol."+t))}).store=e},function(t,n){var r={}.hasOwnProperty;t.exports=function(t,n){return r.call(t,n)}},function(t,n,r){var e=r(94),i=r(33);t.exports=function(t){return e(i(t))}},function(t,n,r){t.exports=!r(4)(function(){return 7!=Object.defineProperty({},"a",{get:function(){return 7}}).a})},function(t,n,r){var e=r(2),i=r(167),o=r(50),u=Object.defineProperty;n.f=r(10)?Object.defineProperty:function(t,n,r){if(e(t),n=o(n,!0),e(r),i)try{return u(t,n,r)}catch(t){}if("get"in r||"set"in r)throw TypeError("Accessors not supported!");return"value"in r&&(t[n]=r.value),t}},function(t,n,r){t.exports=!r(18)(function(){return 7!=Object.defineProperty({},"a",{get:function(){return 7}}).a})},function(t,n,r){var e=r(14),i=r(22);t.exports=r(12)?function(t,n,r){return e.f(t,n,i(1,r))}:function(t,n,r){return t[n]=r,t}},function(t,n,r){var e=r(20),i=r(58),o=r(42),u=Object.defineProperty;n.f=r(12)?Object.defineProperty:function(t,n,r){if(e(t),n=o(n,!0),e(r),i)try{return u(t,n,r)}catch(t){}if("get"in r||"set"in r)throw TypeError("Accessors not supported!");return"value"in r&&(t[n]=r.value),t}},function(t,n,r){var e=r(40)("wks"),i=r(23),o=r(5).Symbol,u="function"==typeof o;(t.exports=function(t){return e[t]||(e[t]=u&&o[t]||(u?o:i)("Symbol."+t))}).store=e},function(t,n,r){var e=r(67),i=Math.min;t.exports=function(t){return t>0?i(e(t),9007199254740991):0}},function(t,n,r){var e=r(46);t.exports=function(t){return Object(e(t))}},function(t,n){t.exports=function(t){try{return!!t()}catch(t){return!0}}},function(t,n,r){var e=r(63),i=r(34);t.exports=Object.keys||function(t){return e(t,i)}},function(t,n,r){var e=r(21);t.exports=function(t){if(!e(t))throw TypeError(t+" is not an object!");return t}},function(t,n){t.exports=function(t){return"object"==typeof t?null!==t:"function"==typeof t}},function(t,n){t.exports=function(t,n){return{enumerable:!(1&t),configurable:!(2&t),writable:!(4&t),value:n}}},function(t,n){var r=0,e=Math.random();t.exports=function(t){return"Symbol(".concat(void 0===t?"":t,")_",(++r+e).toString(36))}},function(t,n){var r={}.hasOwnProperty;t.exports=function(t,n){return r.call(t,n)}},function(t,n){var r=t.exports={version:"2.4.0"};"number"==typeof __e&&(__e=r)},function(t,n){t.exports=function(t){if("function"!=typeof t)throw TypeError(t+" is not a function!");return t}},function(t,n,r){var e=r(11),i=r(66);t.exports=r(10)?function(t,n,r){return e.f(t,n,i(1,r))}:function(t,n,r){return t[n]=r,t}},function(t,n,r){var e=r(3),i=r(27),o=r(24),u=r(76)("src"),c="toString",f=Function[c],a=(""+f).split(c);r(52).inspectSource=function(t){return f.call(t)},(t.exports=function(t,n,r,c){var f="function"==typeof r;f&&(o(r,"name")||i(r,"name",n)),t[n]!==r&&(f&&(o(r,u)||i(r,u,t[n]?""+t[n]:a.join(String(n)))),t===e?t[n]=r:c?t[n]?t[n]=r:i(t,n,r):(delete t[n],i(t,n,r)))})(Function.prototype,c,function(){return"function"==typeof this&&this[u]||f.call(this)})},function(t,n,r){var e=r(1),i=r(4),o=r(46),u=function(t,n,r,e){var i=String(o(t)),u="<"+n;return""!==r&&(u+=" "+r+'="'+String(e).replace(/"/g,"&quot;")+'"'),u+">"+i+"</"+n+">"};t.exports=function(t,n){var r={};r[t]=n(u),e(e.P+e.F*i(function(){var n=""[t]('"');return n!==n.toLowerCase()||n.split('"').length>3}),"String",r)}},function(t,n,r){var e=r(115),i=r(46);t.exports=function(t){return e(i(t))}},function(t,n,r){var e=r(116),i=r(66),o=r(30),u=r(50),c=r(24),f=r(167),a=Object.getOwnPropertyDescriptor;n.f=r(10)?a:function(t,n){if(t=o(t),n=u(n,!0),f)try{return a(t,n)}catch(t){}if(c(t,n))return i(!e.f.call(t,n),t[n])}},function(t,n,r){var e=r(24),i=r(17),o=r(145)("IE_PROTO"),u=Object.prototype;t.exports=Object.getPrototypeOf||function(t){return t=i(t),e(t,o)?t[o]:"function"==typeof t.constructor&&t instanceof t.constructor?t.constructor.prototype:t instanceof Object?u:null}},function(t,n){t.exports=function(t){if(void 0==t)throw TypeError("Can't call method on  "+t);return t}},function(t,n){t.exports="constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf".split(",")},function(t,n){t.exports={}},function(t,n){t.exports=!0},function(t,n){n.f={}.propertyIsEnumerable},function(t,n,r){var e=r(14).f,i=r(8),o=r(15)("toStringTag");t.exports=function(t,n,r){t&&!i(t=r?t:t.prototype,o)&&e(t,o,{configurable:!0,value:n})}},function(t,n,r){var e=r(40)("keys"),i=r(23);t.exports=function(t){return e[t]||(e[t]=i(t))}},function(t,n,r){var e=r(5),i="__core-js_shared__",o=e[i]||(e[i]={});t.exports=function(t){return o[t]||(o[t]={})}},function(t,n){var r=Math.ceil,e=Math.floor;t.exports=function(t){return isNaN(t=+t)?0:(t>0?e:r)(t)}},function(t,n,r){var e=r(21);t.exports=function(t,n){if(!e(t))return t;var r,i;if(n&&"function"==typeof(r=t.toString)&&!e(i=r.call(t)))return i;if("function"==typeof(r=t.valueOf)&&!e(i=r.call(t)))return i;if(!n&&"function"==typeof(r=t.toString)&&!e(i=r.call(t)))return i;throw TypeError("Can't convert object to primitive value")}},function(t,n,r){var e=r(5),i=r(25),o=r(36),u=r(44),c=r(14).f;t.exports=function(t){var n=i.Symbol||(i.Symbol=o?{}:e.Symbol||{});"_"==t.charAt(0)||t in n||c(n,t,{value:u.f(t)})}},function(t,n,r){n.f=r(15)},function(t,n){var r={}.toString;t.exports=function(t){return r.call(t).slice(8,-1)}},function(t,n){t.exports=function(t){if(void 0==t)throw TypeError("Can't call method on  "+t);return t}},function(t,n,r){var e=r(4);t.exports=function(t,n){return!!t&&e(function(){n?t.call(null,function(){},1):t.call(null)})}},function(t,n,r){var e=r(53),i=r(115),o=r(17),u=r(16),c=r(203);t.exports=function(t,n){var r=1==t,f=2==t,a=3==t,s=4==t,l=6==t,h=5==t||l,v=n||c;return function(n,c,p){for(var d,y,g=o(n),b=i(g),m=e(c,p,3),x=u(b.length),w=0,S=r?v(n,x):f?v(n,0):void 0;x>w;w++)if((h||w in b)&&(d=b[w],y=m(d,w,g),t))if(r)S[w]=y;else if(y)switch(t){case 3:return!0;case 5:return d;case 6:return w;case 2:S.push(d)}else if(s)return!1;return l?-1:a||s?s:S}}},function(t,n,r){var e=r(1),i=r(52),o=r(4);t.exports=function(t,n){var r=(i.Object||{})[t]||Object[t],u={};u[t]=n(r),e(e.S+e.F*o(function(){r(1)}),"Object",u)}},function(t,n,r){var e=r(6);t.exports=function(t,n){if(!e(t))return t;var r,i;if(n&&"function"==typeof(r=t.toString)&&!e(i=r.call(t)))return i;if("function"==typeof(r=t.valueOf)&&!e(i=r.call(t)))return i;if(!n&&"function"==typeof(r=t.toString)&&!e(i=r.call(t)))return i;throw TypeError("Can't convert object to primitive value")}},function(t,n,r){var e=r(5),i=r(25),o=r(91),u=r(13),c="prototype",f=function(t,n,r){var a,s,l,h=t&f.F,v=t&f.G,p=t&f.S,d=t&f.P,y=t&f.B,g=t&f.W,b=v?i:i[n]||(i[n]={}),m=b[c],x=v?e:p?e[n]:(e[n]||{})[c];v&&(r=n);for(a in r)(s=!h&&x&&void 0!==x[a])&&a in b||(l=s?x[a]:r[a],b[a]=v&&"function"!=typeof x[a]?r[a]:y&&s?o(l,e):g&&x[a]==l?function(t){var n=function(n,r,e){if(this instanceof t){switch(arguments.length){case 0:return new t;case 1:return new t(n);case 2:return new t(n,r)}return new t(n,r,e)}return t.apply(this,arguments)};return n[c]=t[c],n}(l):d&&"function"==typeof l?o(Function.call,l):l,d&&((b.virtual||(b.virtual={}))[a]=l,t&f.R&&m&&!m[a]&&u(m,a,l)))};f.F=1,f.G=2,f.S=4,f.P=8,f.B=16,f.W=32,f.U=64,f.R=128,t.exports=f},function(t,n){var r=t.exports={version:"2.4.0"};"number"==typeof __e&&(__e=r)},function(t,n,r){var e=r(26);t.exports=function(t,n,r){if(e(t),void 0===n)return t;switch(r){case 1:return function(r){return t.call(n,r)};case 2:return function(r,e){return t.call(n,r,e)};case 3:return function(r,e,i){return t.call(n,r,e,i)}}return function(){return t.apply(n,arguments)}}},function(t,n,r){var e=r(183),i=r(1),o=r(126)("metadata"),u=o.store||(o.store=new(r(186))),c=function(t,n,r){var i=u.get(t);if(!i){if(!r)return;u.set(t,i=new e)}var o=i.get(n);if(!o){if(!r)return;i.set(n,o=new e)}return o},f=function(t,n,r){var e=c(n,r,!1);return void 0!==e&&e.has(t)},a=function(t,n,r){var e=c(n,r,!1);return void 0===e?void 0:e.get(t)},s=function(t,n,r,e){c(r,e,!0).set(t,n)},l=function(t,n){var r=c(t,n,!1),e=[];return r&&r.forEach(function(t,n){e.push(n)}),e},h=function(t){return void 0===t||"symbol"==typeof t?t:String(t)},v=function(t){i(i.S,"Reflect",t)};t.exports={store:u,map:c,has:f,get:a,set:s,keys:l,key:h,exp:v}},function(t,n,r){"use strict";if(r(10)){var e=r(69),i=r(3),o=r(4),u=r(1),c=r(127),f=r(152),a=r(53),s=r(68),l=r(66),h=r(27),v=r(73),p=r(67),d=r(16),y=r(75),g=r(50),b=r(24),m=r(180),x=r(114),w=r(6),S=r(17),_=r(137),O=r(70),E=r(32),P=r(71).f,j=r(154),F=r(76),M=r(7),A=r(48),N=r(117),T=r(146),I=r(155),k=r(80),L=r(123),R=r(74),C=r(130),D=r(160),U=r(11),W=r(31),G=U.f,B=W.f,V=i.RangeError,z=i.TypeError,q=i.Uint8Array,K="ArrayBuffer",J="Shared"+K,Y="BYTES_PER_ELEMENT",H="prototype",$=Array[H],X=f.ArrayBuffer,Q=f.DataView,Z=A(0),tt=A(2),nt=A(3),rt=A(4),et=A(5),it=A(6),ot=N(!0),ut=N(!1),ct=I.values,ft=I.keys,at=I.entries,st=$.lastIndexOf,lt=$.reduce,ht=$.reduceRight,vt=$.join,pt=$.sort,dt=$.slice,yt=$.toString,gt=$.toLocaleString,bt=M("iterator"),mt=M("toStringTag"),xt=F("typed_constructor"),wt=F("def_constructor"),St=c.CONSTR,_t=c.TYPED,Ot=c.VIEW,Et="Wrong length!",Pt=A(1,function(t,n){return Tt(T(t,t[wt]),n)}),jt=o(function(){return 1===new q(new Uint16Array([1]).buffer)[0]}),Ft=!!q&&!!q[H].set&&o(function(){new q(1).set({})}),Mt=function(t,n){if(void 0===t)throw z(Et);var r=+t,e=d(t);if(n&&!m(r,e))throw V(Et);return e},At=function(t,n){var r=p(t);if(r<0||r%n)throw V("Wrong offset!");return r},Nt=function(t){if(w(t)&&_t in t)return t;throw z(t+" is not a typed array!")},Tt=function(t,n){if(!(w(t)&&xt in t))throw z("It is not a typed array constructor!");return new t(n)},It=function(t,n){return kt(T(t,t[wt]),n)},kt=function(t,n){for(var r=0,e=n.length,i=Tt(t,e);e>r;)i[r]=n[r++];return i},Lt=function(t,n,r){G(t,n,{get:function(){return this._d[r]}})},Rt=function(t){var n,r,e,i,o,u,c=S(t),f=arguments.length,s=f>1?arguments[1]:void 0,l=void 0!==s,h=j(c);if(void 0!=h&&!_(h)){for(u=h.call(c),e=[],n=0;!(o=u.next()).done;n++)e.push(o.value);c=e}for(l&&f>2&&(s=a(s,arguments[2],2)),n=0,r=d(c.length),i=Tt(this,r);r>n;n++)i[n]=l?s(c[n],n):c[n];return i},Ct=function(){for(var t=0,n=arguments.length,r=Tt(this,n);n>t;)r[t]=arguments[t++];return r},Dt=!!q&&o(function(){gt.call(new q(1))}),Ut=function(){return gt.apply(Dt?dt.call(Nt(this)):Nt(this),arguments)},Wt={copyWithin:function(t,n){return D.call(Nt(this),t,n,arguments.length>2?arguments[2]:void 0)},every:function(t){return rt(Nt(this),t,arguments.length>1?arguments[1]:void 0)},fill:function(t){return C.apply(Nt(this),arguments)},filter:function(t){return It(this,tt(Nt(this),t,arguments.length>1?arguments[1]:void 0))},find:function(t){return et(Nt(this),t,arguments.length>1?arguments[1]:void 0)},findIndex:function(t){return it(Nt(this),t,arguments.length>1?arguments[1]:void 0)},forEach:function(t){Z(Nt(this),t,arguments.length>1?arguments[1]:void 0)},indexOf:function(t){return ut(Nt(this),t,arguments.length>1?arguments[1]:void 0)},includes:function(t){return ot(Nt(this),t,arguments.length>1?arguments[1]:void 0)},join:function(t){return vt.apply(Nt(this),arguments)},lastIndexOf:function(t){return st.apply(Nt(this),arguments)},map:function(t){return Pt(Nt(this),t,arguments.length>1?arguments[1]:void 0)},reduce:function(t){return lt.apply(Nt(this),arguments)},reduceRight:function(t){return ht.apply(Nt(this),arguments)},reverse:function(){for(var t,n=this,r=Nt(n).length,e=Math.floor(r/2),i=0;i<e;)t=n[i],n[i++]=n[--r],n[r]=t;return n},some:function(t){return nt(Nt(this),t,arguments.length>1?arguments[1]:void 0)},sort:function(t){return pt.call(Nt(this),t)},subarray:function(t,n){var r=Nt(this),e=r.length,i=y(t,e);return new(T(r,r[wt]))(r.buffer,r.byteOffset+i*r.BYTES_PER_ELEMENT,d((void 0===n?e:y(n,e))-i))}},Gt=function(t,n){return It(this,dt.call(Nt(this),t,n))},Bt=function(t){Nt(this);var n=At(arguments[1],1),r=this.length,e=S(t),i=d(e.length),o=0;if(i+n>r)throw V(Et);for(;o<i;)this[n+o]=e[o++]},Vt={entries:function(){return at.call(Nt(this))},keys:function(){return ft.call(Nt(this))},values:function(){return ct.call(Nt(this))}},zt=function(t,n){return w(t)&&t[_t]&&"symbol"!=typeof n&&n in t&&String(+n)==String(n)},qt=function(t,n){return zt(t,n=g(n,!0))?l(2,t[n]):B(t,n)},Kt=function(t,n,r){return!(zt(t,n=g(n,!0))&&w(r)&&b(r,"value"))||b(r,"get")||b(r,"set")||r.configurable||b(r,"writable")&&!r.writable||b(r,"enumerable")&&!r.enumerable?G(t,n,r):(t[n]=r.value,t)};St||(W.f=qt,U.f=Kt),u(u.S+u.F*!St,"Object",{getOwnPropertyDescriptor:qt,defineProperty:Kt}),o(function(){yt.call({})})&&(yt=gt=function(){return vt.call(this)});var Jt=v({},Wt);v(Jt,Vt),h(Jt,bt,Vt.values),v(Jt,{slice:Gt,set:Bt,constructor:function(){},toString:yt,toLocaleString:Ut}),Lt(Jt,"buffer","b"),Lt(Jt,"byteOffset","o"),Lt(Jt,"byteLength","l"),Lt(Jt,"length","e"),G(Jt,mt,{get:function(){return this[_t]}}),t.exports=function(t,n,r,f){f=!!f;var a=t+(f?"Clamped":"")+"Array",l="Uint8Array"!=a,v="get"+t,p="set"+t,y=i[a],g=y||{},b=y&&E(y),m=!y||!c.ABV,S={},_=y&&y[H],j=function(t,r){var e=t._d;return e.v[v](r*n+e.o,jt)},F=function(t,r,e){var i=t._d;f&&(e=(e=Math.round(e))<0?0:e>255?255:255&e),i.v[p](r*n+i.o,e,jt)},M=function(t,n){G(t,n,{get:function(){return j(this,n)},set:function(t){return F(this,n,t)},enumerable:!0})};m?(y=r(function(t,r,e,i){s(t,y,a,"_d");var o,u,c,f,l=0,v=0;if(w(r)){if(!(r instanceof X||(f=x(r))==K||f==J))return _t in r?kt(y,r):Rt.call(y,r);o=r,v=At(e,n);var p=r.byteLength;if(void 0===i){if(p%n)throw V(Et);if((u=p-v)<0)throw V(Et)}else if((u=d(i)*n)+v>p)throw V(Et);c=u/n}else c=Mt(r,!0),u=c*n,o=new X(u);for(h(t,"_d",{b:o,o:v,l:u,e:c,v:new Q(o)});l<c;)M(t,l++)}),_=y[H]=O(Jt),h(_,"constructor",y)):L(function(t){new y(null),new y(t)},!0)||(y=r(function(t,r,e,i){s(t,y,a);var o;return w(r)?r instanceof X||(o=x(r))==K||o==J?void 0!==i?new g(r,At(e,n),i):void 0!==e?new g(r,At(e,n)):new g(r):_t in r?kt(y,r):Rt.call(y,r):new g(Mt(r,l))}),Z(b!==Function.prototype?P(g).concat(P(b)):P(g),function(t){t in y||h(y,t,g[t])}),y[H]=_,e||(_.constructor=y));var A=_[bt],N=!!A&&("values"==A.name||void 0==A.name),T=Vt.values;h(y,xt,!0),h(_,_t,a),h(_,Ot,!0),h(_,wt,y),(f?new y(1)[mt]==a:mt in _)||G(_,mt,{get:function(){return a}}),S[a]=y,u(u.G+u.W+u.F*(y!=g),S),u(u.S,a,{BYTES_PER_ELEMENT:n,from:Rt,of:Ct}),Y in _||h(_,Y,n),u(u.P,a,Wt),R(a),u(u.P+u.F*Ft,a,{set:Bt}),u(u.P+u.F*!N,a,Vt),u(u.P+u.F*(_.toString!=yt),a,{toString:yt}),u(u.P+u.F*o(function(){new y(1).slice()}),a,{slice:Gt}),u(u.P+u.F*(o(function(){return[1,2].toLocaleString()!=new y([1,2]).toLocaleString()})||!o(function(){_.toLocaleString.call([1,2])})),a,{toLocaleString:Ut}),k[a]=N?A:T,e||N||h(_,bt,T)}}else t.exports=function(){}},function(t,n){var r={}.toString;t.exports=function(t){return r.call(t).slice(8,-1)}},function(t,n,r){var e=r(21),i=r(5).document,o=e(i)&&e(i.createElement);t.exports=function(t){return o?i.createElement(t):{}}},function(t,n,r){t.exports=!r(12)&&!r(18)(function(){return 7!=Object.defineProperty(r(57)("div"),"a",{get:function(){return 7}}).a})},function(t,n,r){"use strict";var e=r(36),i=r(51),o=r(64),u=r(13),c=r(8),f=r(35),a=r(96),s=r(38),l=r(103),h=r(15)("iterator"),v=!([].keys&&"next"in[].keys()),p="keys",d="values",y=function(){return this};t.exports=function(t,n,r,g,b,m,x){a(r,n,g);var w,S,_,O=function(t){if(!v&&t in F)return F[t];switch(t){case p:case d:return function(){return new r(this,t)}}return function(){return new r(this,t)}},E=n+" Iterator",P=b==d,j=!1,F=t.prototype,M=F[h]||F["@@iterator"]||b&&F[b],A=M||O(b),N=b?P?O("entries"):A:void 0,T="Array"==n?F.entries||M:M;if(T&&(_=l(T.call(new t)))!==Object.prototype&&(s(_,E,!0),e||c(_,h)||u(_,h,y)),P&&M&&M.name!==d&&(j=!0,A=function(){return M.call(this)}),e&&!x||!v&&!j&&F[h]||u(F,h,A),f[n]=A,f[E]=y,b)if(w={values:P?A:O(d),keys:m?A:O(p),entries:N},x)for(S in w)S in F||o(F,S,w[S]);else i(i.P+i.F*(v||j),n,w);return w}},function(t,n,r){var e=r(20),i=r(100),o=r(34),u=r(39)("IE_PROTO"),c=function(){},f="prototype",a=function(){var t,n=r(57)("iframe"),e=o.length;for(n.style.display="none",r(93).appendChild(n),n.src="javascript:",t=n.contentWindow.document,t.open(),t.write("<script>document.F=Object<\/script>"),t.close(),a=t.F;e--;)delete a[f][o[e]];return a()};t.exports=Object.create||function(t,n){var r;return null!==t?(c[f]=e(t),r=new c,c[f]=null,r[u]=t):r=a(),void 0===n?r:i(r,n)}},function(t,n,r){var e=r(63),i=r(34).concat("length","prototype");n.f=Object.getOwnPropertyNames||function(t){return e(t,i)}},function(t,n){n.f=Object.getOwnPropertySymbols},function(t,n,r){var e=r(8),i=r(9),o=r(90)(!1),u=r(39)("IE_PROTO");t.exports=function(t,n){var r,c=i(t),f=0,a=[];for(r in c)r!=u&&e(c,r)&&a.push(r);for(;n.length>f;)e(c,r=n[f++])&&(~o(a,r)||a.push(r));return a}},function(t,n,r){t.exports=r(13)},function(t,n,r){var e=r(76)("meta"),i=r(6),o=r(24),u=r(11).f,c=0,f=Object.isExtensible||function(){return!0},a=!r(4)(function(){return f(Object.preventExtensions({}))}),s=function(t){u(t,e,{value:{i:"O"+ ++c,w:{}}})},l=function(t,n){if(!i(t))return"symbol"==typeof t?t:("string"==typeof t?"S":"P")+t;if(!o(t,e)){if(!f(t))return"F";if(!n)return"E";s(t)}return t[e].i},h=function(t,n){if(!o(t,e)){if(!f(t))return!0;if(!n)return!1;s(t)}return t[e].w},v=function(t){return a&&p.NEED&&f(t)&&!o(t,e)&&s(t),t},p=t.exports={KEY:e,NEED:!1,fastKey:l,getWeak:h,onFreeze:v}},function(t,n){t.exports=function(t,n){return{enumerable:!(1&t),configurable:!(2&t),writable:!(4&t),value:n}}},function(t,n){var r=Math.ceil,e=Math.floor;t.exports=function(t){return isNaN(t=+t)?0:(t>0?e:r)(t)}},function(t,n){t.exports=function(t,n,r,e){if(!(t instanceof n)||void 0!==e&&e in t)throw TypeError(r+": incorrect invocation!");return t}},function(t,n){t.exports=!1},function(t,n,r){var e=r(2),i=r(173),o=r(133),u=r(145)("IE_PROTO"),c=function(){},f="prototype",a=function(){var t,n=r(132)("iframe"),e=o.length;for(n.style.display="none",r(135).appendChild(n),n.src="javascript:",t=n.contentWindow.document,t.open(),t.write("<script>document.F=Object<\/script>"),t.close(),a=t.F;e--;)delete a[f][o[e]];return a()};t.exports=Object.create||function(t,n){var r;return null!==t?(c[f]=e(t),r=new c,c[f]=null,r[u]=t):r=a(),void 0===n?r:i(r,n)}},function(t,n,r){var e=r(175),i=r(133).concat("length","prototype");n.f=Object.getOwnPropertyNames||function(t){return e(t,i)}},function(t,n,r){var e=r(175),i=r(133);t.exports=Object.keys||function(t){return e(t,i)}},function(t,n,r){var e=r(28);t.exports=function(t,n,r){for(var i in n)e(t,i,n[i],r);return t}},function(t,n,r){"use strict";var e=r(3),i=r(11),o=r(10),u=r(7)("species");t.exports=function(t){var n=e[t];o&&n&&!n[u]&&i.f(n,u,{configurable:!0,get:function(){return this}})}},function(t,n,r){var e=r(67),i=Math.max,o=Math.min;t.exports=function(t,n){return t=e(t),t<0?i(t+n,0):o(t,n)}},function(t,n){var r=0,e=Math.random();t.exports=function(t){return"Symbol(".concat(void 0===t?"":t,")_",(++r+e).toString(36))}},function(t,n,r){var e=r(33);t.exports=function(t){return Object(e(t))}},function(t,n,r){var e=r(7)("unscopables"),i=Array.prototype;void 0==i[e]&&r(27)(i,e,{}),t.exports=function(t){i[e][t]=!0}},function(t,n,r){var e=r(53),i=r(169),o=r(137),u=r(2),c=r(16),f=r(154),a={},s={},n=t.exports=function(t,n,r,l,h){var v,p,d,y,g=h?function(){return t}:f(t),b=e(r,l,n?2:1),m=0;if("function"!=typeof g)throw TypeError(t+" is not iterable!");if(o(g)){for(v=c(t.length);v>m;m++)if((y=n?b(u(p=t[m])[0],p[1]):b(t[m]))===a||y===s)return y}else for(d=g.call(t);!(p=d.next()).done;)if((y=i(d,b,p.value,n))===a||y===s)return y};n.BREAK=a,n.RETURN=s},function(t,n){t.exports={}},function(t,n,r){var e=r(11).f,i=r(24),o=r(7)("toStringTag");t.exports=function(t,n,r){t&&!i(t=r?t:t.prototype,o)&&e(t,o,{configurable:!0,value:n})}},function(t,n,r){var e=r(1),i=r(46),o=r(4),u=r(150),c="["+u+"]",f="​",a=RegExp("^"+c+c+"*"),s=RegExp(c+c+"*$"),l=function(t,n,r){var i={},c=o(function(){return!!u[t]()||f[t]()!=f}),a=i[t]=c?n(h):u[t];r&&(i[r]=a),e(e.P+e.F*c,"String",i)},h=l.trim=function(t,n){return t=String(i(t)),1&n&&(t=t.replace(a,"")),2&n&&(t=t.replace(s,"")),t};t.exports=l},function(t,n,r){t.exports={default:r(86),__esModule:!0}},function(t,n,r){t.exports={default:r(87),__esModule:!0}},function(t,n,r){"use strict";function e(t){return t&&t.__esModule?t:{default:t}}n.__esModule=!0;var i=r(84),o=e(i),u=r(83),c=e(u),f="function"==typeof c.default&&"symbol"==typeof o.default?function(t){return typeof t}:function(t){return t&&"function"==typeof c.default&&t.constructor===c.default&&t!==c.default.prototype?"symbol":typeof t};n.default="function"==typeof c.default&&"symbol"===f(o.default)?function(t){return void 0===t?"undefined":f(t)}:function(t){return t&&"function"==typeof c.default&&t.constructor===c.default&&t!==c.default.prototype?"symbol":void 0===t?"undefined":f(t)}},function(t,n,r){r(110),r(108),r(111),r(112),t.exports=r(25).Symbol},function(t,n,r){r(109),r(113),t.exports=r(44).f("iterator")},function(t,n){t.exports=function(t){if("function"!=typeof t)throw TypeError(t+" is not a function!");return t}},function(t,n){t.exports=function(){}},function(t,n,r){var e=r(9),i=r(106),o=r(105);t.exports=function(t){return function(n,r,u){var c,f=e(n),a=i(f.length),s=o(u,a);if(t&&r!=r){for(;a>s;)if((c=f[s++])!=c)return!0}else for(;a>s;s++)if((t||s in f)&&f[s]===r)return t||s||0;return!t&&-1}}},function(t,n,r){var e=r(88);t.exports=function(t,n,r){if(e(t),void 0===n)return t;switch(r){case 1:return function(r){return t.call(n,r)};case 2:return function(r,e){return t.call(n,r,e)};case 3:return function(r,e,i){return t.call(n,r,e,i)}}return function(){return t.apply(n,arguments)}}},function(t,n,r){var e=r(19),i=r(62),o=r(37);t.exports=function(t){var n=e(t),r=i.f;if(r)for(var u,c=r(t),f=o.f,a=0;c.length>a;)f.call(t,u=c[a++])&&n.push(u);return n}},function(t,n,r){t.exports=r(5).document&&document.documentElement},function(t,n,r){var e=r(56);t.exports=Object("z").propertyIsEnumerable(0)?Object:function(t){return"String"==e(t)?t.split(""):Object(t)}},function(t,n,r){var e=r(56);t.exports=Array.isArray||function(t){return"Array"==e(t)}},function(t,n,r){"use strict";var e=r(60),i=r(22),o=r(38),u={};r(13)(u,r(15)("iterator"),function(){return this}),t.exports=function(t,n,r){t.prototype=e(u,{next:i(1,r)}),o(t,n+" Iterator")}},function(t,n){t.exports=function(t,n){return{value:n,done:!!t}}},function(t,n,r){var e=r(19),i=r(9);t.exports=function(t,n){for(var r,o=i(t),u=e(o),c=u.length,f=0;c>f;)if(o[r=u[f++]]===n)return r}},function(t,n,r){var e=r(23)("meta"),i=r(21),o=r(8),u=r(14).f,c=0,f=Object.isExtensible||function(){return!0},a=!r(18)(function(){return f(Object.preventExtensions({}))}),s=function(t){u(t,e,{value:{i:"O"+ ++c,w:{}}})},l=function(t,n){if(!i(t))return"symbol"==typeof t?t:("string"==typeof t?"S":"P")+t;if(!o(t,e)){if(!f(t))return"F";if(!n)return"E";s(t)}return t[e].i},h=function(t,n){if(!o(t,e)){if(!f(t))return!0;if(!n)return!1;s(t)}return t[e].w},v=function(t){return a&&p.NEED&&f(t)&&!o(t,e)&&s(t),t},p=t.exports={KEY:e,NEED:!1,fastKey:l,getWeak:h,onFreeze:v}},function(t,n,r){var e=r(14),i=r(20),o=r(19);t.exports=r(12)?Object.defineProperties:function(t,n){i(t);for(var r,u=o(n),c=u.length,f=0;c>f;)e.f(t,r=u[f++],n[r]);return t}},function(t,n,r){var e=r(37),i=r(22),o=r(9),u=r(42),c=r(8),f=r(58),a=Object.getOwnPropertyDescriptor;n.f=r(12)?a:function(t,n){if(t=o(t),n=u(n,!0),f)try{return a(t,n)}catch(t){}if(c(t,n))return i(!e.f.call(t,n),t[n])}},function(t,n,r){var e=r(9),i=r(61).f,o={}.toString,u="object"==typeof window&&window&&Object.getOwnPropertyNames?Object.getOwnPropertyNames(window):[],c=function(t){try{return i(t)}catch(t){return u.slice()}};t.exports.f=function(t){return u&&"[object Window]"==o.call(t)?c(t):i(e(t))}},function(t,n,r){var e=r(8),i=r(77),o=r(39)("IE_PROTO"),u=Object.prototype;t.exports=Object.getPrototypeOf||function(t){return t=i(t),e(t,o)?t[o]:"function"==typeof t.constructor&&t instanceof t.constructor?t.constructor.prototype:t instanceof Object?u:null}},function(t,n,r){var e=r(41),i=r(33);t.exports=function(t){return function(n,r){var o,u,c=String(i(n)),f=e(r),a=c.length;return f<0||f>=a?t?"":void 0:(o=c.charCodeAt(f),o<55296||o>56319||f+1===a||(u=c.charCodeAt(f+1))<56320||u>57343?t?c.charAt(f):o:t?c.slice(f,f+2):u-56320+(o-55296<<10)+65536)}}},function(t,n,r){var e=r(41),i=Math.max,o=Math.min;t.exports=function(t,n){return t=e(t),t<0?i(t+n,0):o(t,n)}},function(t,n,r){var e=r(41),i=Math.min;t.exports=function(t){return t>0?i(e(t),9007199254740991):0}},function(t,n,r){"use strict";var e=r(89),i=r(97),o=r(35),u=r(9);t.exports=r(59)(Array,"Array",function(t,n){this._t=u(t),this._i=0,this._k=n},function(){var t=this._t,n=this._k,r=this._i++;return!t||r>=t.length?(this._t=void 0,i(1)):"keys"==n?i(0,r):"values"==n?i(0,t[r]):i(0,[r,t[r]])},"values"),o.Arguments=o.Array,e("keys"),e("values"),e("entries")},function(t,n){},function(t,n,r){"use strict";var e=r(104)(!0);r(59)(String,"String",function(t){this._t=String(t),this._i=0},function(){var t,n=this._t,r=this._i;return r>=n.length?{value:void 0,done:!0}:(t=e(n,r),this._i+=t.length,{value:t,done:!1})})},function(t,n,r){"use strict";var e=r(5),i=r(8),o=r(12),u=r(51),c=r(64),f=r(99).KEY,a=r(18),s=r(40),l=r(38),h=r(23),v=r(15),p=r(44),d=r(43),y=r(98),g=r(92),b=r(95),m=r(20),x=r(9),w=r(42),S=r(22),_=r(60),O=r(102),E=r(101),P=r(14),j=r(19),F=E.f,M=P.f,A=O.f,N=e.Symbol,T=e.JSON,I=T&&T.stringify,k="prototype",L=v("_hidden"),R=v("toPrimitive"),C={}.propertyIsEnumerable,D=s("symbol-registry"),U=s("symbols"),W=s("op-symbols"),G=Object[k],B="function"==typeof N,V=e.QObject,z=!V||!V[k]||!V[k].findChild,q=o&&a(function(){return 7!=_(M({},"a",{get:function(){return M(this,"a",{value:7}).a}})).a})?function(t,n,r){var e=F(G,n);e&&delete G[n],M(t,n,r),e&&t!==G&&M(G,n,e)}:M,K=function(t){var n=U[t]=_(N[k]);return n._k=t,n},J=B&&"symbol"==typeof N.iterator?function(t){return"symbol"==typeof t}:function(t){return t instanceof N},Y=function(t,n,r){return t===G&&Y(W,n,r),m(t),n=w(n,!0),m(r),i(U,n)?(r.enumerable?(i(t,L)&&t[L][n]&&(t[L][n]=!1),r=_(r,{enumerable:S(0,!1)})):(i(t,L)||M(t,L,S(1,{})),t[L][n]=!0),q(t,n,r)):M(t,n,r)},H=function(t,n){m(t);for(var r,e=g(n=x(n)),i=0,o=e.length;o>i;)Y(t,r=e[i++],n[r]);return t},$=function(t,n){return void 0===n?_(t):H(_(t),n)},X=function(t){var n=C.call(this,t=w(t,!0));return!(this===G&&i(U,t)&&!i(W,t))&&(!(n||!i(this,t)||!i(U,t)||i(this,L)&&this[L][t])||n)},Q=function(t,n){if(t=x(t),n=w(n,!0),t!==G||!i(U,n)||i(W,n)){var r=F(t,n);return!r||!i(U,n)||i(t,L)&&t[L][n]||(r.enumerable=!0),r}},Z=function(t){for(var n,r=A(x(t)),e=[],o=0;r.length>o;)i(U,n=r[o++])||n==L||n==f||e.push(n);return e},tt=function(t){for(var n,r=t===G,e=A(r?W:x(t)),o=[],u=0;e.length>u;)!i(U,n=e[u++])||r&&!i(G,n)||o.push(U[n]);return o};B||(N=function(){if(this instanceof N)throw TypeError("Symbol is not a constructor!");var t=h(arguments.length>0?arguments[0]:void 0),n=function(r){this===G&&n.call(W,r),i(this,L)&&i(this[L],t)&&(this[L][t]=!1),q(this,t,S(1,r))};return o&&z&&q(G,t,{configurable:!0,set:n}),K(t)},c(N[k],"toString",function(){return this._k}),E.f=Q,P.f=Y,r(61).f=O.f=Z,r(37).f=X,r(62).f=tt,o&&!r(36)&&c(G,"propertyIsEnumerable",X,!0),p.f=function(t){return K(v(t))}),u(u.G+u.W+u.F*!B,{Symbol:N});for(var nt="hasInstance,isConcatSpreadable,iterator,match,replace,search,species,split,toPrimitive,toStringTag,unscopables".split(","),rt=0;nt.length>rt;)v(nt[rt++]);for(var nt=j(v.store),rt=0;nt.length>rt;)d(nt[rt++]);u(u.S+u.F*!B,"Symbol",{for:function(t){return i(D,t+="")?D[t]:D[t]=N(t)},keyFor:function(t){if(J(t))return y(D,t);throw TypeError(t+" is not a symbol!")},useSetter:function(){z=!0},useSimple:function(){z=!1}}),u(u.S+u.F*!B,"Object",{create:$,defineProperty:Y,defineProperties:H,getOwnPropertyDescriptor:Q,getOwnPropertyNames:Z,getOwnPropertySymbols:tt}),T&&u(u.S+u.F*(!B||a(function(){var t=N();return"[null]"!=I([t])||"{}"!=I({a:t})||"{}"!=I(Object(t))})),"JSON",{stringify:function(t){if(void 0!==t&&!J(t)){for(var n,r,e=[t],i=1;arguments.length>i;)e.push(arguments[i++]);return n=e[1],"function"==typeof n&&(r=n),!r&&b(n)||(n=function(t,n){if(r&&(n=r.call(this,t,n)),!J(n))return n}),e[1]=n,I.apply(T,e)}}}),N[k][R]||r(13)(N[k],R,N[k].valueOf),l(N,"Symbol"),l(Math,"Math",!0),l(e.JSON,"JSON",!0)},function(t,n,r){r(43)("asyncIterator")},function(t,n,r){r(43)("observable")},function(t,n,r){r(107);for(var e=r(5),i=r(13),o=r(35),u=r(15)("toStringTag"),c=["NodeList","DOMTokenList","MediaList","StyleSheetList","CSSRuleList"],f=0;f<5;f++){var a=c[f],s=e[a],l=s&&s.prototype;l&&!l[u]&&i(l,u,a),o[a]=o.Array}},function(t,n,r){var e=r(45),i=r(7)("toStringTag"),o="Arguments"==e(function(){return arguments}()),u=function(t,n){try{return t[n]}catch(t){}};t.exports=function(t){var n,r,c;return void 0===t?"Undefined":null===t?"Null":"string"==typeof(r=u(n=Object(t),i))?r:o?e(n):"Object"==(c=e(n))&&"function"==typeof n.callee?"Arguments":c}},function(t,n,r){var e=r(45);t.exports=Object("z").propertyIsEnumerable(0)?Object:function(t){return"String"==e(t)?t.split(""):Object(t)}},function(t,n){n.f={}.propertyIsEnumerable},function(t,n,r){var e=r(30),i=r(16),o=r(75);t.exports=function(t){return function(n,r,u){var c,f=e(n),a=i(f.length),s=o(u,a);if(t&&r!=r){for(;a>s;)if((c=f[s++])!=c)return!0}else for(;a>s;s++)if((t||s in f)&&f[s]===r)return t||s||0;return!t&&-1}}},function(t,n,r){"use strict";var e=r(3),i=r(1),o=r(28),u=r(73),c=r(65),f=r(79),a=r(68),s=r(6),l=r(4),h=r(123),v=r(81),p=r(136);t.exports=function(t,n,r,d,y,g){var b=e[t],m=b,x=y?"set":"add",w=m&&m.prototype,S={},_=function(t){var n=w[t];o(w,t,"delete"==t?function(t){return!(g&&!s(t))&&n.call(this,0===t?0:t)}:"has"==t?function(t){return!(g&&!s(t))&&n.call(this,0===t?0:t)}:"get"==t?function(t){return g&&!s(t)?void 0:n.call(this,0===t?0:t)}:"add"==t?function(t){return n.call(this,0===t?0:t),this}:function(t,r){return n.call(this,0===t?0:t,r),this})};if("function"==typeof m&&(g||w.forEach&&!l(function(){(new m).entries().next()}))){var O=new m,E=O[x](g?{}:-0,1)!=O,P=l(function(){O.has(1)}),j=h(function(t){new m(t)}),F=!g&&l(function(){for(var t=new m,n=5;n--;)t[x](n,n);return!t.has(-0)});j||(m=n(function(n,r){a(n,m,t);var e=p(new b,n,m);return void 0!=r&&f(r,y,e[x],e),e}),m.prototype=w,w.constructor=m),(P||F)&&(_("delete"),_("has"),y&&_("get")),(F||E)&&_(x),g&&w.clear&&delete w.clear}else m=d.getConstructor(n,t,y,x),u(m.prototype,r),c.NEED=!0;return v(m,t),S[t]=m,i(i.G+i.W+i.F*(m!=b),S),g||d.setStrong(m,t,y),m}},function(t,n,r){"use strict";var e=r(27),i=r(28),o=r(4),u=r(46),c=r(7);t.exports=function(t,n,r){var f=c(t),a=r(u,f,""[t]),s=a[0],l=a[1];o(function(){var n={};return n[f]=function(){return 7},7!=""[t](n)})&&(i(String.prototype,t,s),e(RegExp.prototype,f,2==n?function(t,n){return l.call(t,this,n)}:function(t){return l.call(t,this)}))}
},function(t,n,r){"use strict";var e=r(2);t.exports=function(){var t=e(this),n="";return t.global&&(n+="g"),t.ignoreCase&&(n+="i"),t.multiline&&(n+="m"),t.unicode&&(n+="u"),t.sticky&&(n+="y"),n}},function(t,n){t.exports=function(t,n,r){var e=void 0===r;switch(n.length){case 0:return e?t():t.call(r);case 1:return e?t(n[0]):t.call(r,n[0]);case 2:return e?t(n[0],n[1]):t.call(r,n[0],n[1]);case 3:return e?t(n[0],n[1],n[2]):t.call(r,n[0],n[1],n[2]);case 4:return e?t(n[0],n[1],n[2],n[3]):t.call(r,n[0],n[1],n[2],n[3])}return t.apply(r,n)}},function(t,n,r){var e=r(6),i=r(45),o=r(7)("match");t.exports=function(t){var n;return e(t)&&(void 0!==(n=t[o])?!!n:"RegExp"==i(t))}},function(t,n,r){var e=r(7)("iterator"),i=!1;try{var o=[7][e]();o.return=function(){i=!0},Array.from(o,function(){throw 2})}catch(t){}t.exports=function(t,n){if(!n&&!i)return!1;var r=!1;try{var o=[7],u=o[e]();u.next=function(){return{done:r=!0}},o[e]=function(){return u},t(o)}catch(t){}return r}},function(t,n,r){t.exports=r(69)||!r(4)(function(){var t=Math.random();__defineSetter__.call(null,t,function(){}),delete r(3)[t]})},function(t,n){n.f=Object.getOwnPropertySymbols},function(t,n,r){var e=r(3),i="__core-js_shared__",o=e[i]||(e[i]={});t.exports=function(t){return o[t]||(o[t]={})}},function(t,n,r){for(var e,i=r(3),o=r(27),u=r(76),c=u("typed_array"),f=u("view"),a=!(!i.ArrayBuffer||!i.DataView),s=a,l=0,h="Int8Array,Uint8Array,Uint8ClampedArray,Int16Array,Uint16Array,Int32Array,Uint32Array,Float32Array,Float64Array".split(",");l<9;)(e=i[h[l++]])?(o(e.prototype,c,!0),o(e.prototype,f,!0)):s=!1;t.exports={ABV:a,CONSTR:s,TYPED:c,VIEW:f}},function(t,n){"use strict";var r={versions:function(){var t=window.navigator.userAgent;return{trident:t.indexOf("Trident")>-1,presto:t.indexOf("Presto")>-1,webKit:t.indexOf("AppleWebKit")>-1,gecko:t.indexOf("Gecko")>-1&&-1==t.indexOf("KHTML"),mobile:!!t.match(/AppleWebKit.*Mobile.*/),ios:!!t.match(/\(i[^;]+;( U;)? CPU.+Mac OS X/),android:t.indexOf("Android")>-1||t.indexOf("Linux")>-1,iPhone:t.indexOf("iPhone")>-1||t.indexOf("Mac")>-1,iPad:t.indexOf("iPad")>-1,webApp:-1==t.indexOf("Safari"),weixin:-1==t.indexOf("MicroMessenger")}}()};t.exports=r},function(t,n,r){"use strict";var e=r(85),i=function(t){return t&&t.__esModule?t:{default:t}}(e),o=function(){function t(t,n,e){return n||e?String.fromCharCode(n||e):r[t]||t}function n(t){return e[t]}var r={"&quot;":'"',"&lt;":"<","&gt;":">","&amp;":"&","&nbsp;":" "},e={};for(var u in r)e[r[u]]=u;return r["&apos;"]="'",e["'"]="&#39;",{encode:function(t){return t?(""+t).replace(/['<> "&]/g,n).replace(/\r?\n/g,"<br/>").replace(/\s/g,"&nbsp;"):""},decode:function(n){return n?(""+n).replace(/<br\s*\/?>/gi,"\n").replace(/&quot;|&lt;|&gt;|&amp;|&nbsp;|&apos;|&#(\d+);|&#(\d+)/g,t).replace(/\u00a0/g," "):""},encodeBase16:function(t){if(!t)return t;t+="";for(var n=[],r=0,e=t.length;e>r;r++)n.push(t.charCodeAt(r).toString(16).toUpperCase());return n.join("")},encodeBase16forJSON:function(t){if(!t)return t;t=t.replace(/[\u4E00-\u9FBF]/gi,function(t){return escape(t).replace("%u","\\u")});for(var n=[],r=0,e=t.length;e>r;r++)n.push(t.charCodeAt(r).toString(16).toUpperCase());return n.join("")},decodeBase16:function(t){if(!t)return t;t+="";for(var n=[],r=0,e=t.length;e>r;r+=2)n.push(String.fromCharCode("0x"+t.slice(r,r+2)));return n.join("")},encodeObject:function(t){if(t instanceof Array)for(var n=0,r=t.length;r>n;n++)t[n]=o.encodeObject(t[n]);else if("object"==(void 0===t?"undefined":(0,i.default)(t)))for(var e in t)t[e]=o.encodeObject(t[e]);else if("string"==typeof t)return o.encode(t);return t},loadScript:function(t){var n=document.createElement("script");document.getElementsByTagName("body")[0].appendChild(n),n.setAttribute("src",t)},addLoadEvent:function(t){var n=window.onload;"function"!=typeof window.onload?window.onload=t:window.onload=function(){n(),t()}}}}();t.exports=o},function(t,n,r){"use strict";var e=r(17),i=r(75),o=r(16);t.exports=function(t){for(var n=e(this),r=o(n.length),u=arguments.length,c=i(u>1?arguments[1]:void 0,r),f=u>2?arguments[2]:void 0,a=void 0===f?r:i(f,r);a>c;)n[c++]=t;return n}},function(t,n,r){"use strict";var e=r(11),i=r(66);t.exports=function(t,n,r){n in t?e.f(t,n,i(0,r)):t[n]=r}},function(t,n,r){var e=r(6),i=r(3).document,o=e(i)&&e(i.createElement);t.exports=function(t){return o?i.createElement(t):{}}},function(t,n){t.exports="constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf".split(",")},function(t,n,r){var e=r(7)("match");t.exports=function(t){var n=/./;try{"/./"[t](n)}catch(r){try{return n[e]=!1,!"/./"[t](n)}catch(t){}}return!0}},function(t,n,r){t.exports=r(3).document&&document.documentElement},function(t,n,r){var e=r(6),i=r(144).set;t.exports=function(t,n,r){var o,u=n.constructor;return u!==r&&"function"==typeof u&&(o=u.prototype)!==r.prototype&&e(o)&&i&&i(t,o),t}},function(t,n,r){var e=r(80),i=r(7)("iterator"),o=Array.prototype;t.exports=function(t){return void 0!==t&&(e.Array===t||o[i]===t)}},function(t,n,r){var e=r(45);t.exports=Array.isArray||function(t){return"Array"==e(t)}},function(t,n,r){"use strict";var e=r(70),i=r(66),o=r(81),u={};r(27)(u,r(7)("iterator"),function(){return this}),t.exports=function(t,n,r){t.prototype=e(u,{next:i(1,r)}),o(t,n+" Iterator")}},function(t,n,r){"use strict";var e=r(69),i=r(1),o=r(28),u=r(27),c=r(24),f=r(80),a=r(139),s=r(81),l=r(32),h=r(7)("iterator"),v=!([].keys&&"next"in[].keys()),p="keys",d="values",y=function(){return this};t.exports=function(t,n,r,g,b,m,x){a(r,n,g);var w,S,_,O=function(t){if(!v&&t in F)return F[t];switch(t){case p:case d:return function(){return new r(this,t)}}return function(){return new r(this,t)}},E=n+" Iterator",P=b==d,j=!1,F=t.prototype,M=F[h]||F["@@iterator"]||b&&F[b],A=M||O(b),N=b?P?O("entries"):A:void 0,T="Array"==n?F.entries||M:M;if(T&&(_=l(T.call(new t)))!==Object.prototype&&(s(_,E,!0),e||c(_,h)||u(_,h,y)),P&&M&&M.name!==d&&(j=!0,A=function(){return M.call(this)}),e&&!x||!v&&!j&&F[h]||u(F,h,A),f[n]=A,f[E]=y,b)if(w={values:P?A:O(d),keys:m?A:O(p),entries:N},x)for(S in w)S in F||o(F,S,w[S]);else i(i.P+i.F*(v||j),n,w);return w}},function(t,n){var r=Math.expm1;t.exports=!r||r(10)>22025.465794806718||r(10)<22025.465794806718||-2e-17!=r(-2e-17)?function(t){return 0==(t=+t)?t:t>-1e-6&&t<1e-6?t+t*t/2:Math.exp(t)-1}:r},function(t,n){t.exports=Math.sign||function(t){return 0==(t=+t)||t!=t?t:t<0?-1:1}},function(t,n,r){var e=r(3),i=r(151).set,o=e.MutationObserver||e.WebKitMutationObserver,u=e.process,c=e.Promise,f="process"==r(45)(u);t.exports=function(){var t,n,r,a=function(){var e,i;for(f&&(e=u.domain)&&e.exit();t;){i=t.fn,t=t.next;try{i()}catch(e){throw t?r():n=void 0,e}}n=void 0,e&&e.enter()};if(f)r=function(){u.nextTick(a)};else if(o){var s=!0,l=document.createTextNode("");new o(a).observe(l,{characterData:!0}),r=function(){l.data=s=!s}}else if(c&&c.resolve){var h=c.resolve();r=function(){h.then(a)}}else r=function(){i.call(e,a)};return function(e){var i={fn:e,next:void 0};n&&(n.next=i),t||(t=i,r()),n=i}}},function(t,n,r){var e=r(6),i=r(2),o=function(t,n){if(i(t),!e(n)&&null!==n)throw TypeError(n+": can't set as prototype!")};t.exports={set:Object.setPrototypeOf||("__proto__"in{}?function(t,n,e){try{e=r(53)(Function.call,r(31).f(Object.prototype,"__proto__").set,2),e(t,[]),n=!(t instanceof Array)}catch(t){n=!0}return function(t,r){return o(t,r),n?t.__proto__=r:e(t,r),t}}({},!1):void 0),check:o}},function(t,n,r){var e=r(126)("keys"),i=r(76);t.exports=function(t){return e[t]||(e[t]=i(t))}},function(t,n,r){var e=r(2),i=r(26),o=r(7)("species");t.exports=function(t,n){var r,u=e(t).constructor;return void 0===u||void 0==(r=e(u)[o])?n:i(r)}},function(t,n,r){var e=r(67),i=r(46);t.exports=function(t){return function(n,r){var o,u,c=String(i(n)),f=e(r),a=c.length;return f<0||f>=a?t?"":void 0:(o=c.charCodeAt(f),o<55296||o>56319||f+1===a||(u=c.charCodeAt(f+1))<56320||u>57343?t?c.charAt(f):o:t?c.slice(f,f+2):u-56320+(o-55296<<10)+65536)}}},function(t,n,r){var e=r(122),i=r(46);t.exports=function(t,n,r){if(e(n))throw TypeError("String#"+r+" doesn't accept regex!");return String(i(t))}},function(t,n,r){"use strict";var e=r(67),i=r(46);t.exports=function(t){var n=String(i(this)),r="",o=e(t);if(o<0||o==1/0)throw RangeError("Count can't be negative");for(;o>0;(o>>>=1)&&(n+=n))1&o&&(r+=n);return r}},function(t,n){t.exports="\t\n\v\f\r   ᠎             　\u2028\u2029\ufeff"},function(t,n,r){var e,i,o,u=r(53),c=r(121),f=r(135),a=r(132),s=r(3),l=s.process,h=s.setImmediate,v=s.clearImmediate,p=s.MessageChannel,d=0,y={},g="onreadystatechange",b=function(){var t=+this;if(y.hasOwnProperty(t)){var n=y[t];delete y[t],n()}},m=function(t){b.call(t.data)};h&&v||(h=function(t){for(var n=[],r=1;arguments.length>r;)n.push(arguments[r++]);return y[++d]=function(){c("function"==typeof t?t:Function(t),n)},e(d),d},v=function(t){delete y[t]},"process"==r(45)(l)?e=function(t){l.nextTick(u(b,t,1))}:p?(i=new p,o=i.port2,i.port1.onmessage=m,e=u(o.postMessage,o,1)):s.addEventListener&&"function"==typeof postMessage&&!s.importScripts?(e=function(t){s.postMessage(t+"","*")},s.addEventListener("message",m,!1)):e=g in a("script")?function(t){f.appendChild(a("script"))[g]=function(){f.removeChild(this),b.call(t)}}:function(t){setTimeout(u(b,t,1),0)}),t.exports={set:h,clear:v}},function(t,n,r){"use strict";var e=r(3),i=r(10),o=r(69),u=r(127),c=r(27),f=r(73),a=r(4),s=r(68),l=r(67),h=r(16),v=r(71).f,p=r(11).f,d=r(130),y=r(81),g="ArrayBuffer",b="DataView",m="prototype",x="Wrong length!",w="Wrong index!",S=e[g],_=e[b],O=e.Math,E=e.RangeError,P=e.Infinity,j=S,F=O.abs,M=O.pow,A=O.floor,N=O.log,T=O.LN2,I="buffer",k="byteLength",L="byteOffset",R=i?"_b":I,C=i?"_l":k,D=i?"_o":L,U=function(t,n,r){var e,i,o,u=Array(r),c=8*r-n-1,f=(1<<c)-1,a=f>>1,s=23===n?M(2,-24)-M(2,-77):0,l=0,h=t<0||0===t&&1/t<0?1:0;for(t=F(t),t!=t||t===P?(i=t!=t?1:0,e=f):(e=A(N(t)/T),t*(o=M(2,-e))<1&&(e--,o*=2),t+=e+a>=1?s/o:s*M(2,1-a),t*o>=2&&(e++,o/=2),e+a>=f?(i=0,e=f):e+a>=1?(i=(t*o-1)*M(2,n),e+=a):(i=t*M(2,a-1)*M(2,n),e=0));n>=8;u[l++]=255&i,i/=256,n-=8);for(e=e<<n|i,c+=n;c>0;u[l++]=255&e,e/=256,c-=8);return u[--l]|=128*h,u},W=function(t,n,r){var e,i=8*r-n-1,o=(1<<i)-1,u=o>>1,c=i-7,f=r-1,a=t[f--],s=127&a;for(a>>=7;c>0;s=256*s+t[f],f--,c-=8);for(e=s&(1<<-c)-1,s>>=-c,c+=n;c>0;e=256*e+t[f],f--,c-=8);if(0===s)s=1-u;else{if(s===o)return e?NaN:a?-P:P;e+=M(2,n),s-=u}return(a?-1:1)*e*M(2,s-n)},G=function(t){return t[3]<<24|t[2]<<16|t[1]<<8|t[0]},B=function(t){return[255&t]},V=function(t){return[255&t,t>>8&255]},z=function(t){return[255&t,t>>8&255,t>>16&255,t>>24&255]},q=function(t){return U(t,52,8)},K=function(t){return U(t,23,4)},J=function(t,n,r){p(t[m],n,{get:function(){return this[r]}})},Y=function(t,n,r,e){var i=+r,o=l(i);if(i!=o||o<0||o+n>t[C])throw E(w);var u=t[R]._b,c=o+t[D],f=u.slice(c,c+n);return e?f:f.reverse()},H=function(t,n,r,e,i,o){var u=+r,c=l(u);if(u!=c||c<0||c+n>t[C])throw E(w);for(var f=t[R]._b,a=c+t[D],s=e(+i),h=0;h<n;h++)f[a+h]=s[o?h:n-h-1]},$=function(t,n){s(t,S,g);var r=+n,e=h(r);if(r!=e)throw E(x);return e};if(u.ABV){if(!a(function(){new S})||!a(function(){new S(.5)})){S=function(t){return new j($(this,t))};for(var X,Q=S[m]=j[m],Z=v(j),tt=0;Z.length>tt;)(X=Z[tt++])in S||c(S,X,j[X]);o||(Q.constructor=S)}var nt=new _(new S(2)),rt=_[m].setInt8;nt.setInt8(0,2147483648),nt.setInt8(1,2147483649),!nt.getInt8(0)&&nt.getInt8(1)||f(_[m],{setInt8:function(t,n){rt.call(this,t,n<<24>>24)},setUint8:function(t,n){rt.call(this,t,n<<24>>24)}},!0)}else S=function(t){var n=$(this,t);this._b=d.call(Array(n),0),this[C]=n},_=function(t,n,r){s(this,_,b),s(t,S,b);var e=t[C],i=l(n);if(i<0||i>e)throw E("Wrong offset!");if(r=void 0===r?e-i:h(r),i+r>e)throw E(x);this[R]=t,this[D]=i,this[C]=r},i&&(J(S,k,"_l"),J(_,I,"_b"),J(_,k,"_l"),J(_,L,"_o")),f(_[m],{getInt8:function(t){return Y(this,1,t)[0]<<24>>24},getUint8:function(t){return Y(this,1,t)[0]},getInt16:function(t){var n=Y(this,2,t,arguments[1]);return(n[1]<<8|n[0])<<16>>16},getUint16:function(t){var n=Y(this,2,t,arguments[1]);return n[1]<<8|n[0]},getInt32:function(t){return G(Y(this,4,t,arguments[1]))},getUint32:function(t){return G(Y(this,4,t,arguments[1]))>>>0},getFloat32:function(t){return W(Y(this,4,t,arguments[1]),23,4)},getFloat64:function(t){return W(Y(this,8,t,arguments[1]),52,8)},setInt8:function(t,n){H(this,1,t,B,n)},setUint8:function(t,n){H(this,1,t,B,n)},setInt16:function(t,n){H(this,2,t,V,n,arguments[2])},setUint16:function(t,n){H(this,2,t,V,n,arguments[2])},setInt32:function(t,n){H(this,4,t,z,n,arguments[2])},setUint32:function(t,n){H(this,4,t,z,n,arguments[2])},setFloat32:function(t,n){H(this,4,t,K,n,arguments[2])},setFloat64:function(t,n){H(this,8,t,q,n,arguments[2])}});y(S,g),y(_,b),c(_[m],u.VIEW,!0),n[g]=S,n[b]=_},function(t,n,r){var e=r(3),i=r(52),o=r(69),u=r(182),c=r(11).f;t.exports=function(t){var n=i.Symbol||(i.Symbol=o?{}:e.Symbol||{});"_"==t.charAt(0)||t in n||c(n,t,{value:u.f(t)})}},function(t,n,r){var e=r(114),i=r(7)("iterator"),o=r(80);t.exports=r(52).getIteratorMethod=function(t){if(void 0!=t)return t[i]||t["@@iterator"]||o[e(t)]}},function(t,n,r){"use strict";var e=r(78),i=r(170),o=r(80),u=r(30);t.exports=r(140)(Array,"Array",function(t,n){this._t=u(t),this._i=0,this._k=n},function(){var t=this._t,n=this._k,r=this._i++;return!t||r>=t.length?(this._t=void 0,i(1)):"keys"==n?i(0,r):"values"==n?i(0,t[r]):i(0,[r,t[r]])},"values"),o.Arguments=o.Array,e("keys"),e("values"),e("entries")},function(t,n){function r(t,n){t.classList?t.classList.add(n):t.className+=" "+n}t.exports=r},function(t,n){function r(t,n){if(t.classList)t.classList.remove(n);else{var r=new RegExp("(^|\\b)"+n.split(" ").join("|")+"(\\b|$)","gi");t.className=t.className.replace(r," ")}}t.exports=r},function(t,n){function r(){throw new Error("setTimeout has not been defined")}function e(){throw new Error("clearTimeout has not been defined")}function i(t){if(s===setTimeout)return setTimeout(t,0);if((s===r||!s)&&setTimeout)return s=setTimeout,setTimeout(t,0);try{return s(t,0)}catch(n){try{return s.call(null,t,0)}catch(n){return s.call(this,t,0)}}}function o(t){if(l===clearTimeout)return clearTimeout(t);if((l===e||!l)&&clearTimeout)return l=clearTimeout,clearTimeout(t);try{return l(t)}catch(n){try{return l.call(null,t)}catch(n){return l.call(this,t)}}}function u(){d&&v&&(d=!1,v.length?p=v.concat(p):y=-1,p.length&&c())}function c(){if(!d){var t=i(u);d=!0;for(var n=p.length;n;){for(v=p,p=[];++y<n;)v&&v[y].run();y=-1,n=p.length}v=null,d=!1,o(t)}}function f(t,n){this.fun=t,this.array=n}function a(){}var s,l,h=t.exports={};!function(){try{s="function"==typeof setTimeout?setTimeout:r}catch(t){s=r}try{l="function"==typeof clearTimeout?clearTimeout:e}catch(t){l=e}}();var v,p=[],d=!1,y=-1;h.nextTick=function(t){var n=new Array(arguments.length-1);if(arguments.length>1)for(var r=1;r<arguments.length;r++)n[r-1]=arguments[r];p.push(new f(t,n)),1!==p.length||d||i(c)},f.prototype.run=function(){this.fun.apply(null,this.array)},h.title="browser",h.browser=!0,h.env={},h.argv=[],h.version="",h.versions={},h.on=a,h.addListener=a,h.once=a,h.off=a,h.removeListener=a,h.removeAllListeners=a,h.emit=a,h.prependListener=a,h.prependOnceListener=a,h.listeners=function(t){return[]},h.binding=function(t){throw new Error("process.binding is not supported")},h.cwd=function(){return"/"},h.chdir=function(t){throw new Error("process.chdir is not supported")},h.umask=function(){return 0}},function(t,n,r){var e=r(45);t.exports=function(t,n){if("number"!=typeof t&&"Number"!=e(t))throw TypeError(n);return+t}},function(t,n,r){"use strict";var e=r(17),i=r(75),o=r(16);t.exports=[].copyWithin||function(t,n){var r=e(this),u=o(r.length),c=i(t,u),f=i(n,u),a=arguments.length>2?arguments[2]:void 0,s=Math.min((void 0===a?u:i(a,u))-f,u-c),l=1;for(f<c&&c<f+s&&(l=-1,f+=s-1,c+=s-1);s-- >0;)f in r?r[c]=r[f]:delete r[c],c+=l,f+=l;return r}},function(t,n,r){var e=r(79);t.exports=function(t,n){var r=[];return e(t,!1,r.push,r,n),r}},function(t,n,r){var e=r(26),i=r(17),o=r(115),u=r(16);t.exports=function(t,n,r,c,f){e(n);var a=i(t),s=o(a),l=u(a.length),h=f?l-1:0,v=f?-1:1;if(r<2)for(;;){if(h in s){c=s[h],h+=v;break}if(h+=v,f?h<0:l<=h)throw TypeError("Reduce of empty array with no initial value")}for(;f?h>=0:l>h;h+=v)h in s&&(c=n(c,s[h],h,a));return c}},function(t,n,r){"use strict";var e=r(26),i=r(6),o=r(121),u=[].slice,c={},f=function(t,n,r){if(!(n in c)){for(var e=[],i=0;i<n;i++)e[i]="a["+i+"]";c[n]=Function("F,a","return new F("+e.join(",")+")")}return c[n](t,r)};t.exports=Function.bind||function(t){var n=e(this),r=u.call(arguments,1),c=function(){var e=r.concat(u.call(arguments));return this instanceof c?f(n,e.length,e):o(n,e,t)};return i(n.prototype)&&(c.prototype=n.prototype),c}},function(t,n,r){"use strict";var e=r(11).f,i=r(70),o=r(73),u=r(53),c=r(68),f=r(46),a=r(79),s=r(140),l=r(170),h=r(74),v=r(10),p=r(65).fastKey,d=v?"_s":"size",y=function(t,n){var r,e=p(n);if("F"!==e)return t._i[e];for(r=t._f;r;r=r.n)if(r.k==n)return r};t.exports={getConstructor:function(t,n,r,s){var l=t(function(t,e){c(t,l,n,"_i"),t._i=i(null),t._f=void 0,t._l=void 0,t[d]=0,void 0!=e&&a(e,r,t[s],t)});return o(l.prototype,{clear:function(){for(var t=this,n=t._i,r=t._f;r;r=r.n)r.r=!0,r.p&&(r.p=r.p.n=void 0),delete n[r.i];t._f=t._l=void 0,t[d]=0},delete:function(t){var n=this,r=y(n,t);if(r){var e=r.n,i=r.p;delete n._i[r.i],r.r=!0,i&&(i.n=e),e&&(e.p=i),n._f==r&&(n._f=e),n._l==r&&(n._l=i),n[d]--}return!!r},forEach:function(t){c(this,l,"forEach");for(var n,r=u(t,arguments.length>1?arguments[1]:void 0,3);n=n?n.n:this._f;)for(r(n.v,n.k,this);n&&n.r;)n=n.p},has:function(t){return!!y(this,t)}}),v&&e(l.prototype,"size",{get:function(){return f(this[d])}}),l},def:function(t,n,r){var e,i,o=y(t,n);return o?o.v=r:(t._l=o={i:i=p(n,!0),k:n,v:r,p:e=t._l,n:void 0,r:!1},t._f||(t._f=o),e&&(e.n=o),t[d]++,"F"!==i&&(t._i[i]=o)),t},getEntry:y,setStrong:function(t,n,r){s(t,n,function(t,n){this._t=t,this._k=n,this._l=void 0},function(){for(var t=this,n=t._k,r=t._l;r&&r.r;)r=r.p;return t._t&&(t._l=r=r?r.n:t._t._f)?"keys"==n?l(0,r.k):"values"==n?l(0,r.v):l(0,[r.k,r.v]):(t._t=void 0,l(1))},r?"entries":"values",!r,!0),h(n)}}},function(t,n,r){var e=r(114),i=r(161);t.exports=function(t){return function(){if(e(this)!=t)throw TypeError(t+"#toJSON isn't generic");return i(this)}}},function(t,n,r){"use strict";var e=r(73),i=r(65).getWeak,o=r(2),u=r(6),c=r(68),f=r(79),a=r(48),s=r(24),l=a(5),h=a(6),v=0,p=function(t){return t._l||(t._l=new d)},d=function(){this.a=[]},y=function(t,n){return l(t.a,function(t){return t[0]===n})};d.prototype={get:function(t){var n=y(this,t);if(n)return n[1]},has:function(t){return!!y(this,t)},set:function(t,n){var r=y(this,t);r?r[1]=n:this.a.push([t,n])},delete:function(t){var n=h(this.a,function(n){return n[0]===t});return~n&&this.a.splice(n,1),!!~n}},t.exports={getConstructor:function(t,n,r,o){var a=t(function(t,e){c(t,a,n,"_i"),t._i=v++,t._l=void 0,void 0!=e&&f(e,r,t[o],t)});return e(a.prototype,{delete:function(t){if(!u(t))return!1;var n=i(t);return!0===n?p(this).delete(t):n&&s(n,this._i)&&delete n[this._i]},has:function(t){if(!u(t))return!1;var n=i(t);return!0===n?p(this).has(t):n&&s(n,this._i)}}),a},def:function(t,n,r){var e=i(o(n),!0);return!0===e?p(t).set(n,r):e[t._i]=r,t},ufstore:p}},function(t,n,r){t.exports=!r(10)&&!r(4)(function(){return 7!=Object.defineProperty(r(132)("div"),"a",{get:function(){return 7}}).a})},function(t,n,r){var e=r(6),i=Math.floor;t.exports=function(t){return!e(t)&&isFinite(t)&&i(t)===t}},function(t,n,r){var e=r(2);t.exports=function(t,n,r,i){try{return i?n(e(r)[0],r[1]):n(r)}catch(n){var o=t.return;throw void 0!==o&&e(o.call(t)),n}}},function(t,n){t.exports=function(t,n){return{value:n,done:!!t}}},function(t,n){t.exports=Math.log1p||function(t){return(t=+t)>-1e-8&&t<1e-8?t-t*t/2:Math.log(1+t)}},function(t,n,r){"use strict";var e=r(72),i=r(125),o=r(116),u=r(17),c=r(115),f=Object.assign;t.exports=!f||r(4)(function(){var t={},n={},r=Symbol(),e="abcdefghijklmnopqrst";return t[r]=7,e.split("").forEach(function(t){n[t]=t}),7!=f({},t)[r]||Object.keys(f({},n)).join("")!=e})?function(t,n){for(var r=u(t),f=arguments.length,a=1,s=i.f,l=o.f;f>a;)for(var h,v=c(arguments[a++]),p=s?e(v).concat(s(v)):e(v),d=p.length,y=0;d>y;)l.call(v,h=p[y++])&&(r[h]=v[h]);return r}:f},function(t,n,r){var e=r(11),i=r(2),o=r(72);t.exports=r(10)?Object.defineProperties:function(t,n){i(t);for(var r,u=o(n),c=u.length,f=0;c>f;)e.f(t,r=u[f++],n[r]);return t}},function(t,n,r){var e=r(30),i=r(71).f,o={}.toString,u="object"==typeof window&&window&&Object.getOwnPropertyNames?Object.getOwnPropertyNames(window):[],c=function(t){try{return i(t)}catch(t){return u.slice()}};t.exports.f=function(t){return u&&"[object Window]"==o.call(t)?c(t):i(e(t))}},function(t,n,r){var e=r(24),i=r(30),o=r(117)(!1),u=r(145)("IE_PROTO");t.exports=function(t,n){var r,c=i(t),f=0,a=[];for(r in c)r!=u&&e(c,r)&&a.push(r);for(;n.length>f;)e(c,r=n[f++])&&(~o(a,r)||a.push(r));return a}},function(t,n,r){var e=r(72),i=r(30),o=r(116).f;t.exports=function(t){return function(n){for(var r,u=i(n),c=e(u),f=c.length,a=0,s=[];f>a;)o.call(u,r=c[a++])&&s.push(t?[r,u[r]]:u[r]);return s}}},function(t,n,r){var e=r(71),i=r(125),o=r(2),u=r(3).Reflect;t.exports=u&&u.ownKeys||function(t){var n=e.f(o(t)),r=i.f;return r?n.concat(r(t)):n}},function(t,n,r){var e=r(3).parseFloat,i=r(82).trim;t.exports=1/e(r(150)+"-0")!=-1/0?function(t){var n=i(String(t),3),r=e(n);return 0===r&&"-"==n.charAt(0)?-0:r}:e},function(t,n,r){var e=r(3).parseInt,i=r(82).trim,o=r(150),u=/^[\-+]?0[xX]/;t.exports=8!==e(o+"08")||22!==e(o+"0x16")?function(t,n){var r=i(String(t),3);return e(r,n>>>0||(u.test(r)?16:10))}:e},function(t,n){t.exports=Object.is||function(t,n){return t===n?0!==t||1/t==1/n:t!=t&&n!=n}},function(t,n,r){var e=r(16),i=r(149),o=r(46);t.exports=function(t,n,r,u){var c=String(o(t)),f=c.length,a=void 0===r?" ":String(r),s=e(n);if(s<=f||""==a)return c;var l=s-f,h=i.call(a,Math.ceil(l/a.length));return h.length>l&&(h=h.slice(0,l)),u?h+c:c+h}},function(t,n,r){n.f=r(7)},function(t,n,r){"use strict";var e=r(164);t.exports=r(118)("Map",function(t){return function(){return t(this,arguments.length>0?arguments[0]:void 0)}},{get:function(t){var n=e.getEntry(this,t);return n&&n.v},set:function(t,n){return e.def(this,0===t?0:t,n)}},e,!0)},function(t,n,r){r(10)&&"g"!=/./g.flags&&r(11).f(RegExp.prototype,"flags",{configurable:!0,get:r(120)})},function(t,n,r){"use strict";var e=r(164);t.exports=r(118)("Set",function(t){return function(){return t(this,arguments.length>0?arguments[0]:void 0)}},{add:function(t){return e.def(this,t=0===t?0:t,t)}},e)},function(t,n,r){"use strict";var e,i=r(48)(0),o=r(28),u=r(65),c=r(172),f=r(166),a=r(6),s=u.getWeak,l=Object.isExtensible,h=f.ufstore,v={},p=function(t){return function(){return t(this,arguments.length>0?arguments[0]:void 0)}},d={get:function(t){if(a(t)){var n=s(t);return!0===n?h(this).get(t):n?n[this._i]:void 0}},set:function(t,n){return f.def(this,t,n)}},y=t.exports=r(118)("WeakMap",p,d,f,!0,!0);7!=(new y).set((Object.freeze||Object)(v),7).get(v)&&(e=f.getConstructor(p),c(e.prototype,d),u.NEED=!0,i(["delete","has","get","set"],function(t){var n=y.prototype,r=n[t];o(n,t,function(n,i){if(a(n)&&!l(n)){this._f||(this._f=new e);var o=this._f[t](n,i);return"set"==t?this:o}return r.call(this,n,i)})}))},,,,function(t,n){"use strict";function r(){var t=document.querySelector("#page-nav");if(t&&!document.querySelector("#page-nav .extend.prev")&&(t.innerHTML='<a class="extend prev disabled" rel="prev">&laquo; Prev</a>'+t.innerHTML),t&&!document.querySelector("#page-nav .extend.next")&&(t.innerHTML=t.innerHTML+'<a class="extend next disabled" rel="next">Next &raquo;</a>'),yiliaConfig&&yiliaConfig.open_in_new){document.querySelectorAll(".article-entry a:not(.article-more-a)").forEach(function(t){var n=t.getAttribute("target");n&&""!==n||t.setAttribute("target","_blank")})}if(yiliaConfig&&yiliaConfig.toc_hide_index){document.querySelectorAll(".toc-number").forEach(function(t){t.style.display="none"})}var n=document.querySelector("#js-aboutme");n&&0!==n.length&&(n.innerHTML=n.innerText)}t.exports={init:r}},function(t,n,r){"use strict";function e(t){return t&&t.__esModule?t:{default:t}}function i(t,n){var r=/\/|index.html/g;return t.replace(r,"")===n.replace(r,"")}function o(){for(var t=document.querySelectorAll(".js-header-menu li a"),n=window.location.pathname,r=0,e=t.length;r<e;r++){var o=t[r];i(n,o.getAttribute("href"))&&(0,h.default)(o,"active")}}function u(t){for(var n=t.offsetLeft,r=t.offsetParent;null!==r;)n+=r.offsetLeft,r=r.offsetParent;return n}function c(t){for(var n=t.offsetTop,r=t.offsetParent;null!==r;)n+=r.offsetTop,r=r.offsetParent;return n}function f(t,n,r,e,i){var o=u(t),f=c(t)-n;if(f-r<=i){var a=t.$newDom;a||(a=t.cloneNode(!0),(0,d.default)(t,a),t.$newDom=a,a.style.position="fixed",a.style.top=(r||f)+"px",a.style.left=o+"px",a.style.zIndex=e||2,a.style.width="100%",a.style.color="#fff"),a.style.visibility="visible",t.style.visibility="hidden"}else{t.style.visibility="visible";var s=t.$newDom;s&&(s.style.visibility="hidden")}}function a(){var t=document.querySelector(".js-overlay"),n=document.querySelector(".js-header-menu");f(t,document.body.scrollTop,-63,2,0),f(n,document.body.scrollTop,1,3,0)}function s(){document.querySelector("#container").addEventListener("scroll",function(t){a()}),window.addEventListener("scroll",function(t){a()}),a()}var l=r(156),h=e(l),v=r(157),p=(e(v),r(382)),d=e(p),y=r(128),g=e(y),b=r(190),m=e(b),x=r(129);(function(){g.default.versions.mobile&&window.screen.width<800&&(o(),s())})(),(0,x.addLoadEvent)(function(){m.default.init()}),t.exports={}},,,,function(t,n,r){(function(t){"use strict";function n(t,n,r){t[n]||Object[e](t,n,{writable:!0,configurable:!0,value:r})}if(r(381),r(391),r(198),t._babelPolyfill)throw new Error("only one instance of babel-polyfill is allowed");t._babelPolyfill=!0;var e="defineProperty";n(String.prototype,"padLeft","".padStart),n(String.prototype,"padRight","".padEnd),"pop,reverse,shift,keys,values,entries,indexOf,every,some,forEach,map,filter,find,findIndex,includes,join,slice,concat,push,splice,unshift,sort,lastIndexOf,reduce,reduceRight,copyWithin,fill".split(",").forEach(function(t){[][t]&&n(Array,t,Function.call.bind([][t]))})}).call(n,function(){return this}())},,,function(t,n,r){r(210),t.exports=r(52).RegExp.escape},,,,function(t,n,r){var e=r(6),i=r(138),o=r(7)("species");t.exports=function(t){var n;return i(t)&&(n=t.constructor,"function"!=typeof n||n!==Array&&!i(n.prototype)||(n=void 0),e(n)&&null===(n=n[o])&&(n=void 0)),void 0===n?Array:n}},function(t,n,r){var e=r(202);t.exports=function(t,n){return new(e(t))(n)}},function(t,n,r){"use strict";var e=r(2),i=r(50),o="number";t.exports=function(t){if("string"!==t&&t!==o&&"default"!==t)throw TypeError("Incorrect hint");return i(e(this),t!=o)}},function(t,n,r){var e=r(72),i=r(125),o=r(116);t.exports=function(t){var n=e(t),r=i.f;if(r)for(var u,c=r(t),f=o.f,a=0;c.length>a;)f.call(t,u=c[a++])&&n.push(u);return n}},function(t,n,r){var e=r(72),i=r(30);t.exports=function(t,n){for(var r,o=i(t),u=e(o),c=u.length,f=0;c>f;)if(o[r=u[f++]]===n)return r}},function(t,n,r){"use strict";var e=r(208),i=r(121),o=r(26);t.exports=function(){for(var t=o(this),n=arguments.length,r=Array(n),u=0,c=e._,f=!1;n>u;)(r[u]=arguments[u++])===c&&(f=!0);return function(){var e,o=this,u=arguments.length,a=0,s=0;if(!f&&!u)return i(t,r,o);if(e=r.slice(),f)for(;n>a;a++)e[a]===c&&(e[a]=arguments[s++]);for(;u>s;)e.push(arguments[s++]);return i(t,e,o)}}},function(t,n,r){t.exports=r(3)},function(t,n){t.exports=function(t,n){var r=n===Object(n)?function(t){return n[t]}:n;return function(n){return String(n).replace(t,r)}}},function(t,n,r){var e=r(1),i=r(209)(/[\\^$*+?.()|[\]{}]/g,"\\$&");e(e.S,"RegExp",{escape:function(t){return i(t)}})},function(t,n,r){var e=r(1);e(e.P,"Array",{copyWithin:r(160)}),r(78)("copyWithin")},function(t,n,r){"use strict";var e=r(1),i=r(48)(4);e(e.P+e.F*!r(47)([].every,!0),"Array",{every:function(t){return i(this,t,arguments[1])}})},function(t,n,r){var e=r(1);e(e.P,"Array",{fill:r(130)}),r(78)("fill")},function(t,n,r){"use strict";var e=r(1),i=r(48)(2);e(e.P+e.F*!r(47)([].filter,!0),"Array",{filter:function(t){return i(this,t,arguments[1])}})},function(t,n,r){"use strict";var e=r(1),i=r(48)(6),o="findIndex",u=!0;o in[]&&Array(1)[o](function(){u=!1}),e(e.P+e.F*u,"Array",{findIndex:function(t){return i(this,t,arguments.length>1?arguments[1]:void 0)}}),r(78)(o)},function(t,n,r){"use strict";var e=r(1),i=r(48)(5),o="find",u=!0;o in[]&&Array(1)[o](function(){u=!1}),e(e.P+e.F*u,"Array",{find:function(t){return i(this,t,arguments.length>1?arguments[1]:void 0)}}),r(78)(o)},function(t,n,r){"use strict";var e=r(1),i=r(48)(0),o=r(47)([].forEach,!0);e(e.P+e.F*!o,"Array",{forEach:function(t){return i(this,t,arguments[1])}})},function(t,n,r){"use strict";var e=r(53),i=r(1),o=r(17),u=r(169),c=r(137),f=r(16),a=r(131),s=r(154);i(i.S+i.F*!r(123)(function(t){Array.from(t)}),"Array",{from:function(t){var n,r,i,l,h=o(t),v="function"==typeof this?this:Array,p=arguments.length,d=p>1?arguments[1]:void 0,y=void 0!==d,g=0,b=s(h);if(y&&(d=e(d,p>2?arguments[2]:void 0,2)),void 0==b||v==Array&&c(b))for(n=f(h.length),r=new v(n);n>g;g++)a(r,g,y?d(h[g],g):h[g]);else for(l=b.call(h),r=new v;!(i=l.next()).done;g++)a(r,g,y?u(l,d,[i.value,g],!0):i.value);return r.length=g,r}})},function(t,n,r){"use strict";var e=r(1),i=r(117)(!1),o=[].indexOf,u=!!o&&1/[1].indexOf(1,-0)<0;e(e.P+e.F*(u||!r(47)(o)),"Array",{indexOf:function(t){return u?o.apply(this,arguments)||0:i(this,t,arguments[1])}})},function(t,n,r){var e=r(1);e(e.S,"Array",{isArray:r(138)})},function(t,n,r){"use strict";var e=r(1),i=r(30),o=[].join;e(e.P+e.F*(r(115)!=Object||!r(47)(o)),"Array",{join:function(t){return o.call(i(this),void 0===t?",":t)}})},function(t,n,r){"use strict";var e=r(1),i=r(30),o=r(67),u=r(16),c=[].lastIndexOf,f=!!c&&1/[1].lastIndexOf(1,-0)<0;e(e.P+e.F*(f||!r(47)(c)),"Array",{lastIndexOf:function(t){if(f)return c.apply(this,arguments)||0;var n=i(this),r=u(n.length),e=r-1;for(arguments.length>1&&(e=Math.min(e,o(arguments[1]))),e<0&&(e=r+e);e>=0;e--)if(e in n&&n[e]===t)return e||0;return-1}})},function(t,n,r){"use strict";var e=r(1),i=r(48)(1);e(e.P+e.F*!r(47)([].map,!0),"Array",{map:function(t){return i(this,t,arguments[1])}})},function(t,n,r){"use strict";var e=r(1),i=r(131);e(e.S+e.F*r(4)(function(){function t(){}return!(Array.of.call(t)instanceof t)}),"Array",{of:function(){for(var t=0,n=arguments.length,r=new("function"==typeof this?this:Array)(n);n>t;)i(r,t,arguments[t++]);return r.length=n,r}})},function(t,n,r){"use strict";var e=r(1),i=r(162);e(e.P+e.F*!r(47)([].reduceRight,!0),"Array",{reduceRight:function(t){return i(this,t,arguments.length,arguments[1],!0)}})},function(t,n,r){"use strict";var e=r(1),i=r(162);e(e.P+e.F*!r(47)([].reduce,!0),"Array",{reduce:function(t){return i(this,t,arguments.length,arguments[1],!1)}})},function(t,n,r){"use strict";var e=r(1),i=r(135),o=r(45),u=r(75),c=r(16),f=[].slice;e(e.P+e.F*r(4)(function(){i&&f.call(i)}),"Array",{slice:function(t,n){var r=c(this.length),e=o(this);if(n=void 0===n?r:n,"Array"==e)return f.call(this,t,n);for(var i=u(t,r),a=u(n,r),s=c(a-i),l=Array(s),h=0;h<s;h++)l[h]="String"==e?this.charAt(i+h):this[i+h];return l}})},function(t,n,r){"use strict";var e=r(1),i=r(48)(3);e(e.P+e.F*!r(47)([].some,!0),"Array",{some:function(t){return i(this,t,arguments[1])}})},function(t,n,r){"use strict";var e=r(1),i=r(26),o=r(17),u=r(4),c=[].sort,f=[1,2,3];e(e.P+e.F*(u(function(){f.sort(void 0)})||!u(function(){f.sort(null)})||!r(47)(c)),"Array",{sort:function(t){return void 0===t?c.call(o(this)):c.call(o(this),i(t))}})},function(t,n,r){r(74)("Array")},function(t,n,r){var e=r(1);e(e.S,"Date",{now:function(){return(new Date).getTime()}})},function(t,n,r){"use strict";var e=r(1),i=r(4),o=Date.prototype.getTime,u=function(t){return t>9?t:"0"+t};e(e.P+e.F*(i(function(){return"0385-07-25T07:06:39.999Z"!=new Date(-5e13-1).toISOString()})||!i(function(){new Date(NaN).toISOString()})),"Date",{toISOString:function(){
if(!isFinite(o.call(this)))throw RangeError("Invalid time value");var t=this,n=t.getUTCFullYear(),r=t.getUTCMilliseconds(),e=n<0?"-":n>9999?"+":"";return e+("00000"+Math.abs(n)).slice(e?-6:-4)+"-"+u(t.getUTCMonth()+1)+"-"+u(t.getUTCDate())+"T"+u(t.getUTCHours())+":"+u(t.getUTCMinutes())+":"+u(t.getUTCSeconds())+"."+(r>99?r:"0"+u(r))+"Z"}})},function(t,n,r){"use strict";var e=r(1),i=r(17),o=r(50);e(e.P+e.F*r(4)(function(){return null!==new Date(NaN).toJSON()||1!==Date.prototype.toJSON.call({toISOString:function(){return 1}})}),"Date",{toJSON:function(t){var n=i(this),r=o(n);return"number"!=typeof r||isFinite(r)?n.toISOString():null}})},function(t,n,r){var e=r(7)("toPrimitive"),i=Date.prototype;e in i||r(27)(i,e,r(204))},function(t,n,r){var e=Date.prototype,i="Invalid Date",o="toString",u=e[o],c=e.getTime;new Date(NaN)+""!=i&&r(28)(e,o,function(){var t=c.call(this);return t===t?u.call(this):i})},function(t,n,r){var e=r(1);e(e.P,"Function",{bind:r(163)})},function(t,n,r){"use strict";var e=r(6),i=r(32),o=r(7)("hasInstance"),u=Function.prototype;o in u||r(11).f(u,o,{value:function(t){if("function"!=typeof this||!e(t))return!1;if(!e(this.prototype))return t instanceof this;for(;t=i(t);)if(this.prototype===t)return!0;return!1}})},function(t,n,r){var e=r(11).f,i=r(66),o=r(24),u=Function.prototype,c="name",f=Object.isExtensible||function(){return!0};c in u||r(10)&&e(u,c,{configurable:!0,get:function(){try{var t=this,n=(""+t).match(/^\s*function ([^ (]*)/)[1];return o(t,c)||!f(t)||e(t,c,i(5,n)),n}catch(t){return""}}})},function(t,n,r){var e=r(1),i=r(171),o=Math.sqrt,u=Math.acosh;e(e.S+e.F*!(u&&710==Math.floor(u(Number.MAX_VALUE))&&u(1/0)==1/0),"Math",{acosh:function(t){return(t=+t)<1?NaN:t>94906265.62425156?Math.log(t)+Math.LN2:i(t-1+o(t-1)*o(t+1))}})},function(t,n,r){function e(t){return isFinite(t=+t)&&0!=t?t<0?-e(-t):Math.log(t+Math.sqrt(t*t+1)):t}var i=r(1),o=Math.asinh;i(i.S+i.F*!(o&&1/o(0)>0),"Math",{asinh:e})},function(t,n,r){var e=r(1),i=Math.atanh;e(e.S+e.F*!(i&&1/i(-0)<0),"Math",{atanh:function(t){return 0==(t=+t)?t:Math.log((1+t)/(1-t))/2}})},function(t,n,r){var e=r(1),i=r(142);e(e.S,"Math",{cbrt:function(t){return i(t=+t)*Math.pow(Math.abs(t),1/3)}})},function(t,n,r){var e=r(1);e(e.S,"Math",{clz32:function(t){return(t>>>=0)?31-Math.floor(Math.log(t+.5)*Math.LOG2E):32}})},function(t,n,r){var e=r(1),i=Math.exp;e(e.S,"Math",{cosh:function(t){return(i(t=+t)+i(-t))/2}})},function(t,n,r){var e=r(1),i=r(141);e(e.S+e.F*(i!=Math.expm1),"Math",{expm1:i})},function(t,n,r){var e=r(1),i=r(142),o=Math.pow,u=o(2,-52),c=o(2,-23),f=o(2,127)*(2-c),a=o(2,-126),s=function(t){return t+1/u-1/u};e(e.S,"Math",{fround:function(t){var n,r,e=Math.abs(t),o=i(t);return e<a?o*s(e/a/c)*a*c:(n=(1+c/u)*e,r=n-(n-e),r>f||r!=r?o*(1/0):o*r)}})},function(t,n,r){var e=r(1),i=Math.abs;e(e.S,"Math",{hypot:function(t,n){for(var r,e,o=0,u=0,c=arguments.length,f=0;u<c;)r=i(arguments[u++]),f<r?(e=f/r,o=o*e*e+1,f=r):r>0?(e=r/f,o+=e*e):o+=r;return f===1/0?1/0:f*Math.sqrt(o)}})},function(t,n,r){var e=r(1),i=Math.imul;e(e.S+e.F*r(4)(function(){return-5!=i(4294967295,5)||2!=i.length}),"Math",{imul:function(t,n){var r=65535,e=+t,i=+n,o=r&e,u=r&i;return 0|o*u+((r&e>>>16)*u+o*(r&i>>>16)<<16>>>0)}})},function(t,n,r){var e=r(1);e(e.S,"Math",{log10:function(t){return Math.log(t)/Math.LN10}})},function(t,n,r){var e=r(1);e(e.S,"Math",{log1p:r(171)})},function(t,n,r){var e=r(1);e(e.S,"Math",{log2:function(t){return Math.log(t)/Math.LN2}})},function(t,n,r){var e=r(1);e(e.S,"Math",{sign:r(142)})},function(t,n,r){var e=r(1),i=r(141),o=Math.exp;e(e.S+e.F*r(4)(function(){return-2e-17!=!Math.sinh(-2e-17)}),"Math",{sinh:function(t){return Math.abs(t=+t)<1?(i(t)-i(-t))/2:(o(t-1)-o(-t-1))*(Math.E/2)}})},function(t,n,r){var e=r(1),i=r(141),o=Math.exp;e(e.S,"Math",{tanh:function(t){var n=i(t=+t),r=i(-t);return n==1/0?1:r==1/0?-1:(n-r)/(o(t)+o(-t))}})},function(t,n,r){var e=r(1);e(e.S,"Math",{trunc:function(t){return(t>0?Math.floor:Math.ceil)(t)}})},function(t,n,r){"use strict";var e=r(3),i=r(24),o=r(45),u=r(136),c=r(50),f=r(4),a=r(71).f,s=r(31).f,l=r(11).f,h=r(82).trim,v="Number",p=e[v],d=p,y=p.prototype,g=o(r(70)(y))==v,b="trim"in String.prototype,m=function(t){var n=c(t,!1);if("string"==typeof n&&n.length>2){n=b?n.trim():h(n,3);var r,e,i,o=n.charCodeAt(0);if(43===o||45===o){if(88===(r=n.charCodeAt(2))||120===r)return NaN}else if(48===o){switch(n.charCodeAt(1)){case 66:case 98:e=2,i=49;break;case 79:case 111:e=8,i=55;break;default:return+n}for(var u,f=n.slice(2),a=0,s=f.length;a<s;a++)if((u=f.charCodeAt(a))<48||u>i)return NaN;return parseInt(f,e)}}return+n};if(!p(" 0o1")||!p("0b1")||p("+0x1")){p=function(t){var n=arguments.length<1?0:t,r=this;return r instanceof p&&(g?f(function(){y.valueOf.call(r)}):o(r)!=v)?u(new d(m(n)),r,p):m(n)};for(var x,w=r(10)?a(d):"MAX_VALUE,MIN_VALUE,NaN,NEGATIVE_INFINITY,POSITIVE_INFINITY,EPSILON,isFinite,isInteger,isNaN,isSafeInteger,MAX_SAFE_INTEGER,MIN_SAFE_INTEGER,parseFloat,parseInt,isInteger".split(","),S=0;w.length>S;S++)i(d,x=w[S])&&!i(p,x)&&l(p,x,s(d,x));p.prototype=y,y.constructor=p,r(28)(e,v,p)}},function(t,n,r){var e=r(1);e(e.S,"Number",{EPSILON:Math.pow(2,-52)})},function(t,n,r){var e=r(1),i=r(3).isFinite;e(e.S,"Number",{isFinite:function(t){return"number"==typeof t&&i(t)}})},function(t,n,r){var e=r(1);e(e.S,"Number",{isInteger:r(168)})},function(t,n,r){var e=r(1);e(e.S,"Number",{isNaN:function(t){return t!=t}})},function(t,n,r){var e=r(1),i=r(168),o=Math.abs;e(e.S,"Number",{isSafeInteger:function(t){return i(t)&&o(t)<=9007199254740991}})},function(t,n,r){var e=r(1);e(e.S,"Number",{MAX_SAFE_INTEGER:9007199254740991})},function(t,n,r){var e=r(1);e(e.S,"Number",{MIN_SAFE_INTEGER:-9007199254740991})},function(t,n,r){var e=r(1),i=r(178);e(e.S+e.F*(Number.parseFloat!=i),"Number",{parseFloat:i})},function(t,n,r){var e=r(1),i=r(179);e(e.S+e.F*(Number.parseInt!=i),"Number",{parseInt:i})},function(t,n,r){"use strict";var e=r(1),i=r(67),o=r(159),u=r(149),c=1..toFixed,f=Math.floor,a=[0,0,0,0,0,0],s="Number.toFixed: incorrect invocation!",l="0",h=function(t,n){for(var r=-1,e=n;++r<6;)e+=t*a[r],a[r]=e%1e7,e=f(e/1e7)},v=function(t){for(var n=6,r=0;--n>=0;)r+=a[n],a[n]=f(r/t),r=r%t*1e7},p=function(){for(var t=6,n="";--t>=0;)if(""!==n||0===t||0!==a[t]){var r=String(a[t]);n=""===n?r:n+u.call(l,7-r.length)+r}return n},d=function(t,n,r){return 0===n?r:n%2==1?d(t,n-1,r*t):d(t*t,n/2,r)},y=function(t){for(var n=0,r=t;r>=4096;)n+=12,r/=4096;for(;r>=2;)n+=1,r/=2;return n};e(e.P+e.F*(!!c&&("0.000"!==8e-5.toFixed(3)||"1"!==.9.toFixed(0)||"1.25"!==1.255.toFixed(2)||"1000000000000000128"!==(0xde0b6b3a7640080).toFixed(0))||!r(4)(function(){c.call({})})),"Number",{toFixed:function(t){var n,r,e,c,f=o(this,s),a=i(t),g="",b=l;if(a<0||a>20)throw RangeError(s);if(f!=f)return"NaN";if(f<=-1e21||f>=1e21)return String(f);if(f<0&&(g="-",f=-f),f>1e-21)if(n=y(f*d(2,69,1))-69,r=n<0?f*d(2,-n,1):f/d(2,n,1),r*=4503599627370496,(n=52-n)>0){for(h(0,r),e=a;e>=7;)h(1e7,0),e-=7;for(h(d(10,e,1),0),e=n-1;e>=23;)v(1<<23),e-=23;v(1<<e),h(1,1),v(2),b=p()}else h(0,r),h(1<<-n,0),b=p()+u.call(l,a);return a>0?(c=b.length,b=g+(c<=a?"0."+u.call(l,a-c)+b:b.slice(0,c-a)+"."+b.slice(c-a))):b=g+b,b}})},function(t,n,r){"use strict";var e=r(1),i=r(4),o=r(159),u=1..toPrecision;e(e.P+e.F*(i(function(){return"1"!==u.call(1,void 0)})||!i(function(){u.call({})})),"Number",{toPrecision:function(t){var n=o(this,"Number#toPrecision: incorrect invocation!");return void 0===t?u.call(n):u.call(n,t)}})},function(t,n,r){var e=r(1);e(e.S+e.F,"Object",{assign:r(172)})},function(t,n,r){var e=r(1);e(e.S,"Object",{create:r(70)})},function(t,n,r){var e=r(1);e(e.S+e.F*!r(10),"Object",{defineProperties:r(173)})},function(t,n,r){var e=r(1);e(e.S+e.F*!r(10),"Object",{defineProperty:r(11).f})},function(t,n,r){var e=r(6),i=r(65).onFreeze;r(49)("freeze",function(t){return function(n){return t&&e(n)?t(i(n)):n}})},function(t,n,r){var e=r(30),i=r(31).f;r(49)("getOwnPropertyDescriptor",function(){return function(t,n){return i(e(t),n)}})},function(t,n,r){r(49)("getOwnPropertyNames",function(){return r(174).f})},function(t,n,r){var e=r(17),i=r(32);r(49)("getPrototypeOf",function(){return function(t){return i(e(t))}})},function(t,n,r){var e=r(6);r(49)("isExtensible",function(t){return function(n){return!!e(n)&&(!t||t(n))}})},function(t,n,r){var e=r(6);r(49)("isFrozen",function(t){return function(n){return!e(n)||!!t&&t(n)}})},function(t,n,r){var e=r(6);r(49)("isSealed",function(t){return function(n){return!e(n)||!!t&&t(n)}})},function(t,n,r){var e=r(1);e(e.S,"Object",{is:r(180)})},function(t,n,r){var e=r(17),i=r(72);r(49)("keys",function(){return function(t){return i(e(t))}})},function(t,n,r){var e=r(6),i=r(65).onFreeze;r(49)("preventExtensions",function(t){return function(n){return t&&e(n)?t(i(n)):n}})},function(t,n,r){var e=r(6),i=r(65).onFreeze;r(49)("seal",function(t){return function(n){return t&&e(n)?t(i(n)):n}})},function(t,n,r){var e=r(1);e(e.S,"Object",{setPrototypeOf:r(144).set})},function(t,n,r){"use strict";var e=r(114),i={};i[r(7)("toStringTag")]="z",i+""!="[object z]"&&r(28)(Object.prototype,"toString",function(){return"[object "+e(this)+"]"},!0)},function(t,n,r){var e=r(1),i=r(178);e(e.G+e.F*(parseFloat!=i),{parseFloat:i})},function(t,n,r){var e=r(1),i=r(179);e(e.G+e.F*(parseInt!=i),{parseInt:i})},function(t,n,r){"use strict";var e,i,o,u=r(69),c=r(3),f=r(53),a=r(114),s=r(1),l=r(6),h=r(26),v=r(68),p=r(79),d=r(146),y=r(151).set,g=r(143)(),b="Promise",m=c.TypeError,x=c.process,w=c[b],x=c.process,S="process"==a(x),_=function(){},O=!!function(){try{var t=w.resolve(1),n=(t.constructor={})[r(7)("species")]=function(t){t(_,_)};return(S||"function"==typeof PromiseRejectionEvent)&&t.then(_)instanceof n}catch(t){}}(),E=function(t,n){return t===n||t===w&&n===o},P=function(t){var n;return!(!l(t)||"function"!=typeof(n=t.then))&&n},j=function(t){return E(w,t)?new F(t):new i(t)},F=i=function(t){var n,r;this.promise=new t(function(t,e){if(void 0!==n||void 0!==r)throw m("Bad Promise constructor");n=t,r=e}),this.resolve=h(n),this.reject=h(r)},M=function(t){try{t()}catch(t){return{error:t}}},A=function(t,n){if(!t._n){t._n=!0;var r=t._c;g(function(){for(var e=t._v,i=1==t._s,o=0;r.length>o;)!function(n){var r,o,u=i?n.ok:n.fail,c=n.resolve,f=n.reject,a=n.domain;try{u?(i||(2==t._h&&I(t),t._h=1),!0===u?r=e:(a&&a.enter(),r=u(e),a&&a.exit()),r===n.promise?f(m("Promise-chain cycle")):(o=P(r))?o.call(r,c,f):c(r)):f(e)}catch(t){f(t)}}(r[o++]);t._c=[],t._n=!1,n&&!t._h&&N(t)})}},N=function(t){y.call(c,function(){var n,r,e,i=t._v;if(T(t)&&(n=M(function(){S?x.emit("unhandledRejection",i,t):(r=c.onunhandledrejection)?r({promise:t,reason:i}):(e=c.console)&&e.error&&e.error("Unhandled promise rejection",i)}),t._h=S||T(t)?2:1),t._a=void 0,n)throw n.error})},T=function(t){if(1==t._h)return!1;for(var n,r=t._a||t._c,e=0;r.length>e;)if(n=r[e++],n.fail||!T(n.promise))return!1;return!0},I=function(t){y.call(c,function(){var n;S?x.emit("rejectionHandled",t):(n=c.onrejectionhandled)&&n({promise:t,reason:t._v})})},k=function(t){var n=this;n._d||(n._d=!0,n=n._w||n,n._v=t,n._s=2,n._a||(n._a=n._c.slice()),A(n,!0))},L=function(t){var n,r=this;if(!r._d){r._d=!0,r=r._w||r;try{if(r===t)throw m("Promise can't be resolved itself");(n=P(t))?g(function(){var e={_w:r,_d:!1};try{n.call(t,f(L,e,1),f(k,e,1))}catch(t){k.call(e,t)}}):(r._v=t,r._s=1,A(r,!1))}catch(t){k.call({_w:r,_d:!1},t)}}};O||(w=function(t){v(this,w,b,"_h"),h(t),e.call(this);try{t(f(L,this,1),f(k,this,1))}catch(t){k.call(this,t)}},e=function(t){this._c=[],this._a=void 0,this._s=0,this._d=!1,this._v=void 0,this._h=0,this._n=!1},e.prototype=r(73)(w.prototype,{then:function(t,n){var r=j(d(this,w));return r.ok="function"!=typeof t||t,r.fail="function"==typeof n&&n,r.domain=S?x.domain:void 0,this._c.push(r),this._a&&this._a.push(r),this._s&&A(this,!1),r.promise},catch:function(t){return this.then(void 0,t)}}),F=function(){var t=new e;this.promise=t,this.resolve=f(L,t,1),this.reject=f(k,t,1)}),s(s.G+s.W+s.F*!O,{Promise:w}),r(81)(w,b),r(74)(b),o=r(52)[b],s(s.S+s.F*!O,b,{reject:function(t){var n=j(this);return(0,n.reject)(t),n.promise}}),s(s.S+s.F*(u||!O),b,{resolve:function(t){if(t instanceof w&&E(t.constructor,this))return t;var n=j(this);return(0,n.resolve)(t),n.promise}}),s(s.S+s.F*!(O&&r(123)(function(t){w.all(t).catch(_)})),b,{all:function(t){var n=this,r=j(n),e=r.resolve,i=r.reject,o=M(function(){var r=[],o=0,u=1;p(t,!1,function(t){var c=o++,f=!1;r.push(void 0),u++,n.resolve(t).then(function(t){f||(f=!0,r[c]=t,--u||e(r))},i)}),--u||e(r)});return o&&i(o.error),r.promise},race:function(t){var n=this,r=j(n),e=r.reject,i=M(function(){p(t,!1,function(t){n.resolve(t).then(r.resolve,e)})});return i&&e(i.error),r.promise}})},function(t,n,r){var e=r(1),i=r(26),o=r(2),u=(r(3).Reflect||{}).apply,c=Function.apply;e(e.S+e.F*!r(4)(function(){u(function(){})}),"Reflect",{apply:function(t,n,r){var e=i(t),f=o(r);return u?u(e,n,f):c.call(e,n,f)}})},function(t,n,r){var e=r(1),i=r(70),o=r(26),u=r(2),c=r(6),f=r(4),a=r(163),s=(r(3).Reflect||{}).construct,l=f(function(){function t(){}return!(s(function(){},[],t)instanceof t)}),h=!f(function(){s(function(){})});e(e.S+e.F*(l||h),"Reflect",{construct:function(t,n){o(t),u(n);var r=arguments.length<3?t:o(arguments[2]);if(h&&!l)return s(t,n,r);if(t==r){switch(n.length){case 0:return new t;case 1:return new t(n[0]);case 2:return new t(n[0],n[1]);case 3:return new t(n[0],n[1],n[2]);case 4:return new t(n[0],n[1],n[2],n[3])}var e=[null];return e.push.apply(e,n),new(a.apply(t,e))}var f=r.prototype,v=i(c(f)?f:Object.prototype),p=Function.apply.call(t,v,n);return c(p)?p:v}})},function(t,n,r){var e=r(11),i=r(1),o=r(2),u=r(50);i(i.S+i.F*r(4)(function(){Reflect.defineProperty(e.f({},1,{value:1}),1,{value:2})}),"Reflect",{defineProperty:function(t,n,r){o(t),n=u(n,!0),o(r);try{return e.f(t,n,r),!0}catch(t){return!1}}})},function(t,n,r){var e=r(1),i=r(31).f,o=r(2);e(e.S,"Reflect",{deleteProperty:function(t,n){var r=i(o(t),n);return!(r&&!r.configurable)&&delete t[n]}})},function(t,n,r){"use strict";var e=r(1),i=r(2),o=function(t){this._t=i(t),this._i=0;var n,r=this._k=[];for(n in t)r.push(n)};r(139)(o,"Object",function(){var t,n=this,r=n._k;do{if(n._i>=r.length)return{value:void 0,done:!0}}while(!((t=r[n._i++])in n._t));return{value:t,done:!1}}),e(e.S,"Reflect",{enumerate:function(t){return new o(t)}})},function(t,n,r){var e=r(31),i=r(1),o=r(2);i(i.S,"Reflect",{getOwnPropertyDescriptor:function(t,n){return e.f(o(t),n)}})},function(t,n,r){var e=r(1),i=r(32),o=r(2);e(e.S,"Reflect",{getPrototypeOf:function(t){return i(o(t))}})},function(t,n,r){function e(t,n){var r,c,s=arguments.length<3?t:arguments[2];return a(t)===s?t[n]:(r=i.f(t,n))?u(r,"value")?r.value:void 0!==r.get?r.get.call(s):void 0:f(c=o(t))?e(c,n,s):void 0}var i=r(31),o=r(32),u=r(24),c=r(1),f=r(6),a=r(2);c(c.S,"Reflect",{get:e})},function(t,n,r){var e=r(1);e(e.S,"Reflect",{has:function(t,n){return n in t}})},function(t,n,r){var e=r(1),i=r(2),o=Object.isExtensible;e(e.S,"Reflect",{isExtensible:function(t){return i(t),!o||o(t)}})},function(t,n,r){var e=r(1);e(e.S,"Reflect",{ownKeys:r(177)})},function(t,n,r){var e=r(1),i=r(2),o=Object.preventExtensions;e(e.S,"Reflect",{preventExtensions:function(t){i(t);try{return o&&o(t),!0}catch(t){return!1}}})},function(t,n,r){var e=r(1),i=r(144);i&&e(e.S,"Reflect",{setPrototypeOf:function(t,n){i.check(t,n);try{return i.set(t,n),!0}catch(t){return!1}}})},function(t,n,r){function e(t,n,r){var f,h,v=arguments.length<4?t:arguments[3],p=o.f(s(t),n);if(!p){if(l(h=u(t)))return e(h,n,r,v);p=a(0)}return c(p,"value")?!(!1===p.writable||!l(v)||(f=o.f(v,n)||a(0),f.value=r,i.f(v,n,f),0)):void 0!==p.set&&(p.set.call(v,r),!0)}var i=r(11),o=r(31),u=r(32),c=r(24),f=r(1),a=r(66),s=r(2),l=r(6);f(f.S,"Reflect",{set:e})},function(t,n,r){var e=r(3),i=r(136),o=r(11).f,u=r(71).f,c=r(122),f=r(120),a=e.RegExp,s=a,l=a.prototype,h=/a/g,v=/a/g,p=new a(h)!==h;if(r(10)&&(!p||r(4)(function(){return v[r(7)("match")]=!1,a(h)!=h||a(v)==v||"/a/i"!=a(h,"i")}))){a=function(t,n){var r=this instanceof a,e=c(t),o=void 0===n;return!r&&e&&t.constructor===a&&o?t:i(p?new s(e&&!o?t.source:t,n):s((e=t instanceof a)?t.source:t,e&&o?f.call(t):n),r?this:l,a)};for(var d=u(s),y=0;d.length>y;)!function(t){t in a||o(a,t,{configurable:!0,get:function(){return s[t]},set:function(n){s[t]=n}})}(d[y++]);l.constructor=a,a.prototype=l,r(28)(e,"RegExp",a)}r(74)("RegExp")},function(t,n,r){r(119)("match",1,function(t,n,r){return[function(r){"use strict";var e=t(this),i=void 0==r?void 0:r[n];return void 0!==i?i.call(r,e):new RegExp(r)[n](String(e))},r]})},function(t,n,r){r(119)("replace",2,function(t,n,r){return[function(e,i){"use strict";var o=t(this),u=void 0==e?void 0:e[n];return void 0!==u?u.call(e,o,i):r.call(String(o),e,i)},r]})},function(t,n,r){r(119)("search",1,function(t,n,r){return[function(r){"use strict";var e=t(this),i=void 0==r?void 0:r[n];return void 0!==i?i.call(r,e):new RegExp(r)[n](String(e))},r]})},function(t,n,r){r(119)("split",2,function(t,n,e){"use strict";var i=r(122),o=e,u=[].push,c="split",f="length",a="lastIndex";if("c"=="abbc"[c](/(b)*/)[1]||4!="test"[c](/(?:)/,-1)[f]||2!="ab"[c](/(?:ab)*/)[f]||4!="."[c](/(.?)(.?)/)[f]||"."[c](/()()/)[f]>1||""[c](/.?/)[f]){var s=void 0===/()??/.exec("")[1];e=function(t,n){var r=String(this);if(void 0===t&&0===n)return[];if(!i(t))return o.call(r,t,n);var e,c,l,h,v,p=[],d=(t.ignoreCase?"i":"")+(t.multiline?"m":"")+(t.unicode?"u":"")+(t.sticky?"y":""),y=0,g=void 0===n?4294967295:n>>>0,b=new RegExp(t.source,d+"g");for(s||(e=new RegExp("^"+b.source+"$(?!\\s)",d));(c=b.exec(r))&&!((l=c.index+c[0][f])>y&&(p.push(r.slice(y,c.index)),!s&&c[f]>1&&c[0].replace(e,function(){for(v=1;v<arguments[f]-2;v++)void 0===arguments[v]&&(c[v]=void 0)}),c[f]>1&&c.index<r[f]&&u.apply(p,c.slice(1)),h=c[0][f],y=l,p[f]>=g));)b[a]===c.index&&b[a]++;return y===r[f]?!h&&b.test("")||p.push(""):p.push(r.slice(y)),p[f]>g?p.slice(0,g):p}}else"0"[c](void 0,0)[f]&&(e=function(t,n){return void 0===t&&0===n?[]:o.call(this,t,n)});return[function(r,i){var o=t(this),u=void 0==r?void 0:r[n];return void 0!==u?u.call(r,o,i):e.call(String(o),r,i)},e]})},function(t,n,r){"use strict";r(184);var e=r(2),i=r(120),o=r(10),u="toString",c=/./[u],f=function(t){r(28)(RegExp.prototype,u,t,!0)};r(4)(function(){return"/a/b"!=c.call({source:"a",flags:"b"})})?f(function(){var t=e(this);return"/".concat(t.source,"/","flags"in t?t.flags:!o&&t instanceof RegExp?i.call(t):void 0)}):c.name!=u&&f(function(){return c.call(this)})},function(t,n,r){"use strict";r(29)("anchor",function(t){return function(n){return t(this,"a","name",n)}})},function(t,n,r){"use strict";r(29)("big",function(t){return function(){return t(this,"big","","")}})},function(t,n,r){"use strict";r(29)("blink",function(t){return function(){return t(this,"blink","","")}})},function(t,n,r){"use strict";r(29)("bold",function(t){return function(){return t(this,"b","","")}})},function(t,n,r){"use strict";var e=r(1),i=r(147)(!1);e(e.P,"String",{codePointAt:function(t){return i(this,t)}})},function(t,n,r){"use strict";var e=r(1),i=r(16),o=r(148),u="endsWith",c=""[u];e(e.P+e.F*r(134)(u),"String",{endsWith:function(t){var n=o(this,t,u),r=arguments.length>1?arguments[1]:void 0,e=i(n.length),f=void 0===r?e:Math.min(i(r),e),a=String(t);return c?c.call(n,a,f):n.slice(f-a.length,f)===a}})},function(t,n,r){"use strict";r(29)("fixed",function(t){return function(){return t(this,"tt","","")}})},function(t,n,r){"use strict";r(29)("fontcolor",function(t){return function(n){return t(this,"font","color",n)}})},function(t,n,r){"use strict";r(29)("fontsize",function(t){return function(n){return t(this,"font","size",n)}})},function(t,n,r){var e=r(1),i=r(75),o=String.fromCharCode,u=String.fromCodePoint;e(e.S+e.F*(!!u&&1!=u.length),"String",{fromCodePoint:function(t){for(var n,r=[],e=arguments.length,u=0;e>u;){if(n=+arguments[u++],i(n,1114111)!==n)throw RangeError(n+" is not a valid code point");r.push(n<65536?o(n):o(55296+((n-=65536)>>10),n%1024+56320))}return r.join("")}})},function(t,n,r){"use strict";var e=r(1),i=r(148),o="includes";e(e.P+e.F*r(134)(o),"String",{includes:function(t){return!!~i(this,t,o).indexOf(t,arguments.length>1?arguments[1]:void 0)}})},function(t,n,r){"use strict";r(29)("italics",function(t){return function(){return t(this,"i","","")}})},function(t,n,r){"use strict";var e=r(147)(!0);r(140)(String,"String",function(t){this._t=String(t),this._i=0},function(){var t,n=this._t,r=this._i;return r>=n.length?{value:void 0,done:!0}:(t=e(n,r),this._i+=t.length,{value:t,done:!1})})},function(t,n,r){"use strict";r(29)("link",function(t){return function(n){return t(this,"a","href",n)}})},function(t,n,r){var e=r(1),i=r(30),o=r(16);e(e.S,"String",{raw:function(t){for(var n=i(t.raw),r=o(n.length),e=arguments.length,u=[],c=0;r>c;)u.push(String(n[c++])),c<e&&u.push(String(arguments[c]));return u.join("")}})},function(t,n,r){var e=r(1);e(e.P,"String",{repeat:r(149)})},function(t,n,r){"use strict";r(29)("small",function(t){return function(){return t(this,"small","","")}})},function(t,n,r){"use strict";var e=r(1),i=r(16),o=r(148),u="startsWith",c=""[u];e(e.P+e.F*r(134)(u),"String",{startsWith:function(t){var n=o(this,t,u),r=i(Math.min(arguments.length>1?arguments[1]:void 0,n.length)),e=String(t);return c?c.call(n,e,r):n.slice(r,r+e.length)===e}})},function(t,n,r){"use strict";r(29)("strike",function(t){return function(){return t(this,"strike","","")}})},function(t,n,r){"use strict";r(29)("sub",function(t){return function(){return t(this,"sub","","")}})},function(t,n,r){"use strict";r(29)("sup",function(t){return function(){return t(this,"sup","","")}})},function(t,n,r){"use strict";r(82)("trim",function(t){return function(){return t(this,3)}})},function(t,n,r){"use strict";var e=r(3),i=r(24),o=r(10),u=r(1),c=r(28),f=r(65).KEY,a=r(4),s=r(126),l=r(81),h=r(76),v=r(7),p=r(182),d=r(153),y=r(206),g=r(205),b=r(138),m=r(2),x=r(30),w=r(50),S=r(66),_=r(70),O=r(174),E=r(31),P=r(11),j=r(72),F=E.f,M=P.f,A=O.f,N=e.Symbol,T=e.JSON,I=T&&T.stringify,k="prototype",L=v("_hidden"),R=v("toPrimitive"),C={}.propertyIsEnumerable,D=s("symbol-registry"),U=s("symbols"),W=s("op-symbols"),G=Object[k],B="function"==typeof N,V=e.QObject,z=!V||!V[k]||!V[k].findChild,q=o&&a(function(){return 7!=_(M({},"a",{get:function(){return M(this,"a",{value:7}).a}})).a})?function(t,n,r){var e=F(G,n);e&&delete G[n],M(t,n,r),e&&t!==G&&M(G,n,e)}:M,K=function(t){var n=U[t]=_(N[k]);return n._k=t,n},J=B&&"symbol"==typeof N.iterator?function(t){return"symbol"==typeof t}:function(t){return t instanceof N},Y=function(t,n,r){return t===G&&Y(W,n,r),m(t),n=w(n,!0),m(r),i(U,n)?(r.enumerable?(i(t,L)&&t[L][n]&&(t[L][n]=!1),r=_(r,{enumerable:S(0,!1)})):(i(t,L)||M(t,L,S(1,{})),t[L][n]=!0),q(t,n,r)):M(t,n,r)},H=function(t,n){m(t);for(var r,e=g(n=x(n)),i=0,o=e.length;o>i;)Y(t,r=e[i++],n[r]);return t},$=function(t,n){return void 0===n?_(t):H(_(t),n)},X=function(t){var n=C.call(this,t=w(t,!0));return!(this===G&&i(U,t)&&!i(W,t))&&(!(n||!i(this,t)||!i(U,t)||i(this,L)&&this[L][t])||n)},Q=function(t,n){if(t=x(t),n=w(n,!0),t!==G||!i(U,n)||i(W,n)){var r=F(t,n);return!r||!i(U,n)||i(t,L)&&t[L][n]||(r.enumerable=!0),r}},Z=function(t){for(var n,r=A(x(t)),e=[],o=0;r.length>o;)i(U,n=r[o++])||n==L||n==f||e.push(n);return e},tt=function(t){for(var n,r=t===G,e=A(r?W:x(t)),o=[],u=0;e.length>u;)!i(U,n=e[u++])||r&&!i(G,n)||o.push(U[n]);return o};B||(N=function(){if(this instanceof N)throw TypeError("Symbol is not a constructor!");var t=h(arguments.length>0?arguments[0]:void 0),n=function(r){this===G&&n.call(W,r),i(this,L)&&i(this[L],t)&&(this[L][t]=!1),q(this,t,S(1,r))};return o&&z&&q(G,t,{configurable:!0,set:n}),K(t)},c(N[k],"toString",function(){return this._k}),E.f=Q,P.f=Y,r(71).f=O.f=Z,r(116).f=X,r(125).f=tt,o&&!r(69)&&c(G,"propertyIsEnumerable",X,!0),p.f=function(t){return K(v(t))}),u(u.G+u.W+u.F*!B,{Symbol:N});for(var nt="hasInstance,isConcatSpreadable,iterator,match,replace,search,species,split,toPrimitive,toStringTag,unscopables".split(","),rt=0;nt.length>rt;)v(nt[rt++]);for(var nt=j(v.store),rt=0;nt.length>rt;)d(nt[rt++]);u(u.S+u.F*!B,"Symbol",{for:function(t){return i(D,t+="")?D[t]:D[t]=N(t)},keyFor:function(t){if(J(t))return y(D,t);throw TypeError(t+" is not a symbol!")},useSetter:function(){z=!0},useSimple:function(){z=!1}}),u(u.S+u.F*!B,"Object",{create:$,defineProperty:Y,defineProperties:H,getOwnPropertyDescriptor:Q,getOwnPropertyNames:Z,getOwnPropertySymbols:tt}),T&&u(u.S+u.F*(!B||a(function(){var t=N();return"[null]"!=I([t])||"{}"!=I({a:t})||"{}"!=I(Object(t))})),"JSON",{stringify:function(t){if(void 0!==t&&!J(t)){for(var n,r,e=[t],i=1;arguments.length>i;)e.push(arguments[i++]);return n=e[1],"function"==typeof n&&(r=n),!r&&b(n)||(n=function(t,n){if(r&&(n=r.call(this,t,n)),!J(n))return n}),e[1]=n,I.apply(T,e)}}}),N[k][R]||r(27)(N[k],R,N[k].valueOf),l(N,"Symbol"),l(Math,"Math",!0),l(e.JSON,"JSON",!0)},function(t,n,r){"use strict";var e=r(1),i=r(127),o=r(152),u=r(2),c=r(75),f=r(16),a=r(6),s=r(3).ArrayBuffer,l=r(146),h=o.ArrayBuffer,v=o.DataView,p=i.ABV&&s.isView,d=h.prototype.slice,y=i.VIEW,g="ArrayBuffer";e(e.G+e.W+e.F*(s!==h),{ArrayBuffer:h}),e(e.S+e.F*!i.CONSTR,g,{isView:function(t){return p&&p(t)||a(t)&&y in t}}),e(e.P+e.U+e.F*r(4)(function(){return!new h(2).slice(1,void 0).byteLength}),g,{slice:function(t,n){if(void 0!==d&&void 0===n)return d.call(u(this),t);for(var r=u(this).byteLength,e=c(t,r),i=c(void 0===n?r:n,r),o=new(l(this,h))(f(i-e)),a=new v(this),s=new v(o),p=0;e<i;)s.setUint8(p++,a.getUint8(e++));return o}}),r(74)(g)},function(t,n,r){var e=r(1);e(e.G+e.W+e.F*!r(127).ABV,{DataView:r(152).DataView})},function(t,n,r){r(55)("Float32",4,function(t){return function(n,r,e){return t(this,n,r,e)}})},function(t,n,r){r(55)("Float64",8,function(t){return function(n,r,e){return t(this,n,r,e)}})},function(t,n,r){r(55)("Int16",2,function(t){return function(n,r,e){return t(this,n,r,e)}})},function(t,n,r){r(55)("Int32",4,function(t){return function(n,r,e){return t(this,n,r,e)}})},function(t,n,r){r(55)("Int8",1,function(t){return function(n,r,e){return t(this,n,r,e)}})},function(t,n,r){r(55)("Uint16",2,function(t){return function(n,r,e){return t(this,n,r,e)}})},function(t,n,r){r(55)("Uint32",4,function(t){return function(n,r,e){return t(this,n,r,e)}})},function(t,n,r){r(55)("Uint8",1,function(t){return function(n,r,e){return t(this,n,r,e)}})},function(t,n,r){r(55)("Uint8",1,function(t){return function(n,r,e){return t(this,n,r,e)}},!0)},function(t,n,r){"use strict";var e=r(166);r(118)("WeakSet",function(t){return function(){return t(this,arguments.length>0?arguments[0]:void 0)}},{add:function(t){return e.def(this,t,!0)}},e,!1,!0)},function(t,n,r){"use strict";var e=r(1),i=r(117)(!0);e(e.P,"Array",{includes:function(t){return i(this,t,arguments.length>1?arguments[1]:void 0)}}),r(78)("includes")},function(t,n,r){var e=r(1),i=r(143)(),o=r(3).process,u="process"==r(45)(o);e(e.G,{asap:function(t){var n=u&&o.domain;i(n?n.bind(t):t)}})},function(t,n,r){var e=r(1),i=r(45);e(e.S,"Error",{isError:function(t){return"Error"===i(t)}})},function(t,n,r){var e=r(1);e(e.P+e.R,"Map",{toJSON:r(165)("Map")})},function(t,n,r){var e=r(1);e(e.S,"Math",{iaddh:function(t,n,r,e){var i=t>>>0,o=n>>>0,u=r>>>0;return o+(e>>>0)+((i&u|(i|u)&~(i+u>>>0))>>>31)|0}})},function(t,n,r){var e=r(1);e(e.S,"Math",{imulh:function(t,n){var r=65535,e=+t,i=+n,o=e&r,u=i&r,c=e>>16,f=i>>16,a=(c*u>>>0)+(o*u>>>16);return c*f+(a>>16)+((o*f>>>0)+(a&r)>>16)}})},function(t,n,r){var e=r(1);e(e.S,"Math",{isubh:function(t,n,r,e){var i=t>>>0,o=n>>>0,u=r>>>0;return o-(e>>>0)-((~i&u|~(i^u)&i-u>>>0)>>>31)|0}})},function(t,n,r){var e=r(1);e(e.S,"Math",{umulh:function(t,n){var r=65535,e=+t,i=+n,o=e&r,u=i&r,c=e>>>16,f=i>>>16,a=(c*u>>>0)+(o*u>>>16);return c*f+(a>>>16)+((o*f>>>0)+(a&r)>>>16)}})},function(t,n,r){"use strict";var e=r(1),i=r(17),o=r(26),u=r(11);r(10)&&e(e.P+r(124),"Object",{__defineGetter__:function(t,n){u.f(i(this),t,{get:o(n),enumerable:!0,configurable:!0})}})},function(t,n,r){"use strict";var e=r(1),i=r(17),o=r(26),u=r(11);r(10)&&e(e.P+r(124),"Object",{__defineSetter__:function(t,n){u.f(i(this),t,{set:o(n),enumerable:!0,configurable:!0})}})},function(t,n,r){var e=r(1),i=r(176)(!0);e(e.S,"Object",{entries:function(t){return i(t)}})},function(t,n,r){var e=r(1),i=r(177),o=r(30),u=r(31),c=r(131);e(e.S,"Object",{getOwnPropertyDescriptors:function(t){for(var n,r=o(t),e=u.f,f=i(r),a={},s=0;f.length>s;)c(a,n=f[s++],e(r,n));return a}})},function(t,n,r){"use strict";var e=r(1),i=r(17),o=r(50),u=r(32),c=r(31).f;r(10)&&e(e.P+r(124),"Object",{__lookupGetter__:function(t){var n,r=i(this),e=o(t,!0);do{if(n=c(r,e))return n.get}while(r=u(r))}})},function(t,n,r){"use strict";var e=r(1),i=r(17),o=r(50),u=r(32),c=r(31).f;r(10)&&e(e.P+r(124),"Object",{__lookupSetter__:function(t){var n,r=i(this),e=o(t,!0);do{if(n=c(r,e))return n.set}while(r=u(r))}})},function(t,n,r){var e=r(1),i=r(176)(!1);e(e.S,"Object",{values:function(t){return i(t)}})},function(t,n,r){"use strict";var e=r(1),i=r(3),o=r(52),u=r(143)(),c=r(7)("observable"),f=r(26),a=r(2),s=r(68),l=r(73),h=r(27),v=r(79),p=v.RETURN,d=function(t){return null==t?void 0:f(t)},y=function(t){var n=t._c;n&&(t._c=void 0,n())},g=function(t){return void 0===t._o},b=function(t){g(t)||(t._o=void 0,y(t))},m=function(t,n){a(t),this._c=void 0,this._o=t,t=new x(this);try{var r=n(t),e=r;null!=r&&("function"==typeof r.unsubscribe?r=function(){e.unsubscribe()}:f(r),this._c=r)}catch(n){return void t.error(n)}g(this)&&y(this)};m.prototype=l({},{unsubscribe:function(){b(this)}});var x=function(t){this._s=t};x.prototype=l({},{next:function(t){var n=this._s;if(!g(n)){var r=n._o;try{var e=d(r.next);if(e)return e.call(r,t)}catch(t){try{b(n)}finally{throw t}}}},error:function(t){var n=this._s;if(g(n))throw t;var r=n._o;n._o=void 0;try{var e=d(r.error);if(!e)throw t;t=e.call(r,t)}catch(t){try{y(n)}finally{throw t}}return y(n),t},complete:function(t){var n=this._s;if(!g(n)){var r=n._o;n._o=void 0;try{var e=d(r.complete);t=e?e.call(r,t):void 0}catch(t){try{y(n)}finally{throw t}}return y(n),t}}});var w=function(t){s(this,w,"Observable","_f")._f=f(t)};l(w.prototype,{subscribe:function(t){return new m(t,this._f)},forEach:function(t){var n=this;return new(o.Promise||i.Promise)(function(r,e){f(t);var i=n.subscribe({next:function(n){try{return t(n)}catch(t){e(t),i.unsubscribe()}},error:e,complete:r})})}}),l(w,{from:function(t){var n="function"==typeof this?this:w,r=d(a(t)[c]);if(r){var e=a(r.call(t));return e.constructor===n?e:new n(function(t){return e.subscribe(t)})}return new n(function(n){var r=!1;return u(function(){if(!r){try{if(v(t,!1,function(t){if(n.next(t),r)return p})===p)return}catch(t){if(r)throw t;return void n.error(t)}n.complete()}}),function(){r=!0}})},of:function(){for(var t=0,n=arguments.length,r=Array(n);t<n;)r[t]=arguments[t++];return new("function"==typeof this?this:w)(function(t){var n=!1;return u(function(){if(!n){for(var e=0;e<r.length;++e)if(t.next(r[e]),n)return;t.complete()}}),function(){n=!0}})}}),h(w.prototype,c,function(){return this}),e(e.G,{Observable:w}),r(74)("Observable")},function(t,n,r){var e=r(54),i=r(2),o=e.key,u=e.set;e.exp({defineMetadata:function(t,n,r,e){u(t,n,i(r),o(e))}})},function(t,n,r){var e=r(54),i=r(2),o=e.key,u=e.map,c=e.store;e.exp({deleteMetadata:function(t,n){var r=arguments.length<3?void 0:o(arguments[2]),e=u(i(n),r,!1);if(void 0===e||!e.delete(t))return!1;if(e.size)return!0;var f=c.get(n);return f.delete(r),!!f.size||c.delete(n)}})},function(t,n,r){var e=r(185),i=r(161),o=r(54),u=r(2),c=r(32),f=o.keys,a=o.key,s=function(t,n){var r=f(t,n),o=c(t);if(null===o)return r;var u=s(o,n);return u.length?r.length?i(new e(r.concat(u))):u:r};o.exp({getMetadataKeys:function(t){return s(u(t),arguments.length<2?void 0:a(arguments[1]))}})},function(t,n,r){var e=r(54),i=r(2),o=r(32),u=e.has,c=e.get,f=e.key,a=function(t,n,r){if(u(t,n,r))return c(t,n,r);var e=o(n);return null!==e?a(t,e,r):void 0};e.exp({getMetadata:function(t,n){return a(t,i(n),arguments.length<3?void 0:f(arguments[2]))}})},function(t,n,r){var e=r(54),i=r(2),o=e.keys,u=e.key;e.exp({getOwnMetadataKeys:function(t){
return o(i(t),arguments.length<2?void 0:u(arguments[1]))}})},function(t,n,r){var e=r(54),i=r(2),o=e.get,u=e.key;e.exp({getOwnMetadata:function(t,n){return o(t,i(n),arguments.length<3?void 0:u(arguments[2]))}})},function(t,n,r){var e=r(54),i=r(2),o=r(32),u=e.has,c=e.key,f=function(t,n,r){if(u(t,n,r))return!0;var e=o(n);return null!==e&&f(t,e,r)};e.exp({hasMetadata:function(t,n){return f(t,i(n),arguments.length<3?void 0:c(arguments[2]))}})},function(t,n,r){var e=r(54),i=r(2),o=e.has,u=e.key;e.exp({hasOwnMetadata:function(t,n){return o(t,i(n),arguments.length<3?void 0:u(arguments[2]))}})},function(t,n,r){var e=r(54),i=r(2),o=r(26),u=e.key,c=e.set;e.exp({metadata:function(t,n){return function(r,e){c(t,n,(void 0!==e?i:o)(r),u(e))}}})},function(t,n,r){var e=r(1);e(e.P+e.R,"Set",{toJSON:r(165)("Set")})},function(t,n,r){"use strict";var e=r(1),i=r(147)(!0);e(e.P,"String",{at:function(t){return i(this,t)}})},function(t,n,r){"use strict";var e=r(1),i=r(46),o=r(16),u=r(122),c=r(120),f=RegExp.prototype,a=function(t,n){this._r=t,this._s=n};r(139)(a,"RegExp String",function(){var t=this._r.exec(this._s);return{value:t,done:null===t}}),e(e.P,"String",{matchAll:function(t){if(i(this),!u(t))throw TypeError(t+" is not a regexp!");var n=String(this),r="flags"in f?String(t.flags):c.call(t),e=new RegExp(t.source,~r.indexOf("g")?r:"g"+r);return e.lastIndex=o(t.lastIndex),new a(e,n)}})},function(t,n,r){"use strict";var e=r(1),i=r(181);e(e.P,"String",{padEnd:function(t){return i(this,t,arguments.length>1?arguments[1]:void 0,!1)}})},function(t,n,r){"use strict";var e=r(1),i=r(181);e(e.P,"String",{padStart:function(t){return i(this,t,arguments.length>1?arguments[1]:void 0,!0)}})},function(t,n,r){"use strict";r(82)("trimLeft",function(t){return function(){return t(this,1)}},"trimStart")},function(t,n,r){"use strict";r(82)("trimRight",function(t){return function(){return t(this,2)}},"trimEnd")},function(t,n,r){r(153)("asyncIterator")},function(t,n,r){r(153)("observable")},function(t,n,r){var e=r(1);e(e.S,"System",{global:r(3)})},function(t,n,r){for(var e=r(155),i=r(28),o=r(3),u=r(27),c=r(80),f=r(7),a=f("iterator"),s=f("toStringTag"),l=c.Array,h=["NodeList","DOMTokenList","MediaList","StyleSheetList","CSSRuleList"],v=0;v<5;v++){var p,d=h[v],y=o[d],g=y&&y.prototype;if(g){g[a]||u(g,a,l),g[s]||u(g,s,d),c[d]=l;for(p in e)g[p]||i(g,p,e[p],!0)}}},function(t,n,r){var e=r(1),i=r(151);e(e.G+e.B,{setImmediate:i.set,clearImmediate:i.clear})},function(t,n,r){var e=r(3),i=r(1),o=r(121),u=r(207),c=e.navigator,f=!!c&&/MSIE .\./.test(c.userAgent),a=function(t){return f?function(n,r){return t(o(u,[].slice.call(arguments,2),"function"==typeof n?n:Function(n)),r)}:t};i(i.G+i.B+i.F*f,{setTimeout:a(e.setTimeout),setInterval:a(e.setInterval)})},function(t,n,r){r(330),r(269),r(271),r(270),r(273),r(275),r(280),r(274),r(272),r(282),r(281),r(277),r(278),r(276),r(268),r(279),r(283),r(284),r(236),r(238),r(237),r(286),r(285),r(256),r(266),r(267),r(257),r(258),r(259),r(260),r(261),r(262),r(263),r(264),r(265),r(239),r(240),r(241),r(242),r(243),r(244),r(245),r(246),r(247),r(248),r(249),r(250),r(251),r(252),r(253),r(254),r(255),r(317),r(322),r(329),r(320),r(312),r(313),r(318),r(323),r(325),r(308),r(309),r(310),r(311),r(314),r(315),r(316),r(319),r(321),r(324),r(326),r(327),r(328),r(231),r(233),r(232),r(235),r(234),r(220),r(218),r(224),r(221),r(227),r(229),r(217),r(223),r(214),r(228),r(212),r(226),r(225),r(219),r(222),r(211),r(213),r(216),r(215),r(230),r(155),r(302),r(307),r(184),r(303),r(304),r(305),r(306),r(287),r(183),r(185),r(186),r(342),r(331),r(332),r(337),r(340),r(341),r(335),r(338),r(336),r(339),r(333),r(334),r(288),r(289),r(290),r(291),r(292),r(295),r(293),r(294),r(296),r(297),r(298),r(299),r(301),r(300),r(343),r(369),r(372),r(371),r(373),r(374),r(370),r(375),r(376),r(354),r(357),r(353),r(351),r(352),r(355),r(356),r(346),r(368),r(377),r(345),r(347),r(349),r(348),r(350),r(359),r(360),r(362),r(361),r(364),r(363),r(365),r(366),r(367),r(344),r(358),r(380),r(379),r(378),t.exports=r(52)},function(t,n){function r(t,n){if("string"==typeof n)return t.insertAdjacentHTML("afterend",n);var r=t.nextSibling;return r?t.parentNode.insertBefore(n,r):t.parentNode.appendChild(n)}t.exports=r},,,,,,,,,function(t,n,r){(function(n,r){!function(n){"use strict";function e(t,n,r,e){var i=n&&n.prototype instanceof o?n:o,u=Object.create(i.prototype),c=new p(e||[]);return u._invoke=s(t,r,c),u}function i(t,n,r){try{return{type:"normal",arg:t.call(n,r)}}catch(t){return{type:"throw",arg:t}}}function o(){}function u(){}function c(){}function f(t){["next","throw","return"].forEach(function(n){t[n]=function(t){return this._invoke(n,t)}})}function a(t){function n(r,e,o,u){var c=i(t[r],t,e);if("throw"!==c.type){var f=c.arg,a=f.value;return a&&"object"==typeof a&&m.call(a,"__await")?Promise.resolve(a.__await).then(function(t){n("next",t,o,u)},function(t){n("throw",t,o,u)}):Promise.resolve(a).then(function(t){f.value=t,o(f)},u)}u(c.arg)}function e(t,r){function e(){return new Promise(function(e,i){n(t,r,e,i)})}return o=o?o.then(e,e):e()}"object"==typeof r&&r.domain&&(n=r.domain.bind(n));var o;this._invoke=e}function s(t,n,r){var e=P;return function(o,u){if(e===F)throw new Error("Generator is already running");if(e===M){if("throw"===o)throw u;return y()}for(r.method=o,r.arg=u;;){var c=r.delegate;if(c){var f=l(c,r);if(f){if(f===A)continue;return f}}if("next"===r.method)r.sent=r._sent=r.arg;else if("throw"===r.method){if(e===P)throw e=M,r.arg;r.dispatchException(r.arg)}else"return"===r.method&&r.abrupt("return",r.arg);e=F;var a=i(t,n,r);if("normal"===a.type){if(e=r.done?M:j,a.arg===A)continue;return{value:a.arg,done:r.done}}"throw"===a.type&&(e=M,r.method="throw",r.arg=a.arg)}}}function l(t,n){var r=t.iterator[n.method];if(r===g){if(n.delegate=null,"throw"===n.method){if(t.iterator.return&&(n.method="return",n.arg=g,l(t,n),"throw"===n.method))return A;n.method="throw",n.arg=new TypeError("The iterator does not provide a 'throw' method")}return A}var e=i(r,t.iterator,n.arg);if("throw"===e.type)return n.method="throw",n.arg=e.arg,n.delegate=null,A;var o=e.arg;return o?o.done?(n[t.resultName]=o.value,n.next=t.nextLoc,"return"!==n.method&&(n.method="next",n.arg=g),n.delegate=null,A):o:(n.method="throw",n.arg=new TypeError("iterator result is not an object"),n.delegate=null,A)}function h(t){var n={tryLoc:t[0]};1 in t&&(n.catchLoc=t[1]),2 in t&&(n.finallyLoc=t[2],n.afterLoc=t[3]),this.tryEntries.push(n)}function v(t){var n=t.completion||{};n.type="normal",delete n.arg,t.completion=n}function p(t){this.tryEntries=[{tryLoc:"root"}],t.forEach(h,this),this.reset(!0)}function d(t){if(t){var n=t[w];if(n)return n.call(t);if("function"==typeof t.next)return t;if(!isNaN(t.length)){var r=-1,e=function n(){for(;++r<t.length;)if(m.call(t,r))return n.value=t[r],n.done=!1,n;return n.value=g,n.done=!0,n};return e.next=e}}return{next:y}}function y(){return{value:g,done:!0}}var g,b=Object.prototype,m=b.hasOwnProperty,x="function"==typeof Symbol?Symbol:{},w=x.iterator||"@@iterator",S=x.asyncIterator||"@@asyncIterator",_=x.toStringTag||"@@toStringTag",O="object"==typeof t,E=n.regeneratorRuntime;if(E)return void(O&&(t.exports=E));E=n.regeneratorRuntime=O?t.exports:{},E.wrap=e;var P="suspendedStart",j="suspendedYield",F="executing",M="completed",A={},N={};N[w]=function(){return this};var T=Object.getPrototypeOf,I=T&&T(T(d([])));I&&I!==b&&m.call(I,w)&&(N=I);var k=c.prototype=o.prototype=Object.create(N);u.prototype=k.constructor=c,c.constructor=u,c[_]=u.displayName="GeneratorFunction",E.isGeneratorFunction=function(t){var n="function"==typeof t&&t.constructor;return!!n&&(n===u||"GeneratorFunction"===(n.displayName||n.name))},E.mark=function(t){return Object.setPrototypeOf?Object.setPrototypeOf(t,c):(t.__proto__=c,_ in t||(t[_]="GeneratorFunction")),t.prototype=Object.create(k),t},E.awrap=function(t){return{__await:t}},f(a.prototype),a.prototype[S]=function(){return this},E.AsyncIterator=a,E.async=function(t,n,r,i){var o=new a(e(t,n,r,i));return E.isGeneratorFunction(n)?o:o.next().then(function(t){return t.done?t.value:o.next()})},f(k),k[_]="Generator",k.toString=function(){return"[object Generator]"},E.keys=function(t){var n=[];for(var r in t)n.push(r);return n.reverse(),function r(){for(;n.length;){var e=n.pop();if(e in t)return r.value=e,r.done=!1,r}return r.done=!0,r}},E.values=d,p.prototype={constructor:p,reset:function(t){if(this.prev=0,this.next=0,this.sent=this._sent=g,this.done=!1,this.delegate=null,this.method="next",this.arg=g,this.tryEntries.forEach(v),!t)for(var n in this)"t"===n.charAt(0)&&m.call(this,n)&&!isNaN(+n.slice(1))&&(this[n]=g)},stop:function(){this.done=!0;var t=this.tryEntries[0],n=t.completion;if("throw"===n.type)throw n.arg;return this.rval},dispatchException:function(t){function n(n,e){return o.type="throw",o.arg=t,r.next=n,e&&(r.method="next",r.arg=g),!!e}if(this.done)throw t;for(var r=this,e=this.tryEntries.length-1;e>=0;--e){var i=this.tryEntries[e],o=i.completion;if("root"===i.tryLoc)return n("end");if(i.tryLoc<=this.prev){var u=m.call(i,"catchLoc"),c=m.call(i,"finallyLoc");if(u&&c){if(this.prev<i.catchLoc)return n(i.catchLoc,!0);if(this.prev<i.finallyLoc)return n(i.finallyLoc)}else if(u){if(this.prev<i.catchLoc)return n(i.catchLoc,!0)}else{if(!c)throw new Error("try statement without catch or finally");if(this.prev<i.finallyLoc)return n(i.finallyLoc)}}}},abrupt:function(t,n){for(var r=this.tryEntries.length-1;r>=0;--r){var e=this.tryEntries[r];if(e.tryLoc<=this.prev&&m.call(e,"finallyLoc")&&this.prev<e.finallyLoc){var i=e;break}}i&&("break"===t||"continue"===t)&&i.tryLoc<=n&&n<=i.finallyLoc&&(i=null);var o=i?i.completion:{};return o.type=t,o.arg=n,i?(this.method="next",this.next=i.finallyLoc,A):this.complete(o)},complete:function(t,n){if("throw"===t.type)throw t.arg;return"break"===t.type||"continue"===t.type?this.next=t.arg:"return"===t.type?(this.rval=this.arg=t.arg,this.method="return",this.next="end"):"normal"===t.type&&n&&(this.next=n),A},finish:function(t){for(var n=this.tryEntries.length-1;n>=0;--n){var r=this.tryEntries[n];if(r.finallyLoc===t)return this.complete(r.completion,r.afterLoc),v(r),A}},catch:function(t){for(var n=this.tryEntries.length-1;n>=0;--n){var r=this.tryEntries[n];if(r.tryLoc===t){var e=r.completion;if("throw"===e.type){var i=e.arg;v(r)}return i}}throw new Error("illegal catch attempt")},delegateYield:function(t,n,r){return this.delegate={iterator:d(t),resultName:n,nextLoc:r},"next"===this.method&&(this.arg=g),A}}}("object"==typeof n?n:"object"==typeof window?window:"object"==typeof self?self:this)}).call(n,function(){return this}(),r(158))}])</script><script src="/./main.0cf68a.js"></script><script>!function(){!function(e){var t=document.createElement("script");document.getElementsByTagName("body")[0].appendChild(t),t.setAttribute("src",e)}("/slider.e37972.js")}()</script>


<script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
});

MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';                 
    }       
});
</script>

<script src="//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


    
<div class="tools-col" q-class="show:isShow,hide:isShow|isFalse" q-on="click:stop(e)">
  <div class="tools-nav header-menu">
    
    
      
      
      
    
      
      
      
    
      
      
      
    
    

    <ul style="width: 70%">
    
    
      
      <li style="width: 33.333333333333336%" q-on="click: openSlider(e, 'innerArchive')"><a href="javascript:void(0)" q-class="active:innerArchive">所有文章</a></li>
      
        
      
      <li style="width: 33.333333333333336%" q-on="click: openSlider(e, 'friends')"><a href="javascript:void(0)" q-class="active:friends">友链</a></li>
      
        
      
      <li style="width: 33.333333333333336%" q-on="click: openSlider(e, 'aboutme')"><a href="javascript:void(0)" q-class="active:aboutme">关于我</a></li>
      
        
    </ul>
  </div>
  <div class="tools-wrap">
    
    	<section class="tools-section tools-section-all" q-show="innerArchive">
        <div class="search-wrap">
          <input class="search-ipt" q-model="search" type="text" placeholder="find something…">
          <i class="icon-search icon" q-show="search|isEmptyStr"></i>
          <i class="icon-close icon" q-show="search|isNotEmptyStr" q-on="click:clearChose(e)"></i>
        </div>
        <div class="widget tagcloud search-tag">
          <p class="search-tag-wording">tag:</p>
          <label class="search-switch">
            <input type="checkbox" q-on="click:toggleTag(e)" q-attr="checked:showTags">
          </label>
          <ul class="article-tag-list" q-show="showTags">
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color4">备忘录</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color5">做题笔记</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color3">题解</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color5">学习笔记</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color3">游记</a>
              </li>
            
            <div class="clearfix"></div>
          </ul>
        </div>
        <ul class="search-ul">
          <p q-show="jsonFail" style="padding: 20px; font-size: 12px;">
            缺失模块。<br/>1、请确保node版本大于6.2<br/>2、在博客根目录（注意不是yilia根目录）执行以下命令：<br/> npm i hexo-generator-json-content --save<br/><br/>
            3、在根目录_config.yml里添加配置：
<pre style="font-size: 12px;" q-show="jsonFail">
  jsonContent:
    meta: false
    pages: false
    posts:
      title: true
      date: true
      path: true
      text: false
      raw: false
      content: false
      slug: false
      updated: false
      comments: false
      link: false
      permalink: false
      excerpt: false
      categories: false
      tags: true
</pre>
          </p>
          <li class="search-li" q-repeat="items" q-show="isShow">
            <a q-attr="href:path|urlformat" class="search-title"><i class="icon-quo-left icon"></i><span q-text="title"></span></a>
            <p class="search-time">
              <i class="icon-calendar icon"></i>
              <span q-text="date|dateformat"></span>
            </p>
            <p class="search-tag">
              <i class="icon-price-tags icon"></i>
              <span q-repeat="tags" q-on="click:choseTag(e, name)" q-text="name|tagformat"></span>
            </p>
          </li>
        </ul>
    	</section>
    

    
    	<section class="tools-section tools-section-friends" q-show="friends">
  		
        <ul class="search-ul">
          
            <li class="search-li">
              <a href="http://localhost:4000/" target="_blank" class="search-title"><i class="icon-quo-left icon"></i>友情链接1</a>
            </li>
          
            <li class="search-li">
              <a href="http://localhost:4000/" target="_blank" class="search-title"><i class="icon-quo-left icon"></i>友情链接2</a>
            </li>
          
            <li class="search-li">
              <a href="http://localhost:4000/" target="_blank" class="search-title"><i class="icon-quo-left icon"></i>友情链接3</a>
            </li>
          
            <li class="search-li">
              <a href="http://localhost:4000/" target="_blank" class="search-title"><i class="icon-quo-left icon"></i>友情链接4</a>
            </li>
          
            <li class="search-li">
              <a href="http://localhost:4000/" target="_blank" class="search-title"><i class="icon-quo-left icon"></i>友情链接5</a>
            </li>
          
            <li class="search-li">
              <a href="http://localhost:4000/" target="_blank" class="search-title"><i class="icon-quo-left icon"></i>友情链接6</a>
            </li>
          
        </ul>
  		
    	</section>
    

    
    	<section class="tools-section tools-section-me" q-show="aboutme">
  	  	
  	  		<div class="aboutme-wrap" id="js-aboutme">很惭愧&lt;br&gt;&lt;br&gt;只做了一点微小的工作&lt;br&gt;谢谢大家</div>
  	  	
    	</section>
    
  </div>
  
</div>
    <!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                      <div class="pswp__preloader__cut">
                        <div class="pswp__preloader__donut"></div>
                      </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div> 
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>
  </div>
</body>
</html>